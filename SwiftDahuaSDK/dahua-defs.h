//
//  dahua-defs.h
//  ACC
//
//  Created by Shoaib Ahmed on 8/21/16.
//  Copyright © 2016 Kindows Tech Solutions. All rights reserved.
//

#ifndef dahua_defs_h
#define dahua_defs_h


#if (defined(WIN32) || defined(WIN64))
#include <windows.h>
#ifdef NETSDK_EXPORTS

#ifndef CLIENT_API
#define CLIENT_API  __declspec(dllexport)
#endif

#else

#ifndef CLIENT_API
#define CLIENT_API  __declspec(dllimport)
#endif

#endif

#define CALLBACK __stdcall
#define CALL_METHOD  __stdcall  //__cdecl

#define INT64    __int64

#ifndef LLONG
#ifdef WIN64
#define LLONG INT64
#else
#define LLONG LONG
#endif
#endif

#ifndef LDWORD
#ifdef WIN64
#define LDWORD INT64
#else
#define LDWORD DWORD
#endif
#endif

#else    //non-windows

#define CLIENT_API    extern "C"
#define CALL_METHOD
#define CALLBACK

#ifndef INTERNAL_COMPILE
#define RELEASE_HEADER
#endif

#ifdef RELEASE_HEADER

#define WORD        unsigned short
#define DWORD       unsigned int
#define LONG        int
#define LPDWORD     DWORD*
#ifdef __OBJC__
#include "objc/objc.h"
#else
#define BOOL        int
#endif
#ifndef TRUE
#define TRUE        1
#endif
#ifndef FALSE
#define FALSE       0
#endif
#define BYTE        unsigned char
#define UINT        unsigned int
#define HDC         void*
#define HWND        void*
#define LPVOID      void*
#ifndef NULL
#define NULL        0
#endif
#define LLONG       long
#define INT64       long long
#define LDWORD      long

#ifndef MAX_PATH
#define MAX_PATH    260
#endif

#ifndef DEF_RECT
typedef struct  tagRECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT;
#define DEF_RECT
#endif

#else	//Internal translation

#include "../Platform/osIndependent.h"
#endif

#endif

#ifndef LDWORD
#if (defined(WIN32) || defined(WIN64))
#ifdef WIN64
#define LDWORD __int64
#else //WIN32
#define LDWORD DWORD
#endif
#else    //linux
#define LDWORD long
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif
    
    /************************************************************************
     ** Constant Definition
     ***********************************************************************/
#define DH_SERIALNO_LEN             48          // Device SN string length
#define DH_MAX_DISKNUM 				256			// Max HDD number
#define DH_MAX_SDCARDNUM			32			// Max SD card number
#define DH_MAX_BURNING_DEV_NUM		32			// Max buner amount
#define DH_BURNING_DEV_NAMELEN		32			// Burner name max length
#define DH_MAX_LINK 				6
#define DH_MAX_CHANNUM 				16			// Max channel amount
#define DH_MAX_DECODER_CHANNUM		64			// decoder device max channel number
#define DH_MAX_ALARMIN 				128			// Max alarm input amount
#define DH_MAX_ALARMOUT 			64			// Max alarm output amount
#define DH_MAX_RIGHT_NUM			100			// Max user right amount
#define DH_MAX_GROUP_NUM			20			// Max user group amount
#define DH_MAX_USER_NUM				200			// Max user account amount
#define DH_RIGHT_NAME_LENGTH		32			// Right name length
#define DH_USER_NAME_LENGTH			8			// User name length
#define DH_USER_PSW_LENGTH			8			// User password length
#define DH_MEMO_LENGTH				32			// Note length
#define DH_MAX_STRING_LEN			128
#define MAX_STRING_LINE_LEN			6			// Max six rows
#define MAX_PER_STRING_LEN			20			// Line max length
#define DH_MAX_MAIL_NAME_LEN		64			// The user name length the new mail structure supported
#define DH_MAX_MAIL_PSW_LEN			64			// Password length the new mail structhre supported
#define DH_SPEEDLIMIT_TYPE_LEN      32          // speed limit string max length
#define DH_VEHICLE_TYPE_LEN         32          // vehicle info type max length
#define DH_VEHICLE_INFO_LEN         32          // vehicle info string max length
#define DH_VEHICLE_DRIVERNO_LEN     32          // Driver no string max length=
#define DH_MAX_CROSSING_NUM         128         // Max supported crossing num
#define DH_MAX_CROSSING_ID          32          // Max crossing ID length
#define DH_MAX_CARD_INFO_LEN		256			// max card info length
#define DH_MAX_CHANNUM_EX           32          // extended max channel number
#define DH_MAX_SAERCH_IP_NUM        256         // max number of IP for saerch
#define DH_MAX_HARDDISK_TYPE_LEN	32			// hard disk type maximum length
#define DH_MAX_HARDDISK_SERIAL_LEN	32			// hard disk serial maximum length
#define DH_MAX_SIM_LEN				16			// value of SIM maximum length
#define DH_MAX_SIM_NUM				10			// pick up SIM maximum number
#define DH_MAX_VERSION_LEN			32			// version maximum length
#define DH_MAX_MDN_LEN				36			// value of MDN maximum length
#define DH_MAX_NETINTERFACE_NUM     64          // support the card number
#define DH_EVENT_NAME_LEN			128			// length of event name
#define DH_STORAGE_NAME_LEN			128			// length of storage name
#define DH_MAX_CARPORTLIGHT_NUM     4           // carport liht maximum number
#define DH_STATION_NAME_LEN         32          // length of station name
#define	PTZ_PRESET_NAME_LEN         64			// Length of PTZ preset name
#define DH_MAX_GUARD_DETECT_ID_COUNT	  64			   // Max Station Detection ID Number
    
#define DH_MAX_VERSION_STR			64			// Max length of version string
    
#define DH_COMMON_STRING_16			16          // Common string length 16
#define DH_COMMON_STRING_32			32          // Common string length 32
#define DH_COMMON_STRING_64			64          // Common string length 64
#define DH_COMMON_STRING_128		128         // Common string length 128
#define DH_COMMON_STRING_256		256         // Common string length 256
#define DH_COMMON_STRING_512		512         // Common string length 512
#define DH_COMMON_STRING_1024		1024        // Common string length 1024
    
#define DH_MAX_ACCESS_NAME_LEN		64			// Length of access name
#define DH_MAX_EXALARMCHANNEL_NAME_LEN	 128	// length of extension module alarm channel name
#define DH_MAX_ALARM_SUBSYSTEM_NUM  8           // Max Alarm Sub System Number
#define DH_MAX_BELL_NUM             4           // Max Bell Number
#define DH_MAX_KEYBOARD_NUM         256         // Max Keyboard Number
#define MAX_GOURP_NUM               128         //Face library max number
    
    // Remote configuration structure corresponding constant
#define DH_MAX_MAIL_ADDR_LEN		128			// Mail address max length
#define DH_MAX_MAIL_SUBJECT_LEN		64			// Mail subject max length
#define DH_MAX_IPADDR_LEN			16			// IP address string length
#define DH_MAX_IPADDR_LEN_EX		40			// extension Ip address support IPV6
#define DH_MACADDR_LEN				40			// MACE address string length
#define DH_MAX_URL_LEN				128			// URL string length
#define DH_MAX_DEV_ID_LEN			48			// Device serial number max length
#define	DH_MAX_HOST_NAMELEN			64			// Host name length
#define DH_MAX_HOST_PSWLEN			32			// Password length
#define DH_MAX_NAME_LEN				16			// Universal name string length
#define DH_MAX_ETHERNET_NUM			2			// Ethernet max amount
#define DH_MAX_ETHERNET_NUM_EX	    10			// extended ethernet max amout
#define	DH_DEV_SERIALNO_LEN			48			// Serial number string length
#define DH_DEV_TYPE_LEN				32			// Device type string length
#define DH_N_WEEKS					7			// The days in one week
#define DH_N_TSECT					6			// Time period amount
#define DH_N_REC_TSECT				6			// Record period amount
#define DH_N_COL_TSECT				2			// Color period amount
#define DH_CHAN_NAME_LEN			32			// Channel name lengh. DVR DSP capacity limit. Max 32 bytes.
#define DH_N_ENCODE_AUX				3			// Extra stream amount
#define DH_N_TALK					1			// Max audio talk channel amount
#define DH_N_COVERS					1			// Privacy mask zone amount
#define DH_N_CHANNEL				16			// Max channel amount
#define DH_N_ALARM_TSECT			2			// Alarm prompt period amount
#define DH_MAX_ALARMOUT_NUM			16			// Alarm output ports max amount
#define DH_MAX_AUDIO_IN_NUM			16			// Audio input ports max amount
#define DH_MAX_VIDEO_IN_NUM			16			// Video input ports max amount
#define DH_MAX_ALARM_IN_NUM			16			// Alarm input ports max amount
#define DH_MAX_DISK_NUM				16			// HDD max amount. Now the value is 16.
#define DH_MAX_DECODER_NUM			16			// Decoder(485) max amount
#define DH_MAX_232FUNCS				10			// 232 COM function max amount
#define DH_MAX_232_NUM				2			// 232 COM port max amount
#define DH_MAX_232_NUM_EX           16          // extended 232 COM port max amount
#define DH_MAX_DECPRO_LIST_SIZE		100			// Decoder protocol list max amount
#define DH_FTP_MAXDIRLEN			240			// FTP file folder max length
#define DH_MATRIX_MAXOUT			16			// Matrix output ports max amount
#define DH_TOUR_GROUP_NUM			6			// Matrix output ports max amount
#define DH_MAX_DDNS_NUM				10			// ddns max amount the device supported
#define DH_MAX_SERVER_TYPE_LEN		32			// ddns type and max string length
#define DH_MAX_DOMAIN_NAME_LEN		256			// ddns domain name and max string length
#define DH_MAX_DDNS_ALIAS_LEN		32			// ddns alias and max string length
#define DH_MAX_DEFAULT_DOMAIN_LEN	60			// ddns default domain, max sring length
#define DH_MOTION_ROW				32			// Motion detection zone row amount
#define DH_MOTION_COL				32			// Motion detection zone column amount
#define DH_STATIC_ROW				32			// Static detection zone row amount
#define DH_STATIC_COL				32			// Static detection zone column amount
#define	DH_FTP_USERNAME_LEN			64			// FTP setup:user name max lengh
#define	DH_FTP_PASSWORD_LEN			64			// FTP setup:password max length
#define	DH_TIME_SECTION				2			// FTP setup:time periods in each day.
#define DH_FTP_MAX_PATH				240			// FTP setup:file path max length
#define DH_FTP_MAX_SUB_PATH			128 		// FTP setup:sub path max lenth
#define DH_INTERVIDEO_UCOM_CHANID	32			// Platform embedded setup:U China Net Communication (CNC)channel ID
#define DH_INTERVIDEO_UCOM_DEVID	32			// Platform embedded setup:UCNC device ID
#define DH_INTERVIDEO_UCOM_REGPSW	16			// Platform embedded setup:UCNC registration password
#define DH_INTERVIDEO_UCOM_USERNAME	32			// Platform embedded setup:UCNC user name
#define DH_INTERVIDEO_UCOM_USERPSW	32			// Platform embedded setup: UCNC password
#define DH_INTERVIDEO_NSS_IP		32			// Platform embedded setup:ZTE Netview IP
#define DH_INTERVIDEO_NSS_SERIAL	32			// Serial Platform embedded setup:ZTE Netview  serial
#define DH_INTERVIDEO_NSS_USER		32			// User Platform embedded setup:ZTE Netview user
#define DH_INTERVIDEO_NSS_PWD		50			// Password Platform embedded setup:ZTE Netview password
#define DH_MAX_VIDEO_COVER_NUM		16			// Privacy mask zones max amount
#define DH_MAX_WATERMAKE_DATA		4096		// Watermark data max length
#define DH_MAX_WATERMAKE_LETTER		128			// Watermark text max length
#define DH_MAX_WLANDEVICE_NUM		10			// Max searched wireless device amount
#define DH_MAX_WLANDEVICE_NUM_EX	32			// Max searched wireless device amount
#define DH_MAX_ALARM_NAME			64			// Address length
#define DH_MAX_REGISTER_SERVER_NUM	10			// Auto registration server amount
#define DH_SNIFFER_FRAMEID_NUM		6			// 6 FRAME ID options
#define DH_SNIFFER_CONTENT_NUM		4			// 4 sniffer in each FRAME
#define DH_SNIFFER_CONTENT_NUM_EX	8			// 8 sniffer in each FRAME
#define DH_SNIFFER_PROTOCOL_SIZE	20			// protocol length
#define DH_MAX_PROTOCOL_NAME_LENGTH 20
#define DH_SNIFFER_GROUP_NUM		4			// 4 group sniffer setup
#define MAX_PATH_STOR				240			// Remote folder length
#define DH_ALARM_OCCUR_TIME_LEN		40			// New alarm upload time length
#define DH_VIDEO_OSD_NAME_NUM		64			// Overlay name length. Now it supports 32-digit English and 16-digit Chinese.
#define DH_VIDEO_CUSTOM_OSD_NUM		8			// The self-defined amount supported excluding time and channel.
#define DH_CONTROL_AUTO_REGISTER_NUM 100        // Targeted initiatives to support the number of registration servers
#define DH_MMS_RECEIVER_NUM          100        // Support the number of messages the recipient
#define DH_MMS_SMSACTIVATION_NUM     100        // Support the number of SMS sender
#define DH_MMS_DIALINACTIVATION_NUM  100        // Support for dial-up number of the sender
#define DH_MAX_ALARMOUT_NUM_EX		 32			// Alarm output amount max limit
#define DH_MAX_VIDEO_IN_NUM_EX		 32			// Video input amount max limit
#define DH_MAX_ALARM_IN_NUM_EX		 32			// Alarm input amount max limit
#define DH_MAX_IPADDR_OR_DOMAIN_LEN	 64			// IP or domain name length
#define DH_MAX_CALLID				 32         // Call ID
#define DH_MAX_OBJECT_LIST				 16			// the upper limit number of object id that detected by device in intelligent analysis
#define DH_MAX_RULE_LIST				 16			// the upper limit number of device rule in intelligent analysis
#define DH_MAX_POLYGON_NUM				 16			// the max number of polygon's culmination
#define DH_MAX_DETECT_LINE_NUM       20          // rule detect line's max point number
#define DH_MAX_DETECT_REGION_NUM     20          // rule detect region's max point number
#define DH_MAX_TRACK_LINE_NUM        20         // object moving track's max point number
#define DH_MAX_CANDIDATE_NUM         50         // max candidate number
#define DH_MAX_PERSON_IMAGE_NUM      48         // max image of ervery person
#define DH_MAX_FENCE_LINE_NUM        2          // max fance line number
#define MAX_SMART_VALUE_NUM          30         // the max number of smart disk information
#define DH_MACHINE_NAME_NUM			 64         // Device name length
#define DH_INTERVIDEO_AMP_DEVICESERIAL    48    // Platform embedded setup, AMP,Device serial num length
#define DH_INTERVIDEO_AMP_DEVICENAME      16    // Platform embedded setup, AMP,Device Name length
#define DH_INTERVIDEO_AMP_USER            32    // Platform embedded setup, AMP,User Name Length
#define DH_INTERVIDEO_AMP_PWD             32    // Platform embedded setup, AMP,password length
#define MAX_SUBMODULE_NUM            32         // Max number of submodule infomation
#define DH_MAX_CARWAY_NUM            8          // traffic snapshot,the max car way number
#define DH_MAX_SNAP_SIGNAL_NUM       3          // one car way max time for snapshot
#define DH_MAX_CARD_NUM              128        // max number of card
#define DH_MAX_CARDINFO_LEN          32         // max lenth of card infomation
#define DH_MAX_CONTROLER_NUM         64         // max supported controller number
#define DH_MAX_LIGHT_NUM             32         // max control light group number
#define DH_MAX_SNMP_COMMON_LEN       64         // max Snmp read or write buffer
#define DH_MAX_DDNS_STATE_LEN        128        // max DDNS state buffer
#define DH_MAX_PHONE_NO_LEN          16         // max phone len
#define DH_MAX_MSGTYPE_LEN           32         // max type len
#define DH_MAX_MSG_LEN               256        // max message len
#define DH_MAX_DRIVINGDIRECTION      256        // max drivingdirection len
#define DH_MAX_GRAB_INTERVAL_NUM     4	        // max snapshot count
#define DH_MAX_FLASH_NUM			 5			// max flash count
#define DH_MAX_LANE_NUM              8          // max number of road in every channel
#define DH_MAX_ISCSI_PATH_NUM		 64			// max ISCSI remote path number
#define DH_MAX_WIRELESS_CHN_NUM		 256		// max wireless channel number
#define DH_PROTOCOL3_BASE			 100		// protocol 3 base value
#define DH_PROTOCOL3_SUPPORT		 11			// prococol 3 support
#define DH_MAX_CHANMASK              64         // max channel mask
#define DH_MAX_STAFF_NUM			 20			// max of compressed video configuration staff number
#define DH_MAX_CALIBRATEBOX_NUM		 10			// max of compressed video configuration calibrate region
#define DH_MAX_EXCLUDEREGION_NUM	 10			// max of compressed video configuration exclude region
#define DH_MAX_POLYLINE_NUM			 20			// number of compressed video configuration poly line
#define	DH_MAX_COLOR_NUM			 16			// color maximum number
#define MAX_OBJFILTER_NUM			 16			// max number of  filter type
#define DH_MAX_SYNOPSIS_STATE_NAME   64         // string state length of compressed video
#define DH_MAX_SYNOPSIS_QUERY_FILE_COUNT	10	// the file number limit
#define DH_MAX_SSID_LEN              36         // length of SSID
#define DH_MAX_APPIN_LEN             16         // length of PIN
#define DH_NETINTERFACE_NAME_LEN     260        // length of net port
#define DH_NETINTERFACE_TYPE_LEN     260        // length of net type
#define DH_MAX_CONNECT_STATUS_LEN    260        // length of connect status
#define DH_MAX_MODE_LEN              64         // length of 3G mode support
#define DH_MAX_MODE_NUM              64         // number of 3G mode support
#define DH_MAX_COMPRESSION_TYPES_NUM  16        // max number of video compression types
#define DH_MAX_CAPTURE_SIZE_NUM      64         // number of video resolution
#define DH_NODE_NAME_LEN			 64			// length of node name
#define MAX_CALIBPOINTS_NUM          256        // max number of point support
#define DH_MAX_ATTR_NUM				 32			// the maximum number display element attributes
#define DH_MAX_CLOUDCONNECT_STATE_LEN 128       // length of cloud connect state
#define DH_MAX_IPADDR_EX_LEN         128        // IP entended maximum length
#define DH_MAX_PLATE_NUMBER_LEN      32         // plate string length
#define DH_MAX_AUTHORITY_LIST_NUM    16         // max in authority list
#define DH_MAX_CITY_NAME_LEN         64         // max length of city name
#define DH_MAX_PROVINCE_NAME_LEN     64         // max length of province name
#define DH_MAX_PERSON_ID_LEN         32         // max length of person ID
#define MAX_FACE_AREA_NUM            8          // max number if face area
#define MAX_FACE_DB_NUM              8          // max number of face DB
#define MAX_EVENT_NAME				128			// max event name
#define DH_MAX_ETH_NAME			     64			// max network card name
#define DH_MAX_PERSON_NAME_LEN       64         // max length of person name
#define DH_N_SCHEDULE_TSECT			 8			// element number of schedule
#define DH_MAX_URL_NUM				 8			// max URL number
#define DH_MAX_LOWER_MITRIX_NUM		16			// max lower mitrix number
#define DH_MAX_BURN_CHANNEL_NUM		32			// max burn channel number
#define DH_MAX_NET_STRORAGE_BLOCK_NUM	64		// max remote storage block number
#define DH_MAX_CASE_PERSON_NUM		32			// max number of case person
#define DH_MAX_MULTIPLAYBACK_CHANNEL_NUM 64     // max channel number of multiplayback channel
#define DH_MAX_MULTIPLAYBACK_SPLIT_NUM   32     // max split number of multipalyback channel
#define DH_MAX_AUDIO_ENCODE_TYPE          64               // Max audio encoding type quantity
#define MAX_LOG_PATH_LEN                  260              // Max log path name length
#define MAX_CARD_RECORD_FIELD_NUM         16               // Card No. Max Domain Quantity
#define DH_BATTERY_NUM_MAX			 16			// max battery number
#define DH_POWER_NUM_MAX			 16			// max power number
#define DH_MAX_AUDIO_PATH			 260		// max path of audio file
#define DH_MAX_DOORNAME_LEN			 128		// max length of door access name
#define DH_MAX_CARDPWD_LEN			 64			// max length of door access name
#define NET_MAX_FISHEYE_MOUNTMODE_NUM   4       // Max fish eye installation mode number
#define NET_MAX_FISHEYE_CALIBRATEMODE_NUM 16    // Max fish eye correction mode numer
#define NET_MAX_FISHEYE_EPTZCMD_NUM    64       // Max fish eye electronic PTZ operation number
#define POINT_NUM_IN_PAIR              2        // Point Number in Pair
#define MAX_POINT_PAIR_NUM            128       // Point Max Quantity
#define CHANNEL_NUM_IN_POINT_GROUP    2         // Point Video Channel Number
#define MAX_POINT_GROUP_NUM           32        // Point Group Max Quantity. Each two channel splicing requires one group of point.
#define MAX_LANE_INFO_NUM             32        // Max lane info number
#define MAX_LANE_DIRECTION_NUM        8         // Lane direction total
#define DH_MAX_MONITORWALL_NUM        32        // TV wall max quantity
#define DH_MAX_OPTIONAL_URL_NUM       8         // Alternate url maxquantity
    
    // Search type, corresponding to CLIENT_QueryDevState
#define DH_DEVSTATE_COMM_ALARM            0x0001           // Search general alarm status(including external alarm,video loss, motion detection)
#define DH_DEVSTATE_SHELTER_ALARM         0x0002           // Search camera masking alarm status
#define DH_DEVSTATE_RECORDING             0x0003           // Search record status
#define DH_DEVSTATE_DISK                  0x0004           // Search HDD information
#define DH_DEVSTATE_RESOURCE              0x0005           // Search system resources status
#define DH_DEVSTATE_BITRATE	              0x0006           // Search channel bit stream
#define DH_DEVSTATE_CONN                  0x0007           // Search device connection status
#define DH_DEVSTATE_PROTOCAL_VER          0x0008           // Search network protocol version number , pBuf = int*
#define DH_DEVSTATE_TALK_ECTYPE	          0x0009           // Search the audio talk format the device supported. Please refer to structure DHDEV_TALKFORMAT_LIST
#define DH_DEVSTATE_SD_CARD	              0x000A           // Search SD card information(FOR IPC series)
#define DH_DEVSTATE_BURNING_DEV           0x000B           // Search burner information
#define DH_DEVSTATE_BURNING_PROGRESS      0x000C           // Search burning information
#define DH_DEVSTATE_PLATFORM              0x000D           // Search the embedded platform the device supported
#define DH_DEVSTATE_CAMERA                0x000E           // Search camera property information ( for IPC series),pBuf = DHDEV_CAMERA_INFO *,there can be several structure.
#define DH_DEVSTATE_SOFTWARE              0x000F           // Search device software version information
#define DH_DEVSTATE_LANGUAGE              0x0010           // Search the audio type the device supported
#define DH_DEVSTATE_DSP                   0x0011           // Search DSP capacity description
#define	DH_DEVSTATE_OEM	                  0x0012           // Search OEM information
#define	DH_DEVSTATE_NET	                  0x0013           // Search network running status information
#define DH_DEVSTATE_TYPE                  0x0014           // Search function attributes(for IPC serirs)
#define DH_DEVSTATE_SNAP                  0x0015           // Search snapshot function attribute(For IPC series)
#define DH_DEVSTATE_RECORD_TIME	          0x0016           // Query the first time and the recent video time
#define DH_DEVSTATE_NET_RSSI              0x0017           // Query the wireless network signal strength,Please refer to structure DHDEV_WIRELESS_RSS_INFO
#define DH_DEVSTATE_BURNING_ATTACH        0x0018           // Burning options inquiry
#define DH_DEVSTATE_BACKUP_DEV            0x0019           // Query the list of backup device
#define DH_DEVSTATE_BACKUP_DEV_INFO	      0x001a           // Query the backup device information
#define DH_DEVSTATE_BACKUP_FEEDBACK	      0x001b           // backup rate of progress
#define DH_DEVSTATE_ATM_QUERY_TRADE       0x001c           // Query ATM trade type
#define DH_DEVSTATE_SIP                   0x001d           // Query sip state
#define DH_DEVSTATE_VICHILE_STATE         0x001e           // Query wifi state of mobile DVR
#define DH_DEVSTATE_TEST_EMAIL            0x001f           // Query Email Function
#define DH_DEVSTATE_SMART_HARD_DISK       0x0020           // Query Hard Disk Information
#define DH_DEVSTATE_TEST_SNAPPICTURE      0x0021           // Query Snap Picture Function
#define DH_DEVSTATE_STATIC_ALARM          0x0022           // Query static alarm state
#define DH_DEVSTATE_SUBMODULE_INFO        0x0023           // Query submodule information
#define DH_DEVSTATE_DISKDAMAGE            0x0024           // Query harddisk damage ability
#define DH_DEVSTATE_IPC                   0x0025           // Query device supported IPC ability,see struct DH_DEV_IPC_INFO
#define DH_DEVSTATE_ALARM_ARM_DISARM      0x0026           // Query alarm arm disarm state
#define DH_DEVSTATE_ACC_POWEROFF_ALARM    0x0027           // Query ACC power off state(return a DWORD type value, 1 means power off,0 means power on)
#define DH_DEVSTATE_TEST_FTP_SERVER       0x0028           // FTP server connect test
#define DH_DEVSTATE_3GFLOW_EXCEED         0x0029           // Query 3G Flow exceed state info(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_DEVSTATE_3GFLOW_INFO           0x002a           // Query 3G Flow info(see struct DH_DEV_3GFLOW_INFO)
#define DH_DEVSTATE_VIHICLE_INFO_UPLOAD   0x002b           // Vihicle information uploading
#define DH_DEVSTATE_SPEED_LIMIT           0x002c           // Speed limit alarm
#define DH_DEVSTATE_DSP_EX                0x002d           // Query DSP expended cap(struct DHDEV_DSP_ENCODECAP_EX)
#define DH_DEVSTATE_3GMODULE_INFO         0x002e           // Query 3G module info(struct DH_DEV_3GMODLE_INFO)
#define DH_DEVSTATE_MULTI_DDNS            0x002f           // Query multi DDNS status(struct DH_DEV_MULTI_DDNS_INFO)
#define DH_DEVSTATE_CONFIG_URL            0x0030           // Query Device URL info(struct DH_DEV_URL_INFO)
#define DH_DEVSTATE_HARDKEY               0x0031           // Query Hard key state(struct DHDEV_HARDKEY_STATE)
#define DH_DEVSTATE_ISCSI_PATH            0x0032           // Query ISCSI path(struct DHDEV_ISCSI_PATHLIST)
#define DH_DEVSTATE_DLPREVIEW_SLIPT_CAP   0x0033           // Query local preview split capability(struct DEVICE_LOCALPREVIEW_SLIPT_CAP)
#define DH_DEVSTATE_WIFI_ROUTE_CAP        0x0034           // Query wifi capablity(struct DHDEV_WIFI_ROUTE_CAP)
#define DH_DEVSTATE_ONLINE                0x0035           // Query device online state(return a DWORD value, 1-online, 0-offline)
#define DH_DEVSTATE_PTZ_LOCATION          0x0036           // Query ptz state(struct DH_PTZ_LOCATION_INFO)
#define DH_DEVSTATE_MONITOR_INFO          0x0037           // Query monitor state(state DHDEV_MONITOR_INFO)
#define DH_DEVSTATE_SUBDEVICE             0x0300           // Query subdevcie(fan,cpu...) state(struct CFG_DEVICESTATUS_INFO)
#define DH_DEVSTATE_RAID_INFO             0x0038           // Query RAID state(struct ALARM_RAID_INFO)
#define DH_DEVSTATE_TEST_DDNSDOMAIN       0x0039           // test DDNS domain enable
#define DH_DEVSTATE_VIRTUALCAMERA         0x003a           // query virtual camera state(struct DHDEV_VIRTUALCAMERA_STATE_INFO)
#define DH_DEVSTATE_TRAFFICWORKSTATE      0x003b           // get device's state of video/coil module(struct DHDEV_TRAFFICWORKSTATE_INFO)
#define DH_DEVSTATE_ALARM_CAMERA_MOVE     0x003c           // get camera move alarm state(struct ALARM_CAMERA_MOVE_INFO)
#define DH_DEVSTATE_ALARM                 0x003e           // get external alarm(struct NET_CLIENT_ALARM_STATE)
#define DH_DEVSTATE_VIDEOLOST             0x003f           // get video loss alarm(struct NET_CLIENT_VIDEOLOST_STATE)
#define DH_DEVSTATE_MOTIONDETECT          0x0040           // get motion alarm(struct NET_CLIENT_MOTIONDETECT_STATE)
#define DH_DEVSTATE_DETAILEDMOTION        0x0041           // get detailed motion alarm(struct NET_CLIENT_DETAILEDMOTION_STATE)
#define DH_DEVSTATE_VEHICLE_INFO          0x0042           // get vehicle device state(struct DHDEV_VEHICLE_INFO)
#define DH_DEVSTATE_VIDEOBLIND            0x0043           // get blind alarm(struct NET_CLIENT_VIDEOBLIND_STATE)
#define DH_DEVSTATE_3GSTATE_INFO          0x0044           // Query 3G state(struct DHDEV_VEHICLE_3GMODULE)
#define DH_DEVSTATE_NETINTERFACE          0x0045           // Query net interface(struct DHDEV_NETINTERFACE_INFO)
#define DH_DEVSTATE_PICINPIC_CHN          0x0046           // Query picinpic channel(struct DWORD)
#define DH_DEVSTATE_COMPOSITE_CHN         0x0047           // Query splice screen(struct DH_COMPOSITE_CHANNEL)
#define DH_DEVSTATE_WHOLE_RECORDING	      0x0048           // Query whole recording status(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_WHOLE_ENCODING        0x0049           // Query whole encoding(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_DISK_RECORDE_TIME     0x004a           // Query disk record time(pBuf = DEV_DISK_RECORD_TIME*)
#define DH_DEVSTATE_BURNER_DOOR           0x004b           // whether have pop-up optical dirve(struct NET_DEVSTATE_BURNERDOOR)
#define DH_DEVSTATE_GET_DATA_CHECK        0x004c           // get data validation process(struct NET_DEVSTATE_DATA_CHECK)
#define DH_DEVSTATE_ALARM_IN_CHANNEL      0x004f           // Query alarm input channel information(struct NET_ALARM_IN_CHANNEL)
#define DH_DEVSTATE_ALARM_CHN_COUNT	      0x0050           // Query alarm channel number(struct NET_ALARM_CHANNEL_COUNT)
#define DH_DEVSTATE_PTZ_VIEW_RANGE        0x0051           // Query PTZ view range status(struct DH_OUT_PTZ_VIEW_RANGE_STATUS)
#define DH_DEVSTATE_DEV_CHN_COUNT         0x0052           // Query device channel information(struct NET_DEV_CHN_COUNT_INFO)
#define DH_DEVSTATE_RTSP_URL              0x0053           // Query RTSP URL list supported by device, struct DEV_RTSPURL_LIST
#define DH_DEVSTATE_LIMIT_LOGIN_TIME      0x0054           // Query online overtime of device logging in and return a BTY?¡§UNIT??MIN?? ,0 means no limite and The non-zero positive integer means restrictions on the number of minutes
#define DH_DEVSTATE_GET_COMM_COUNT        0x0055           // get com count (struct NET_GET_COMM_COUNT)
#define DH_DEVSTATE_RECORDING_DETAIL      0x0056           // Query recording status detail information(pBuf = NET_RECORD_STATE_DETAIL*)
#define DH_DEVSTATE_PTZ_PRESET_LIST       0x0057           // get state PTZ preset list (struct NET_PTZ_PRESET_LIST)
#define DH_DEVSTATE_EXTERNAL_DEVICE	      0x0058           // exteral device information (pBuf = NET_EXTERNAL_DEVICE*)
#define DH_DEVSTATE_GET_UPGRADE_STATE     0x0059           // get device upgrade state(struct DHDEV_UPGRADE_STATE_INFO)
#define DH_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP 0x005a         // get mulipalyback split (struct NET_MULTIPLAYBACK_SPLIT_CAP )
#define DH_DEVSTATE_BURN_SESSION_NUM      0x005b           // get burn session number(pBuf = int*)
#define DH_DEVSTATE_PROTECTIVE_CAPSULE    0X005c           // Search protective capsule status(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
    
#define DH_DEVSTATE_POWER_STATE	          0x0152           // Query power state(struct DH_POWER_STATUS)
#define DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE  0x153	       // Query alarm channel state(struct NET_CLIENT_ALARM_CHANNELS_STATE)
#define DH_DEVSTATE_ALARMKEYBOARD_COUNT	  0x0154           // Query alarm keyboard count connected on com(struct NET_ALARMKEYBOARD_COUNT)
#define DH_DEVSTATE_EXALARMCHANNELS       0x0155           // Query mapping relationship of extension alarm module channel (struct NET_EXALARMCHANNELS)
#define DH_DEVSTATE_GET_BYPASS            0x0156           // Query channel bypass state(struct NET_DEVSTATE_GET_BYPASS)
#define DH_DEVSTATE_ACTIVATEDDEFENCEAREA  0x0157           // get active sector information(struct NET_ACTIVATEDDEFENCEAREA)
#define DH_DEVSTATE_DEV_RECORDSET         0x0158           // Query device recording information(struct NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_DOOR_STATE            0x0159           // Query door access state(struct NET_DOOR_STATUS_INFO)
#define DH_DEVSTATE_ANALOGALARM_CHANNELS  0x1560           // analog alarm input channel mapping (struct NET_ANALOGALARM_CHANNELS)
#define DH_DEVSTATE_GET_SENSORLIST        0x1561           // Get device supported sensor list(corresponding NET_SENSOR_LIST)
#define DH_DEVSTATE_ALARM_CHANNELS        0x1562           // Search switch alarm template channel mapping relation(corresponding structure  NET_ALARM_CHANNELS)
    // If device su not support search extension alarm module channel, may use this function to search extension channel logic channel no. and use as local alarm channel use
#define DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS	0x1563	// Get current system enabling status( corresponding NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
#define DH_DEVSTATE_AIRCONDITION_STATE    0x1564           // Get air conditioning status(corresponding to NET_GET_AIRCONDITION_STATE)
#define DH_DEVSTATE_ALARMSUBSYSTEM_STATE  0x1565           // Get sub system status(corresponding to NET_ALARM_SUBSYSTEM_STATE)
#define DH_DEVSTATE_ALARM_FAULT_STATE     0x1566           // Get failure status(corresponding to NET_ALARM_FAULT_STATE_INFO)
#define DH_DEVSTATE_DEFENCE_STATE         0x1567           // Get zone status(corresponding to NET_DEFENCE_STATE_INFO, and bypass status change event, local alarm event, alarm signal event status description is different, cannot mix, for specific device use only)
#define DH_DEVSTATE_CLUSTER_STATE         0x1568           // Get collection status(corresponding to NET_CLUSTER_STATE_INFO)
#define DH_DEVSTATE_SCADA_POINT_LIST      0x1569           // Get spot chart path info(corresponding to NET_SCADA_POINT_LIST_INFO)
#define DH_DEVSTATE_SCADA_INFO            0x156a           // Get monitor spot info(corresponding to NET_SCADA_INFO)
#define DH_DEVSTATE_SCADA_CAPS            0X156b           // Get SCADA capacityset(corresponding to NET_SCADA_CAPS)
#define DH_DEVSTATE_GET_CODEID_COUNT      0x156c           // Get successful code item number(corresponding  NET_GET_CODEID_COUNT)
#define DH_DEVSTATE_GET_CODEID_LIST       0x156d           // Search code info(corresponding  NET_GET_CODEID_LIST)
#define DH_DEVSTATE_ANALOGALARM_DATA      0x156e           // Search analog channel data(corresponding  NET_GET_ANALOGALARM_DATA)
#define DH_DEVSTATE_VTP_CALLSTATE         0x156f           // Access the call state of the video phone (Corresponding to NET_GET_VTP_CALLSTATE)
#define DH_DEVSTATE_SCADA_INFO_BY_ID      0x1570           // query point info by device id(corresponding to NET_SCADA_INFO_BY_ID)
#define DH_DEVSTATE_SCADA_DEVICE_LIST     0x1571           // query scada device id(corresponding to NET_SCADA_DEVICE_LIST)
    
    // three state bool type
    typedef enum tagNET_THREE_STATUS_BOOL
    {
        BOOL_STATUS_FALSE  = 0 ,
        BOOL_STATUS_TRUE       ,
        BOOL_STATUS_UNKNOWN    ,  //unknown
    }NET_THREE_STATUS_BOOL;
    
    //////////////////////////////////////////////////////////////////////////
    
    // Air Conditioning Work Mode
    typedef enum __EM_AIRCONDITION_MODE
    {
        AIRCONDITION_MODE_UNKNOWN = 0,
        AIRCONDITION_MODE_AUTO,             // Auto
        AIRCONDITION_MODE_HOT,              // Cool
        AIRCONDITION_MODE_COLD,             // Heat
        AIRCONDITION_MODE_WET,              // Arefaction
        AIRCONDITION_MODE_WIND,             // Vent
    } EM_AIRCONDITION_MODE;
    
    // Air Conditioning Fan Mode
    typedef enum __EM_AIRCONDITION_WINDMODE
    {
        AIRCONDITION_WINDMODE_UNKNOWN = 0,
        AIRCONDITION_WINDMODE_STOP,            // Stop
        AIRCONDITION_WINDMODE_AUTO,            // Auto
        AIRCONDITION_WINDMODE_HIGH,            // High Speed
        AIRCONDITION_WINDMODE_MIDDLE,          // Medium Speed
        AIRCONDITION_WINDMODE_LOW,             // Low Speed
    } EM_AIRCONDITION_WINDMODE;
    
    // Air Conditioning Working Status Info
    typedef struct tagNET_AIRCONDITION_STATE_INFO
    {
        DWORD				        dwSize;
        BOOL                        bIsOnline;                      // Online
        BOOL                        bIsON;                          // Enable
        int                         nTemperature;                   // Temperature
        EM_AIRCONDITION_MODE        emAirconditionMode;             // Work Mode
        EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Air Fan Mode
        float                       fActualTemperature;             // Environment Temperature
    }NET_AIRCONDITION_STATE_INFO;
    
    // Get Air Working Status(corresponding to DH_DEVSTATE_AIRCONDITION_STATE command)
    typedef struct tagNET_GET_AIRCONDITION_STATE
    {
        DWORD				dwSize;
        char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
        NET_AIRCONDITION_STATE_INFO stuAirConditionState;           // Air conditioning working status info
    }NET_GET_AIRCONDITION_STATE;
    
    // Switch alarm channel info
    typedef struct tagNET_ALARM_CHANNEL_INFO
    {
        DWORD			dwSize;
        int				nSlot;					// Root address, 0 means local channel, 1 means connected to 1st serial extension channel, 2, 3... and so on
        int				nChannel;				// Non local alarm channel on extension module channel no., from 0
        char			szName[DH_COMMON_STRING_128];	// Channel name
    }NET_ALARM_CHANNEL_INFO;
    
    // Local(far or close)switch alarm channel and logic channel no. mapping relation
    typedef struct tagNET_ALARM_CHANNELS
    {
        DWORD			dwSize;
        int				nMaxAlarmChannels;		// Max channel
        int				nRetAlarmChannels;		// Retuen channel no.
        NET_ALARM_CHANNEL_INFO*	pstuChannelInfo;// Channel info, user allocate memory
    }NET_ALARM_CHANNELS;
    
    // Alarm Sub System Status Type
    typedef enum __EM_ALARM_SUBSYSTEM_STATE_TYPE
    {
        ALARM_SUBSYSTEM_STATE_UNKNOWN = 0,
        ALARM_SUBSYSTEM_STATE_ACTIVE,               // Activated
        ALARM_SUBSYSTEM_STATE_INACTIVE,             // Not activated
        ALARM_SUBSYSTEM_STATE_UNDISTRIBUTED,        // Not distributed
    }EM_ALARM_SUBSYSTEM_STATE_TYPE;
    
    // Alarm Sub System Status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARMSUBSYSTEM_STATE
    typedef struct tagNET_ALARM_SUBSYSTEM_STATE
    {
        DWORD          dwSize;
        int            nMaxAlarmSubSystem;                                  // Valid Sub System Number
        EM_ALARM_SUBSYSTEM_STATE_TYPE  emState[DH_MAX_ALARM_SUBSYSTEM_NUM]; // Sub System Status Info
    }NET_ALARM_SUBSYSTEM_STATE;
    
    
    // Failure Type
    typedef enum __EM_ALARM_FAULT_STATE_TYPE
    {
        EM_ALARM_FAULT_STATE_ALL = 0,                       // All Types
        EM_ALARM_FAULT_STATE_CONNECTFAULT,                  // Connection Failure
        EM_ALARM_FAULT_STATE_BELLFAULT,                     // Bell Failure
        EM_ALARM_FAULT_STATE_KBFAULT,                       // Keyboard Failure
        EM_ALARM_FAULT_STATE_KBTAMPER,                      // Keyboard Vandal-proof
        EM_ALARM_FAULT_STATE_SENSORSHORTOUT,                // Sensor Short circuit
        EM_ALARM_FAULT_STATE_SENSORTAMPER,                  // Sensor Vandal-proof
    }EM_ALARM_FAULT_STATE_TYPE;
    
    // Alarm Failure Status, Input Parameter
    typedef struct tagNET_IN_ALARM_FAULT_STATE
    {
        DWORD           dwSize;
        EM_ALARM_FAULT_STATE_TYPE   emType;                 // Type to search
    }NET_IN_ALARM_FAULT_STATE;
    
    // Alarm Failure Status, Output Parameter
    typedef struct tagNET_OUT_ALARM_FAULT_STATE
    {
        DWORD           dwSize;
        int             nConnectFaultState;                 // 0: Unknown, 1: Normal, 2:Failure
        int             nBell;                              // Bell valid number
        int             anBellState[DH_MAX_BELL_NUM];       // Bell failure status info 0: Unknown, 1: Normal, 2:Failure
        int             nFaultKeyboard;                     // Keyboard failure valid number
        int             anFaultKeyboard[DH_MAX_KEYBOARD_NUM];// Keyboard failure info 0: Unknown, 1: Normal, 2:Failure
        int             nTamperKeyboard;                    // Keyboard valid vandal-proof number
        int             anTamperKeyboard[DH_MAX_KEYBOARD_NUM];// Keyboard vandal-proof info 0: Unknown, 1: Normal, 2:Failure
        int             nShortOutSensor;                    // Sensor valid short circuit number
        int             anShortOutSensor[DH_MAX_ALARMIN];   // Sensor short circuit info 0: Unknown, 1: Normal, 2:Failure
        int             nTamperSensor;                      // Sensor valid vandal-proof number
        int             anTamperSensor[DH_MAX_ALARMIN];     // Sensor vandal-proof info 0: Unknown, 1: Normal, 2:Failure
    }NET_OUT_ALARM_FAULT_STATE;
    
    // Alarm failure status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARM_FAULT_STATE
    typedef struct tagNET_ALARM_FAULT_STATE_INFO
    {
        DWORD           dwSize;
        NET_IN_ALARM_FAULT_STATE    stuIn;                  // Input parameter
        NET_OUT_ALARM_FAULT_STATE   stuOut;                 // Output parameter
    }NET_ALARM_FAULT_STATE_INFO;
    
    // Zone Status Type
    typedef enum __EM_DEFENCE_STATE_TYPE
    {
        EM_DEFENCE_STATE_UNKNOWN = 0,
        EM_DEFENCE_STATE_BYPASS,                                // Bypass
        EM_DEFENCE_STATE_OPEN,                                  // Open, for alarm under disarming
        EM_DEFENCE_STATE_CLOSE,                                 // Close
        EM_DEFENCE_STATE_ALARMING,                              // Alarm, for alarm under arming
    }EM_DEFENCE_STATE_TYPE;
    
    // Zone Status Info Input Parameter
    typedef struct tagNET_IN_DEFENCE_STATE_INFO
    {
        DWORD           dwSize;
        int             nDefenceNum;                            // Zone valid number, -1means search all zones
        int             anDefence[DH_MAX_ALARMIN];              // Zone number to search
    }NET_IN_DEFENCE_STATE_INFO;
    
    // Zone Status Info Output Parameter
    typedef struct tagNET_OUT_DEFENCE_STATE_INFO
    {
        DWORD           dwSize;
        int             nDefenceNum;                            // Zone valid number
        EM_DEFENCE_STATE_TYPE  anDefenceState[DH_MAX_ALARMIN];  // Zone status info
    }NET_OUT_DEFENCE_STATE_INFO;
    
    // Zpne status info, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_DEFENCE_STATE
    typedef struct tagNET_DEFENCE_STATE_INFO
    {
        DWORD           dwSize;
        NET_IN_DEFENCE_STATE_INFO   stuIn;                      // Input parameter
        NET_OUT_DEFENCE_STATE_INFO  stuOut;                     // Output parameter
    }NET_DEFENCE_STATE_INFO;
    
    // Type of video phone call
    typedef enum tagEM_NET_VTP_CALL_TYPE
    {
        EM_NET_VTP_CALL_TYPE_SIP = 0,                           // SIP calling
        EM_NET_VTP_CALL_TYPE_GSM,                               // GSM calling
        EM_NET_VTP_CALL_TYPE_PRIVATE,                           // private protocol calling
    }EM_NET_VTP_CALL_TYPE;
    
    // Type of video phone call
    typedef enum tagEM_NET_VTP_CALL_STATE_TYPE
    {
        EM_NET_VTP_CALL_STATE_UNKNOWN = 0,
        EM_NET_VTP_CALL_STATE_IDLE,                                 // Initial State
        EM_NET_VTP_CALL_STATE_CALLING,                              // State of calling(the opposite side not response)
        EM_NET_VTP_CALL_STATE_CALLED,                               // State of called
        EM_NET_VTP_CALL_STATE_RINGING,                              // State of calling back (the opposite side responsed but no answer)
        EM_NET_VTP_CALL_STATE_CONNECTING,                           // State of answering
        EM_NET_VTP_CALL_STATE_CONNECTING2,                          // 2 states in the call (?¡§?¡ã????¡À??¨¹?¨®???¡§?¡ã??¡Á???)
        EM_NET_VTP_CALL_STATE_DISCONNECT,                           // State of call off
    }EM_NET_VTP_CALL_STATE_TYPE;
    
    // Obtain the calling state of video phone (Corresponding to DH_DEVSTATE_VTP_CALLSTATE)
    typedef struct tagNET_GET_VTP_CALLSTATE
    {
        DWORD                       dwSize;
        EM_NET_VTP_CALL_TYPE        emCallType;                     // the call type to be queried, input parameter
        char                        szCallID[DH_COMMON_STRING_128]; // the unique identification to be queried, input parameter
        const char*                 szTargetID;                     // the device to be transmit,  ID= NULL equals to no transmitting,  input parameter
        EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // State of calling
    }NET_GET_VTP_CALLSTATE;
    
    // Configuration type,corresponding to CLIENT_QueryRemotDevState
#define DH_DEVSTATE_ALARM_REMOTE   0x1000        // get the remote device external alarm(struct ALARM_REMOTE_ALARM_INFO)
#define DH_DEVSTATE_ALARM_FRONTDISCONNECT 0x1001 // get the front IPC disconnect alarm (struct ALARM_FRONTDISCONNET_INFO)
    
    // Configuration type,corresponding to CLIENT_GetDevConfig and CLIENT_SetDevConfig
#define DH_DEV_DEVICECFG			0x0001		// Device property setup
#define DH_DEV_NETCFG				0x0002		// Network setup
#define DH_DEV_CHANNELCFG			0x0003		// Video channel setup
#define DH_DEV_PREVIEWCFG 			0x0004		// Preview parameter setup
#define DH_DEV_RECORDCFG			0x0005		// Record setup
#define DH_DEV_COMMCFG				0x0006		// COM property setup
#define DH_DEV_ALARMCFG 			0x0007		// Alarm property setup
#define DH_DEV_TIMECFG 				0x0008		// DVR time setup
#define DH_DEV_TALKCFG				0x0009		// Audio talk parameter setup
#define DH_DEV_AUTOMTCFG			0x000A		// Auto matrix setup
#define	DH_DEV_VEDIO_MARTIX			0x000B		// Local matrix control strategy setup
#define DH_DEV_MULTI_DDNS			0x000C		//  Multiple ddns setup
#define DH_DEV_SNAP_CFG				0x000D		// Snapshot corresponding setup
#define DH_DEV_WEB_URL_CFG			0x000E		// HTTP path setup
#define DH_DEV_FTP_PROTO_CFG		0x000F		// FTP upload setup
#define DH_DEV_INTERVIDEO_CFG		0x0010		// Plaform embedded setup. Now the channel parameter represents the platform type.
    // channel=4:Bell alcatel;channel=10:ZTE Netview;channel=11:U CNC  channel = 51 AMP
#define DH_DEV_VIDEO_COVER			0x0011		// Privacy mask setup
#define DH_DEV_TRANS_STRATEGY		0x0012		// Transmission strategy. Video quality\Fluency
#define DH_DEV_DOWNLOAD_STRATEGY	0x0013		//  Record download strategy setup:high-speed\general download
#define DH_DEV_WATERMAKE_CFG		0x0014		// Video watermark setup
#define DH_DEV_WLAN_CFG				0x0015		// Wireless network setup
#define DH_DEV_WLAN_DEVICE_CFG		0x0016		// Search wireless device setup
#define DH_DEV_REGISTER_CFG			0x0017		// Auto register parameter setup
#define DH_DEV_CAMERA_CFG			0x0018		// Camera property setup
#define DH_DEV_INFRARED_CFG 		0x0019		// IR alarm setup
#define DH_DEV_SNIFFER_CFG			0x001A		// Sniffer setup
#define DH_DEV_MAIL_CFG				0x001B		// Mail setup
#define DH_DEV_DNS_CFG				0x001C		// DNS setup
#define DH_DEV_NTP_CFG				0x001D		// NTP setup
#define DH_DEV_AUDIO_DETECT_CFG		0x001E		// Audio detection setup
#define DH_DEV_STORAGE_STATION_CFG  0x001F      // Storage position setup
#define DH_DEV_PTZ_OPT_CFG			0x0020		// PTZ operation property(It is invalid now. Please use CLIENT_GetPtzOptAttr to get PTZ operation property.)
#define DH_DEV_DST_CFG				0x0021      // Daylight Saving Time (DST)setup
#define DH_DEV_ALARM_CENTER_CFG		0x0022		// Alarm centre setup
#define DH_DEV_VIDEO_OSD_CFG        0x0023		// VIdeo OSD setup
#define DH_DEV_CDMAGPRS_CFG         0x0024		// CDMA\GPRS configuration
    
#define DH_DEV_IPFILTER_CFG         0x0025		// IP Filter configuration
#define DH_DEV_TALK_ENCODE_CFG      0x0026      // Talk encode configuration
#define DH_DEV_RECORD_PACKET_CFG    0X0027      // The length of the video package configuration
#define DH_DEV_MMS_CFG              0X0028		// SMS MMS configuration
#define DH_DEV_SMSACTIVATION_CFG	0X0029		// SMS to activate the wireless connection configuration
#define DH_DEV_DIALINACTIVATION_CFG	0X002A		// Dial-up activation of a wireless connection configuration
#define DH_DEV_SNIFFER_CFG_EX		0x0030		// Capture network configuration
#define DH_DEV_DOWNLOAD_RATE_CFG	0x0031		// Download speed limit
#define DH_DEV_PANORAMA_SWITCH_CFG	0x0032		// Panorama switch alarm configuration
#define DH_DEV_LOST_FOCUS_CFG		0x0033		// Lose focus alarm configuration
#define DH_DEV_ALARM_DECODE_CFG		0x0034		// Alarm decoder configuration
#define DH_DEV_VIDEOOUT_CFG         0x0035      // Video output configuration
#define DH_DEV_POINT_CFG			0x0036		// Preset enable configuration
#define DH_DEV_IP_COLLISION_CFG     0x0037      // IP conflication configurationIp
#define DH_DEV_OSD_ENABLE_CFG		0x0038		// OSD overlay enable configuration
#define DH_DEV_LOCALALARM_CFG 		0x0039		// Local alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_NETALARM_CFG 		0x003A		// Network alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_MOTIONALARM_CFG 		0x003B		// Motion detection configuration(Structure DH_MOTION_DETECT_CFG_EX)
#define DH_DEV_VIDEOLOSTALARM_CFG 	0x003C		// Video loss configuration(Structure DH_VIDEO_LOST_CFG_EX)
#define DH_DEV_BLINDALARM_CFG 		0x003D		// Camera masking configuration(Structure DH_BLIND_CFG_EX)
#define DH_DEV_DISKALARM_CFG 		0x003E		// HDD alarm configuration(Structure DH_DISK_ALARM_CFG_EX)
#define DH_DEV_NETBROKENALARM_CFG 	0x003F		// Network disconnection alarm configuration(Structure DH_NETBROKEN_ALARM_CFG_EX)
#define DH_DEV_ENCODER_CFG          0x0040      // Digital channel info of front encoders(Hybrid DVR use,Structure DEV_ENCODER_CFG)
#define DH_DEV_TV_ADJUST_CFG        0x0041      // TV adjust configuration(Now the channel parameter represents the TV numble(from 0), Structure DHDEV_TVADJUST_CFG)
#define DH_DEV_ABOUT_VEHICLE_CFG	0x0042		// about vehicle configuration
#define DH_DEV_ATM_OVERLAY_ABILITY	0x0043		// ATM ability information
#define DH_DEV_ATM_OVERLAY_CFG		0x0044		// ATM overlay configuration
#define DH_DEV_DECODER_TOUR_CFG		0x0045		// Decoder tour configuration
#define DH_DEV_SIP_CFG				0x0046		// SIP configuration
#define DH_DEV_VICHILE_WIFI_AP_CFG	0x0047		// wifi ap configuration
#define DH_DEV_STATICALARM_CFG      0x0048      // Static
#define DH_DEV_DECODE_POLICY_CFG    0x0049      // decode policy configuration(Structure DHDEV_DECODEPOLICY_CFG,channel start with 0)
#define DH_DEV_MACHINE_CFG			0x004A		// Device relative config (Structure DHDEV_MACHINE_CFG)
#define DH_DEV_MAC_COLLISION_CFG    0x004B      // MACconflication configuration(Structure ALARM_MAC_COLLISION_CFG)
#define DH_DEV_RTSP_CFG             0x004C      // RTSP configuration(structure DHDEV_RTSP_CFG)
#define DH_DEV_232_COM_CARD_CFG     0x004E      // 232 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_485_COM_CARD_CFG     0x004F      // 485 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_FTP_PROTO_CFG_EX		0x0050		// extend FTP upload setup(Structure DHDEV_FTP_PROTO_CFG_EX)
#define DH_DEV_SYSLOG_REMOTE_SERVER	0x0051		// SYSLOG remote server config (Structure DHDEV_SYSLOG_REMOTE_SERVER)
#define DH_DEV_COMMCFG_EX           0x0052      // Extended com configuration(structure DHDEV_COMM_CFG_EX)
#define DH_DEV_NETCARD_CFG          0x0053      // net card configuration(structure DHDEV_NETCARD_CFG)
#define DH_DEV_BACKUP_VIDEO_FORMAT  0x0054		// Video backup format(structure DHDEV_BACKUP_VIDEO_FORMAT)
#define DH_DEV_STREAM_ENCRYPT_CFG   0x0055      // stream encrypt configuration(structure DHEDV_STREAM_ENCRYPT)
#define DH_DEV_IPFILTER_CFG_EX      0x0056		// IP filter extended configuration(structure DHDEV_IPIFILTER_CFG_EX)
#define DH_DEV_CUSTOM_CFG           0x0057      // custom configuration(structure DHDEV_CUSTOM_CFG)
#define DH_DEV_WLAN_DEVICE_CFG_EX   0x0058      // Search wireless device extended setup(structure DHDEV_WLAN_DEVICE_LIST_EX)
#define DH_DEV_ACC_POWEROFF_CFG     0x0059      // ACC power off configuration(structure DHDEV_ACC_POWEROFF_CFG)
#define DH_DEV_EXPLOSION_PROOF_CFG  0x005a      // explosion proof alarm configuration(structure DHDEV_EXPLOSION_PROOF_CFG)
#define DH_DEV_NETCFG_EX			0x005b		// Network extended setup(struct DHDEV_NET_CFG_EX)
#define DH_DEV_LIGHTCONTROL_CFG     0x005c      // light control config(struct DHDEV_LIGHTCONTROL_CFG)
#define DH_DEV_3GFLOW_CFG           0x005d      // 3G flow info config(struct DHDEV_3GFLOW_INFO_CFG)
#define DH_DEV_IPV6_CFG             0x005e      // IPv6 config(struct DHDEV_IPV6_CFG)
#define DH_DEV_SNMP_CFG             0X005f      // Snmp config(struct DHDEV_NET_SNMP_CFG)
#define DH_DEV_SNAP_CONTROL_CFG     0x0060      // snap control config(struct DHDEV_SNAP_CONTROL_CFG)
#define DH_DEV_GPS_MODE_CFG         0X0061      // GPS mode config(struct DHDEV_GPS_MODE_CFG)
#define DH_DEV_SNAP_UPLOAD_CFG      0X0062      // Snap upload config(struct DHDEV_SNAP_UPLOAD_CFG)
#define DH_DEV_SPEED_LIMIT_CFG      0x0063      // Speed limit config(struct DHDEV_SPEED_LIMIT_CFG)
#define DH_DEV_ISCSI_CFG	    0x0064		// iSCSI config(struct DHDEV_ISCSI_CFG), need reboot
#define DH_DEV_WIRELESS_ROUTING_CFG  0x0065		// wifi config(struc DHDEV_WIRELESS_ROUTING_CFG)
#define DH_DEV_ENCLOSURE_CFG         0x0066      // enclosure config(stuct DHDEV_ENCLOSURE_CFG)
#define DH_DEV_ENCLOSURE_VERSION_CFG 0x0067     // enclosure version config(struct DHDEV_ENCLOSURE_VERSION_CFG)
#define DH_DEV_RIAD_EVENT_CFG        0x0068     // Raid event config(struct DHDEV_RAID_EVENT_CFG)
#define DH_DEV_FIRE_ALARM_CFG        0x0069     // fire alarm config(struct DHDEV_FIRE_ALARM_CFG)
#define DH_DEV_LOCALALARM_NAME_CFG   0x006a     // local alarm name config(string like "Name1&&name2&&name3...")
#define DH_DEV_URGENCY_RECORD_CFG    0x0070     // urgency storage config(struct DHDEV_URGENCY_RECORD_CFG)
#define DH_DEV_ELEVATOR_ATTRI_CFG    0x0071     // elevator parameter config(struct DHDEV_ELEVATOR_ATTRI_CFG)
#define DH_DEV_ATM_OVERLAY_CFG_EX   0x0072     // TM overlay function. For latest ATM series product only.
    // Support devices of 32-channel or higher.( struct DHDEV_ATM_OVERLAY_CONFIG_EX)
#define DH_DEV_MACFILTER_CFG		 0x0073		// MAC filter config(struct DHDEV_MACFILTER_CFG)
#define DH_DEV_MACIPFILTER_CFG		 0x0074		// MAC,IP filter config(need ip,mac one to one corresponding)(struct DHDEV_MACIPFILTER_CFG)
#define DH_DEV_STREAM_ENCRYPT_TIME_CFG 0x0075   // stream encrypt(encryot plan)(struct DHEDV_STREAM_ENCRYPT)
#define DH_DEV_LIMIT_BIT_RATE_CFG    0x0076     // limit bit rate config(struct DHDEV_LIMIT_BIT_RATE)
#define DH_DEV_SNAP_CFG_EX			 0x0077		// snap extern config(struct DHDEV_SNAP_CFG_EX)
#define DH_DEV_DECODER_URL_CFG		0x0078		// decoder url config(struct DHDEV_DECODER_URL_CFG)
#define DH_DEV_TOUR_ENABLE_CFG		0x0079		// toyr enable config(struct DHDEV_TOUR_ENABLE_CFG)
#define DH_DEV_VICHILE_WIFI_AP_CFG_EX 0x007a    // wifi ap extern config(struct DHDEV_VEHICLE_WIFI_AP_CFG_EX)
#define DH_DEV_ENCODER_CFG_EX         0x007b    // encoder extern config(struct DEV_ENCODER_CFG_EX)
#define DH_DEV_USER_END_CFG			1000
    
    // Alarm type, corresponding to CLIENT_StartListen
#define DH_COMM_ALARM				0x1100		// General alarm(Including external alarm, video loss and motion detection)
#define DH_SHELTER_ALARM			0x1101		// Camera masking alarm
#define DH_DISK_FULL_ALARM			0x1102		// HDD full alarm
#define DH_DISK_ERROR_ALARM			0x1103		// HDD malfunction alarm
#define DH_SOUND_DETECT_ALARM		0x1104		// Audio detection alarm
#define DH_ALARM_DECODER_ALARM		0x1105		// Alarm decoder alarm
    
    // Extensive alarm type,corresponding to CLIENT_StartListenEx
#define DH_ALARM_ALARM_EX			0x2101		// External alarm
#define DH_MOTION_ALARM_EX			0x2102		// Motion detection alarm
#define DH_VIDEOLOST_ALARM_EX		0x2103		// Video loss alarm
#define DH_SHELTER_ALARM_EX			0x2104		// Camera masking alarm
#define DH_SOUND_DETECT_ALARM_EX	0x2105		// Audio detection alarm
#define DH_DISKFULL_ALARM_EX		0x2106		// HDD full alarm
#define DH_DISKERROR_ALARM_EX		0x2107		// HDD malfunction alarm
#define DH_ENCODER_ALARM_EX			0x210A		// Encoder alarm
#define DH_URGENCY_ALARM_EX			0x210B		// Emergency alarm
#define DH_WIRELESS_ALARM_EX		0x210C		// Wireless alarm
#define DH_NEW_SOUND_DETECT_ALARM_EX 0x210D		// New auido detection alarm. Please refer to DH_NEW_SOUND_ALARM_STATE for alarm information structure;
#define DH_ALARM_DECODER_ALARM_EX	0x210E		// Alarm decoder alarm
#define DH_DECODER_DECODE_ABILITY	0x210F		// NVD:Decoding capacity
#define DH_FDDI_DECODER_ABILITY		0x2110		// Fiber encoder alarm
#define DH_PANORAMA_SWITCH_ALARM_EX	0x2111		// Panorama switch alarm
#define DH_LOSTFOCUS_ALARM_EX		0x2112		// Lost focus alarm
#define DH_OEMSTATE_EX				0x2113		// oem state
#define DH_DSP_ALARM_EX				0x2114		// DSP alarm
#define DH_ATMPOS_BROKEN_EX			0x2115		// atm and pos disconnection alarm, 0:disconnection 1:connection
#define DH_RECORD_CHANGED_EX		0x2116		// Record state changed alarm
#define DH_CONFIG_CHANGED_EX		0x2117		// Device config changed alarm
#define DH_DEVICE_REBOOT_EX			0x2118		// Device rebooting alarm
#define DH_WINGDING_ALARM_EX        0x2119      // CoilFault alarm
#define DH_TRAF_CONGESTION_ALARM_EX 0x211A      // traffic congestion alarm
#define DH_TRAF_EXCEPTION_ALARM_EX  0x211B      // traffic exception alarm
#define DH_EQUIPMENT_FILL_ALARM_EX  0x211C      // FlashFault alarm
#define DH_ALARM_ARM_DISARM_STATE	0x211D		// alarm arm disarm
#define DH_ALARM_ACC_POWEROFF       0x211E      // ACC power off alarm
#define DH_ALARM_3GFLOW_EXCEED      0x211F      // Alarm of 3G flow exceed(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_ALARM_SPEED_LIMIT        0x2120      // Speed limit alarm
#define DH_ALARM_VEHICLE_INFO_UPLOAD  0x2121    // Vehicle information uploading
#define DH_STATIC_ALARM_EX          0x2122      // Static detection alarm
#define DH_PTZ_LOCATION_EX          0x2123      // ptz location info
#define DH_ALARM_CARD_RECORD_UPLOAD	0x2124		// card record info(struct ALARM_CARD_RECORD_INFO_UPLOAD)
#define DH_ALARM_ATM_INFO_UPLOAD	0x2125		// ATM trade info(struct ALARM_ATM_INFO_UPLOAD)
#define DH_ALARM_ENCLOSURE          0x2126      // enclosure alarm(struct ALARM_ENCLOSURE_INFO)
#define DH_ALARM_SIP_STATE          0x2127      // SIP state alarm(struct ALARM_SIP_STATE)
#define DH_ALARM_RAID_STATE         0x2128      // RAID state alarm(struct ALARM_RAID_INFO)
#define DH_ALARM_CROSSING_SPEED_LIMIT 0x2129	// crossing speed limit alarm(struct ALARM_SPEED_LIMIT)
#define DH_ALARM_OVER_LOADING         0x212A      // over loading alarm(struct ALARM_OVER_LOADING)
#define DH_ALARM_HARD_BRAKING         0x212B      // hard brake alarm(struct ALARM_HARD_BRAKING)
#define DH_ALARM_SMOKE_SENSOR         0x212C      // smoke sensor alarm(struct ALARM_SMOKE_SENSOR)
#define DH_ALARM_TRAFFIC_LIGHT_FAULT 0x212D     // traffic light fault alarm(struct ALARM_TRAFFIC_LIGHT_FAULT)
#define DH_ALARM_TRAFFIC_FLUX_STAT   0x212E     // traffic flux alarm(struct ALARM_TRAFFIC_FLUX_LANE_INFO)
#define DH_ALARM_CAMERA_MOVE         0x212F     // camera move alarm(struct ALARM_CAMERA_MOVE_INFO)
#define DH_ALARM_DETAILEDMOTION      0x2130     // detailed motion alarm(struct ALARM_DETAILEDMOTION_CHNL_INFO)
#define DH_ALARM_STORAGE_FAILURE     0x2131     // storage failure alarm(struct ALARM_STORAGE_FAILURE)
#define DH_ALARM_FRONTDISCONNECT     0x2132     // front IPC disconnect alarm(struct ALARM_FRONTDISCONNET_INFO)
#define DH_ALARM_ALARM_EX_REMOTE     0x2133     // remote external alarm
#define DH_ALARM_BATTERYLOWPOWER     0x2134     // battery low power alarm(struct ALARM_BATTERYLOWPOWER_INFO)
#define DH_ALARM_TEMPERATURE         0x2135     // temperature alarm(struct ALARM_TEMPERATURE_INFO)
#define DH_ALARM_TIREDDRIVE          0x2136     // tired drive alarm(struct ALARM_TIREDDRIVE_INFO)
#define DH_ALARM_LOST_RECORD         0x2137     // Alarm of record loss (corresponding structure ALARM_LOST_RECORD)
#define DH_ALARM_HIGH_CPU            0x2138     // Alarm of High CPU Occupancy rate (corresponding structure ALARM_HIGH_CPU)
#define DH_ALARM_LOST_NETPACKET      0x2139     // Alarm of net package loss (corresponding structure ALARM_LOST_NETPACKET)
#define DH_ALARM_HIGH_MEMORY         0x213A     // Alarm of high memory occupancy rate(corresponding structure ALARM_HIGH_MEMORY)
#define DH_LONG_TIME_NO_OPERATION	 0x213B	    // WEB user have no operation for long time (no extended info)
#define DH_BLACKLIST_SNAP            0x213C     // blacklist snap(corresponding to DH_BLACKLIST_SNAP_INFO)
#define DH_ALARM_DISK				 0x213E		// alarm of disk(corresponding to ALARM_DISK_INFO)
#define	DH_ALARM_FILE_SYSTEM		 0x213F		// alarm of file systemcorresponding to ALARM_FILE_SYSTEM_INFO)
#define DH_ALARM_IVS                 0x2140     // alarm of ivs(corresponding to ALARM_IVS_INFO)
#define DH_ALARM_GOODS_WEIGHT_UPLOAD 0x2141		// goods weight (corresponding to ALARM_GOODS_WEIGHT_UPLOAD_INFO)
#define DH_ALARM_GOODS_WEIGHT		 0x2142		// alarm of goods weight(corresponding to ALARM_GOODS_WEIGHT_INFO)
#define DH_GPS_STATUS                0x2143     // GPS orientation info(corresponding to NET_GPS_STATUS_INFO)
#define DH_ALARM_DISKBURNED_FULL     0x2144     // alarm disk burned full(corresponding to ALARM_DISKBURNED_FULL_INFO)
#define DH_ALARM_STORAGE_LOW_SPACE	 0x2145		// storage low space(corresponding to ALARM_STORAGE_LOW_SPACE_INFO)
#define DH_ALARM_DISK_FLUX			 0x2160		// disk flux abnormal(corresponding to ALARM_DISK_FLUX)
#define DH_ALARM_NET_FLUX			 0x2161		// net flux abnormal(corresponding to ALARM_NET_FLUX)
#define	DH_ALARM_FAN_SPEED			 0x2162		// fan speed abnormal(corresponding to ALARM_FAN_SPEED)
#define DH_ALARM_STORAGE_FAILURE_EX  0x2163     // storage mistake(corresponding to ALARM_STORAGE_FAILURE_EX)
#define	DH_ALARM_RECORD_FAILED		 0x2164		// record abnormal(corresponding to ALARM_RECORD_FAILED_INFO)
#define DH_ALARM_STORAGE_BREAK_DOWN	 0x2165		// storage break down(corresponding to ALARM_STORAGE_BREAK_DOWN_INFO)
#define DH_ALARM_VIDEO_ININVALID     0x2166     // ALARM_VIDEO_ININVALID_INFO
#define DH_ALARM_VEHICLE_TURNOVER	 0x2167		// vehicle turnover arm event(struct ALARM_VEHICEL_TURNOVER_EVENT_INFO)
#define DH_ALARM_VEHICLE_COLLISION	 0x2168     // vehicle collision event(struct ALARM_VEHICEL_COLLISION_EVENT_INFO)
#define DH_ALARM_VEHICLE_CONFIRM     0x2169     // vehicle confirm information event(struct ALARM_VEHICEL_CONFIRM_INFO)
#define DH_ALARM_VEHICLE_LARGE_ANGLE 0x2170     // vehicle camero large angle event(struct ALARM_VEHICEL_LARGE_ANGLE)
#define DH_ALARM_TALKING_INVITE		 0x2171		// device talking invite event (struct ALARM_TALKING_INVITE_INFO)
#define DH_ALARM_ALARM_EX2			 0x2175		// local alarm event (struct ALARM_ALARM_INFO_EX2??upgrade DH_ALARM_ALARM_EX)
#define DH_ALARM_VIDEO_TIMING        0x2176     // video timing detecting event(struct ALARM_VIDEO_TIMING)
#define DH_ALARM_COMM_PORT			 0x2177     // COM event(struct ALARM_COMM_PORT_EVENT_INFO)
#define DH_ALARM_AUDIO_ANOMALY       0x2178     // audio anomaly event(struct ALARM_AUDIO_ANOMALY)
#define DH_ALARM_AUDIO_MUTATION      0x2179     // audio mutation event(struct ALARM_AUDIO_MUTATION)
#define DH_EVENT_TYREINFO            0x2180     // Tyre information report event (struct EVENT_TYRE_INFO)
#define DH_ALARM_POWER_ABNORMAL      0X2181     // Redundant power supplies abnormal alarm(struct ALARM_POWER_ABNORMAL_INFO)
#define DH_EVENT_REGISTER_OFF		 0x2182		// On-board equipment active offline events(struct  EVENT_REGISTER_OFF_INFO)
#define DH_ALARM_NO_DISK             0x2183     // No hard disk alarm(struct ALARM_NO_DISK_INFO)
#define DH_ALARM_FALLING             0x2184     // The fall alarm(struct ALARM_FALLING_INFO)
#define DH_ALARM_PROTECTIVE_CAPSULE  0x2185     // Protective capsule event(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_ALARM_NO_RESPONSE              0x2186           // Call Non-response alarm(corresponding to ALARM_NO_RESPONSE_INFO)
#define DH_ALARM_CONFIG_ENABLE_CHANGE     0X2187           // Config enable to change reported event(corresponding to structure  ALARM_CONFIG_ENABLE_CHANGE_INFO)
    
#define DH_ALARM_STORAGE_NOT_EXIST   0x3167		// A storage group does not exist(struct ALARM_STORAGE_NOT_EXIST_INFO)
#define DH_ALARM_NET_ABORT			 0x3169		// Network fault event(struct ALARM_NETABORT_INFO)
#define DH_ALARM_IP_CONFLICT		 0x3170		// IP conflict event(struct ALARM_IP_CONFLICT_INFO)
#define DH_ALARM_MAC_CONFLICT		 0x3171		// MAC conflict event(struct ALARM_MAC_CONFLICT_INFO)
#define DH_ALARM_POWERFAULT			 0x3172		// power fault event(struct ALARM_POWERFAULT_INFO)
#define DH_ALARM_CHASSISINTRUDED	 0x3173		// Chassis intrusion, tamper alarm events(struct ALARM_CHASSISINTRUDED_INFO)
#define DH_ALARM_ALARMEXTENDED		 0x3174		// Native extension alarm events(struct ALARM_ALARMEXTENDED_INFO)
    
#define DH_ALARM_ARMMODE_CHANGE_EVENT		 0x3175		// Cloth removal state change events(struct ALARM_ARMMODE_CHANGE_INFO)
#define DH_ALARM_BYPASSMODE_CHANGE_EVENT	 0x3176		// The bypass state change events(struct ALARM_BYPASSMODE_CHANGE_INFO)
    
#define DH_ALARM_ACCESS_CTL_NOT_CLOSE		0x3177		// Entrance guard did not close events(struct ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
#define DH_ALARM_ACCESS_CTL_BREAK_IN		0x3178		// break-in event(struct ALARM_ACCESS_CTL_BREAK_IN_INFO)
#define DH_ALARM_ACCESS_CTL_REPEAT_ENTER	0x3179		//access Again and again event(struct ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
#define DH_ALARM_ACCESS_CTL_DURESS			0x3180		// Stress CARDS event(struct ALARM_ACCESS_CTL_DURESS_INFO)
#define DH_ALARM_ACCESS_CTL_EVENT			0x3181		// Access event(struct ALARM_ACCESS_CTL_EVENT_INFO)
    
#define DH_URGENCY_ALARM_EX2              0x3182           // Emergency ALARM EX2(upgrade DH_URGENCY_ALARM_EX,struct ALARM_URGENCY_ALARM_EX2, Artificially triggered emergency, general processing is linked external communication function requests for help
#define DH_ALARM_INPUT_SOURCE_SIGNAL      0x3183           // Alarm input source signal events (as long as there is input will generate the event, whether to play the current mode, unable to block, struct ALARM_INPUT_SOURCE_SIGNAL_INFO)
#define DH_ALARM_ANALOGALARM_EVENT        0x3184           //  analog alarm(struct ALARM_ANALOGALARM_EVENT_INFO)
#define DH_ALARM_ACCESS_CTL_STATUS        0x3185           // Access control status event(corresponding structure ALARM_ACCESS_CTL_STATUS_INFO)
#define DH_ALARM_ACCESS_SNAP              0x3186           // Access control snapshot event(corresponding to ALARM_ACCESS_SNAP_INFO)
#define DH_ALARM_ALARMCLEAR               0x3187           // Cancel alarm(corresponding to structure ALARM_ALARMCLEAR_INFO)
#define DH_ALARM_CIDEVENT                 0x3188           // CID event(corresponding to structure ALARM_CIDEVENT_INFO)
#define DH_ALARM_TALKING_HANGUP           0x3189           // Device hand up evnt(corresponding to structure ALARM_TALKING_HANGUP_INFO)
#define DH_ALARM_BANKCARDINSERT           0x318a           // Bank card evnt(corresponding to structure ALARM_BANKCARDINSERT_INFO)
#define DH_ALARM_RCEMERGENCY_CALL         0x318b           // Emergency call alarm event(corresponding to structure ALARM_RCEMERGENCY_CALL_INFO)
#define DH_ALARM_OPENDOORGROUP            0x318c           // Multi-people group unlock event(corresponding to  structure ALARM_OPEN_DOOR_GROUP_INFO)
#define DH_ALARM_FINGER_PRINT             0x318d           // get fingerprint event(corresponding to  structure ALARM_CAPTURE_FINGER_PRINT_INFO)
#define DH_ALARM_CARD_RECORD              0x318e           // card no. record event(corresponding to  structure  ALARM_CARD_RECORD_INFO)
#define DH_ALARM_SUBSYSTEM_STATE_CHANGE   0x318f           // sub system status change event(corresponding to  structure ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
#define DH_ALARM_BATTERYPOWER_EVENT       0x3190           // battery scheduled warning event(corresponding to  structure ALARM_BATTERYPOWER_INFO)
#define DH_ALARM_BELLSTATUS_EVENT         0x3191           // bell status event(corresponding to  structure ALARM_BELLSTATUS_INFO)
#define DH_ALARM_DEFENCE_STATE_CHANGE_EVENT 0x3192         // zone status change event(corresponding to  structure ALARM_DEFENCE_STATUS_CHANGE_INFO),
    // customized need??and arm/disarm change event, bypass event status have different definitions,
    // The status via CLIENT_QueryDevState() port DH_DEVSTATE_DEFENCE_STATE command get
#define DH_ALARM_TICKET_STATISTIC         0x3193           // ticket statistics info event(corresponding to  structure  ALARM_TICKET_STATISTIC)
#define DH_ALARM_LOGIN_FAILIUR            0x3194           // login failed event(corresponding to  structure ALARM_LOGIN_FAILIUR_INFO)
#define DH_ALARM_MODULE_LOST              0x3195           // expansion module offline event(corresponding to  structure  ALARM_MODULE_LOST_INFO)
#define DH_ALARM_PSTN_BREAK_LINE          0x3196           // PSTN offline event(corresponding to  structure ALARM_PSTN_BREAK_LINE_INFO)
#define DH_ALARM_ANALOG_PULSE             0x3197           // analog alarm evnet(instant event), specific sensor  trigger(corresponding to  structure ALARM_ANALOGPULSE_INFO)
#define DH_ALARM_MISSION_CONFIRM          0x3198           // task confirmation event(corresponding to  structure  ALARM_MISSION_CONFIRM_INFO)
#define DH_ALARM_DEVICE_MSG_NOTIFY        0x3199           // device to platform notice event??(corresponding to  structure  ALARM_DEVICE_MSG_NOTIFY_INFO)
#define DH_ALARM_VEHICLE_STANDING_OVER_TIME 0x319A         // parking timeout event(corresponding to  structure  ALARM_VEHICLE_STANDING_OVER_TIME_INFO)
#define DH_ALARM_ENCLOSURE_ALARM          0x319B           // e-fence event(corresponding to  structure  ALARM_ENCLOSURE_ALARM_INFO)
#define DH_ALARM_GUARD_DETECT			  0x319C	       // station detection event, one in station first report the start event??and last on in station report stop event before leave (corresponding to  structure ALARM_GUARD_DETECT_INFO)
#define DH_ALARM_GUARD_INFO_UPDATE		  0x319D	       // station info update event??report if people in station(corresponding to  structure ALARM_GUARD_UPDATE_INFO)
#define DH_ALARM_NODE_ACTIVE              0x319E           // Node activation event (corresponding to structure ALARM_NODE_ACTIVE_INFO)
#define DH_ALARM_VIDEO_STATIC             0x319F           // Video static detection event (corresponding to structure ALARM_VIDEO_STATIC_INFO)
#define DH_ALARM_REGISTER_REONLINE        0x31a0           // Active registration device re-login event (corresponding to structure ALARM_REGISTER_REONLINE_INFO)
#define DH_ALARM_ISCSI_STATUS             0x31a1           // ISCSI alarm event (corresponding to structure ALARM_ISCSI_STATUS_INFO)
#define DH_ALARM_SCADA_DEV_ALARM          0x31a2           // detection collection device alarm event (corresponding to structure ALARM_SCADA_DEV_INFO)
#define DH_ALARM_AUXILIARY_DEV_STATE      0x31a3           // Sub device status(corresponding structure ALARM_AUXILIARY_DEV_STATE)
#define DH_ALARM_PARKING_CARD             0x31a4           // Parking swipe card event(corresponding structure ALARM_PARKING_CARD)
#define DH_ALARM_PROFILE_ALARM_TRANSMIT   0x31a5           // Alarm transmit event(corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
#define DH_ALARM_VEHICLE_ACC              0x31a6           // Vehicle acc event(corresponding structure ALARM_VEHICLE_ACC_INFO)
#define DH_ALARM_TRAFFIC_SUSPICIOUSCAR    0x31a7           // suspiciouscar event(corresponding structure ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
#define DH_ALARM_ACCESS_LOCK_STATUS       0x31a8           // the event of latch state (corresponding structure  ALARM_ACCESS_LOCK_STATUS_INFO)
#define DH_ALARM_FINACE_SCHEME            0x31a9           // Finace scheme event(corresponding structure ALARM_FINACE_SCHEME_INFO)
    
    // Event type
#define DH_CONFIG_RESULT_EVENT_EX	0x3000		// Modify the return code of the setup. Please refer to DEV_SET_RESULT for returned structure.
#define DH_REBOOT_EVENT_EX			0x3001		//  Device reboot event. Current modification becomes valid unitl sending out the reboot command.
#define DH_AUTO_TALK_START_EX		0x3002		// Device automatically invites to begin audio talk
#define DH_AUTO_TALK_STOP_EX		0x3003		// Device actively stop audio talk
#define DH_CONFIG_CHANGE_EX			0x3004		// Device setup changes.
#define DH_IPSEARCH_EVENT_EX        0x3005      // IP search event, the return value format is:DevName:::Manufacturer::MAC:: IP:: Port&& DevName:: Manufacturer::MAC:: IP:: Port&&?-
#define DH_AUTO_RECONNECT_FAILD     0x3006      // reconnect failed
#define DH_REALPLAY_FAILD_EVENT     0x3007      // real play failed
#define DH_PLAYBACK_FAILD_EVENT     0x3008      // playback failed
#define DH_IVS_TRAFFIC_REALFLOWINFO 0x3009      // traffic real flow info ALARM_IVS_TRAFFIC_REALFLOW_INFO
#define DH_DEVICE_ABORT_EVENT	    0x300a	    // Client end is out, corresponding to structure  DEV_CLIENT_ABORT_INFO
#define DH_TALK_FAILD_EVENT         0x300b      // failed to request talk, corresponding to  structure  DEV_TALK_RESULT
    
    // Alarm type of alarm upload function,corresponding to CLIENT_StartService.NEW_ALARM_UPLOAD structure.
#define DH_UPLOAD_ALARM					0x4000		// External alarm
#define DH_UPLOAD_MOTION_ALARM			0x4001		// Motion detection alarm
#define DH_UPLOAD_VIDEOLOST_ALARM		0x4002		// Video loss alarm
#define DH_UPLOAD_SHELTER_ALARM			0x4003		// Camera masking alarm
#define DH_UPLOAD_SOUND_DETECT_ALARM	0x4004		// Audio detection alarm
#define DH_UPLOAD_DISKFULL_ALARM		0x4005		// HDD full alarm
#define DH_UPLOAD_DISKERROR_ALARM		0x4006		// HDD malfunction alarm
#define DH_UPLOAD_ENCODER_ALARM			0x4007		// Encoder alarm
#define DH_UPLOAD_DECODER_ALARM			0x400B		// Alarm decoder alarm
#define DH_UPLOAD_EVENT					0x400C		// Scheduled upload
#define DH_UPLOAD_IVS					0x400D		// intelligent alarm,corresponding to ALARM_UPLOAD_IVS_INFO
#define DH_UPLOAD_SMOKESENSOR_ALARM 0x400E		// Smoke alarm, struct ALARM_UPLOAD_SMOKESENSOR_INFO
#define DH_UPLOAD_ALARM_EX                0x400F           // External alarm extension??corresponding structure  ALARM_UPLOAD_ALARMEX_INFO
#define DH_UPLOAD_REMOTE_LOGIN_FAILD_ALARM  0x4010           // Remote login failed alarm, corresponding structure ALARM_UPLOAD_LOGIN_FAILED_INFO
    
    // order Bus status corresponding to event report(CLIENT_AttachBusState)
#define DH_ALARM_BUS_DRIVER_CHECK         0X0001           // driver sign up event(corresponding to  structure  ALARM_BUS_DRIVER_CHECK_INFO)
#define DH_ALARM_BUS_IMPORT_SITE          0x0002           // in station(corresponding to  structure  ALARM_BUS_IMPORT_SITE_INFO)
#define DH_ALARM_BUS_EXPORT_SITE          0x0003           // out event (corresponding to  structure  ALARM_BUS_EXPORT_SITE_INFO)
#define DH_ALARM_BUS_ABNORMAL             0x0004           // Abnormal vehicle event (corresponding to structure ALARM_BUS_ABNORMAL_INFO)
#define DH_ALARM_BUS_DOOR_OPEN            0x0005           // Unlock car door event (corresponding to structure ALARM_VEHICLE_DOOR_OPEN_INFO)
#define DH_ALARM_BUS_CUR_MILEAGE          0x0006           // Current mileage event(corresponding to structure ALARM_BUS_CUR_MILEAGE_INFO)
#define DH_ALARM_BUS_CUR_OIL              0x0007           // Current oil event(corresponding to structure ALARM_BUS_CUR_OIL_INFO)
#define DH_ALARM_BUS_LOW_OIL              0x0008           // Low oil event(corresponding to structure ALARM_BUS_LOW_OIL_INFO)
    
    // Asynchronous interface callback type
#define RESPONSE_DECODER_CTRL_TV	0x00000001		// refer to CLIENT_CtrlDecTVScreen interface
#define RESPONSE_DECODER_SWITCH_TV	0x00000002		// refer to CLIENT_SwitchDecTVEncoder interface
#define RESPONSE_DECODER_PLAYBACK	0x00000003		// refer to CLIENT_DecTVPlayback interface
    
#define RESPONSE_EXCHANGE_DATA		0X00000004	// correspoding CLIENT_ExchangeData interface
#define RESPONSE_ASYN_QUERY_RECORDFILE 0X00000005  // correspoding CLIENT_StartQueryRecordFile interface
    // CLIENT_FileTransmit Interface transmission file type
#define DH_DEV_UPGRADEFILETRANS_START	0x0000		// Begin sending update file(Corresponding structure DHDEV_UPGRADE_FILE_INFO)
#define DH_DEV_UPGRADEFILETRANS_SEND	0x0001		// Send update file
#define DH_DEV_UPGRADEFILETRANS_STOP	0x0002		// Stop sending update file
#define DH_DEV_BLACKWHITETRANS_START  	0x0003    	// begin to send blackwhite list(Corresponding structure DHDEV_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITETRANS_SEND   	0x0004    	// send blackwhite list
#define DH_DEV_BLACKWHITETRANS_STOP   	0x0005    	// stop to send blackwhite list
#define DH_DEV_BLACKWHITE_LOAD        	0x0006    	// blackwhite list load (Corresponding structure DHDEV_LOAD_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITE_LOAD_STOP   	0x0007    	// blackwhite list load stop
#define DH_DEV_FILETRANS_STOP			0x002B		// Stop file upload
#define DH_DEV_FILETRANS_BURN			0x002C		// Burn File Upload
    
    // Resolution list. Use to AND & OR of resolution subnet mask
#define	DH_CAPTURE_SIZE_D1			0x00000001
#define DH_CAPTURE_SIZE_HD1			0x00000002
#define DH_CAPTURE_SIZE_BCIF		0x00000004
#define DH_CAPTURE_SIZE_CIF			0x00000008
#define DH_CAPTURE_SIZE_QCIF		0x00000010
#define DH_CAPTURE_SIZE_VGA			0x00000020
#define DH_CAPTURE_SIZE_QVGA		0x00000040
#define DH_CAPTURE_SIZE_SVCD		0x00000080
#define DH_CAPTURE_SIZE_QQVGA		0x00000100
#define DH_CAPTURE_SIZE_SVGA		0x00000200
#define DH_CAPTURE_SIZE_XVGA		0x00000400
#define DH_CAPTURE_SIZE_WXGA		0x00000800
#define DH_CAPTURE_SIZE_SXGA		0x00001000
#define DH_CAPTURE_SIZE_WSXGA		0x00002000
#define DH_CAPTURE_SIZE_UXGA		0x00004000
#define DH_CAPTURE_SIZE_WUXGA       0x00008000
#define DH_CAPTURE_SIZE_LFT         0x00010000
#define DH_CAPTURE_SIZE_720		    0x00020000
#define DH_CAPTURE_SIZE_1080		0x00040000
#define DH_CAPTURE_SIZE_1_3M        0x00080000
#define DH_CAPTURE_SIZE_2M			0x00100000
#define DH_CAPTURE_SIZE_5M			0x00200000
#define DH_CAPTURE_SIZE_3M			0x00400000
#define DH_CAPTURE_SIZE_5_0M        0x00800000
#define DH_CPTRUTE_SIZE_1_2M 		0x01000000
#define DH_CPTRUTE_SIZE_1408_1024   0x02000000
#define DH_CPTRUTE_SIZE_8M	        0x04000000
#define DH_CPTRUTE_SIZE_2560_1920   0x08000000
#define DH_CAPTURE_SIZE_960H        0x10000000
#define DH_CAPTURE_SIZE_960_720     0x20000000
    
    // Encode mode list. Use to work AND & OR operation of encode mode mask.
#define DH_CAPTURE_COMP_DIVX_MPEG4	0x00000001
#define DH_CAPTURE_COMP_MS_MPEG4 	0x00000002
#define DH_CAPTURE_COMP_MPEG2		0x00000004
#define DH_CAPTURE_COMP_MPEG1		0x00000008
#define DH_CAPTURE_COMP_H263		0x00000010
#define DH_CAPTURE_COMP_MJPG		0x00000020
#define DH_CAPTURE_COMP_FCC_MPEG4	0x00000040
#define DH_CAPTURE_COMP_H264		0x00000080
#define DH_CAPTURE_COMP_H265		0x00000100
    
    // Alarm activation operation. Use to work AND & OR operation of alarm activation operation.
#define DH_ALARM_UPLOAD				0x00000001
#define DH_ALARM_RECORD				0x00000002
#define DH_ALARM_PTZ				0x00000004
#define DH_ALARM_MAIL				0x00000008
#define DH_ALARM_TOUR				0x00000010
#define DH_ALARM_TIP				0x00000020
#define DH_ALARM_OUT				0x00000040
#define DH_ALARM_FTP_UL				0x00000080
#define DH_ALARM_BEEP				0x00000100
#define DH_ALARM_VOICE				0x00000200
#define DH_ALARM_SNAP				0x00000400
    
    // Restore default setup mask. Can use to AND & OR operation
#define DH_RESTORE_COMMON			0x00000001	// General setup
#define DH_RESTORE_CODING			0x00000002	// Encode setup
#define DH_RESTORE_VIDEO			0x00000004	// Record setup
#define DH_RESTORE_COMM				0x00000008	// COM setup
#define DH_RESTORE_NETWORK			0x00000010	//network setup
#define DH_RESTORE_ALARM			0x00000020	// Alarm setup
#define DH_RESTORE_VIDEODETECT		0x00000040	// Video detection
#define DH_RESTORE_PTZ				0x00000080	// PTZ control
#define DH_RESTORE_OUTPUTMODE		0x00000100	// Output mode
#define DH_RESTORE_CHANNELNAME		0x00000200	// Channel name
#define DH_RESTORE_VIDEOINOPTIONS   0x00000400  // Camera attribute
#define DH_RESTORE_CPS              0x00000800  // TrafficSnapshot
#define DH_RESTORE_INTELLIGENT      0x00001000  // Intelligent Component
#define DH_RESTORE_REMOTEDEVICE     0x00002000  // Remote device configuration
#define DH_RESTORE_DECODERVIDEOOUT  0x00004000  // decode video out
#define DH_RESTORE_LINKMODE         0x00008000  // link mode
#define DH_RESTORE_COMPOSITE        0x00010000  // split screen
#define DH_RESTORE_ALL				0x80000000	// Reset all
    
    // PTZ property list
    // Lower four bytes subnet mask
#define PTZ_DIRECTION				0x00000001	// Direction
#define PTZ_ZOOM					0x00000002	// Zoom
#define PTZ_FOCUS					0x00000004	// Focus
#define PTZ_IRIS					0x00000008	// Aperture
#define PTZ_ALARM					0x00000010	// Alarm function
#define PTZ_LIGHT					0x00000020	// Light
#define PTZ_SETPRESET				0x00000040	// Set preset
#define PTZ_CLEARPRESET				0x00000080	// Delete preset
#define PTZ_GOTOPRESET				0x00000100	// Go to a preset
#define PTZ_AUTOPANON				0x00000200	// Enable pan
#define PTZ_AUTOPANOFF				0x00000400	// isable pan
#define PTZ_SETLIMIT				0x00000800	// Set limit
#define PTZ_AUTOSCANON				0x00001000	// Enable auto scan
#define PTZ_AUTOSCANOFF				0x00002000	// Disable auto scan
#define PTZ_ADDTOUR					0x00004000	// Add tour point
#define PTZ_DELETETOUR				0x00008000	// Delete tour point
#define PTZ_STARTTOUR				0x00010000	// Begin tour
#define PTZ_STOPTOUR				0x00020000	// Stop tour
#define PTZ_CLEARTOUR				0x00040000	// Delete tour
#define PTZ_SETPATTERN				0x00080000	// Set pattern
#define PTZ_STARTPATTERN			0x00100000	// Enbale pattern
#define PTZ_STOPPATTERN				0x00200000	// Disable pattern
#define PTZ_CLEARPATTERN			0x00400000	// Delete pattern
#define PTZ_POSITION				0x00800000	// Position
#define PTZ_AUX						0x01000000	// auxiliary button
#define PTZ_MENU					0x02000000	// Speed dome menu
#define PTZ_EXIT					0x04000000	// Exit speed dome menu
#define PTZ_ENTER					0x08000000	// Confirm
#define PTZ_ESC						0x10000000	// Cancel
#define PTZ_MENUUPDOWN				0x20000000	// Menu up/down
#define PTZ_MENULEFTRIGHT			0x40000000	// Menu left/right
#define PTZ_OPT_NUM					0x80000000	// Operation amount
    // Higher four bytes subnet mask
#define PTZ_DEV						0x00000001	// PTZ control
#define PTZ_MATRIX					0x00000002	// Matrix control
    
    // Snapshot video encode type
#define CODETYPE_MPEG4                    0
#define CODETYPE_H264                     1
#define CODETYPE_JPG                      2
    
    // Bit stream control control list
#define DH_CAPTURE_BRC_CBR                0
#define DH_CAPTURE_BRC_VBR                1
    //#define DH_CAPTURE_BRC_MBR              2
    
    //The frame type mask definition
#define FRAME_TYPE_MOTION                   0x00000001      // MD frame
    
    // the type of intelligent analysis event
#define EVENT_IVS_ALL						0x00000001		// subscription all event
#define EVENT_IVS_CROSSLINEDETECTION		0x00000002		// cross line event
#define EVENT_IVS_CROSSREGIONDETECTION		0x00000003		// cross region event
#define EVENT_IVS_PASTEDETECTION			0x00000004		// past event
#define EVENT_IVS_LEFTDETECTION				0x00000005		// left event
#define EVENT_IVS_STAYDETECTION				0x00000006		// stay event
#define EVENT_IVS_WANDERDETECTION			0x00000007		// wander event
#define EVENT_IVS_PRESERVATION				0x00000008		// reservation event
#define EVENT_IVS_MOVEDETECTION				0x00000009		// move event
#define EVENT_IVS_TAILDETECTION				0x0000000A		// tail event
#define EVENT_IVS_RIOTERDETECTION			0x0000000B		// rioter event
#define EVENT_IVS_FIREDETECTION				0x0000000C		// fire event
#define EVENT_IVS_SMOKEDETECTION			0x0000000D		// smoke event
#define EVENT_IVS_FIGHTDETECTION			0x0000000E		// fight event
#define EVENT_IVS_FLOWSTAT					0x0000000F		// flow stat event
#define EVENT_IVS_NUMBERSTAT				0x00000010		// number stat event
#define EVENT_IVS_CAMERACOVERDDETECTION		0x00000011		// camera cover event
#define EVENT_IVS_CAMERAMOVEDDETECTION		0x00000012		// camera move event
#define EVENT_IVS_VIDEOABNORMALDETECTION	0x00000013		// video abnormal event
#define EVENT_IVS_VIDEOBADDETECTION			0x00000014		// video bad event
#define EVENT_IVS_TRAFFICCONTROL			0x00000015		// traffic control event
#define EVENT_IVS_TRAFFICACCIDENT			0x00000016		// traffic accident event
#define EVENT_IVS_TRAFFICJUNCTION			0x00000017		// traffic junction event
#define EVENT_IVS_TRAFFICGATE				0x00000018		// traffic gate event
#define EVENT_TRAFFICSNAPSHOT				0x00000019		// traffic snapshot
#define EVENT_IVS_FACEDETECT                0x0000001A      // face detection
#define EVENT_IVS_TRAFFICJAM                0x0000001B      // traffic-Jam
#define EVENT_IVS_TRAFFIC_RUNREDLIGHT		0x00000100		// traffic-RunRedLight
#define EVENT_IVS_TRAFFIC_OVERLINE			0x00000101		// traffic-Overline
#define EVENT_IVS_TRAFFIC_RETROGRADE		0x00000102		// traffic-Retrograde
#define EVENT_IVS_TRAFFIC_TURNLEFT			0x00000103		// traffic-TurnLeft
#define EVENT_IVS_TRAFFIC_TURNRIGHT			0x00000104		// traffic-TurnRight
#define EVENT_IVS_TRAFFIC_UTURN				0x00000105		// traffic-Uturn
#define EVENT_IVS_TRAFFIC_OVERSPEED			0x00000106		// traffic-Overspeed
#define EVENT_IVS_TRAFFIC_UNDERSPEED		0x00000107		// traffic-Underspeed
#define EVENT_IVS_TRAFFIC_PARKING           0x00000108      // traffic-Parking
#define EVENT_IVS_TRAFFIC_WRONGROUTE        0x00000109      // traffic-WrongRoute
#define EVENT_IVS_TRAFFIC_CROSSLANE         0x0000010A      // traffic-CrossLane
#define EVENT_IVS_TRAFFIC_OVERYELLOWLINE    0x0000010B      // traffic-OverYellowLine
#define EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER 0x0000010C      // traffic-DrivingOnShoulder
#define EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE 0x0000010E      // traffic-YellowPlateInLane
#define EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY 0x0000010F		// Traffic offense-Pedestral has higher priority at the  crosswalk
#define EVENT_IVS_CROSSFENCEDETECTION       0x0000011F      // cross fence
#define EVENT_IVS_ELECTROSPARKDETECTION     0X00000110      // ElectroSpark event
#define EVENT_IVS_TRAFFIC_NOPASSING         0x00000111      // no passing
#define EVENT_IVS_ABNORMALRUNDETECTION      0x00000112      // abnormal run
#define EVENT_IVS_RETROGRADEDETECTION       0x00000113      // retrograde
#define EVENT_IVS_INREGIONDETECTION         0x00000114      // in region detection
#define EVENT_IVS_TAKENAWAYDETECTION        0x00000115      // taking away things
#define EVENT_IVS_PARKINGDETECTION          0x00000116      // parking
#define EVENT_IVS_FACERECOGNITION			0x00000117		// face recognition
#define EVENT_IVS_TRAFFIC_MANUALSNAP        0x00000118      // manual snap
#define EVENT_IVS_TRAFFIC_FLOWSTATE			0x00000119		// traffic flow state
#define EVENT_IVS_TRAFFIC_STAY				0x0000011A		// traffic stay
#define EVENT_IVS_TRAFFIC_VEHICLEINROUTE	0x0000011B		// traffic vehicle route
#define EVENT_ALARM_MOTIONDETECT            0x0000011C      // motion detect
#define EVENT_ALARM_LOCALALARM              0x0000011D      // local alarm
#define EVENT_IVS_PRISONERRISEDETECTION		0x0000011E		// prisoner rise detect
#define EVENT_IVS_TRAFFIC_TOLLGATE			0x00000120		// traffic tollgate
#define EVENT_IVS_DENSITYDETECTION			0x00000121      // density detection of persons
#define EVENT_IVS_VIDEODIAGNOSIS            0x00000122		// video diagnosis result
#define EVENT_IVS_QUEUEDETECTION            0x00000123      // queue detection
#define EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE 0x00000124      // take up in bus route
#define EVENT_IVS_TRAFFIC_BACKING           0x00000125      // illegal astern
#define EVENT_IVS_AUDIO_ABNORMALDETECTION   0x00000126      // audio abnormity
#define EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT    0x00000127      // run yellow light
#define EVENT_IVS_CLIMBDETECTION            0x00000128      // climb detection
#define EVENT_IVS_LEAVEDETECTION            0x00000129      // leave detection
#define EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX    0x0000012A        // parking on yellow box
#define EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING   0x0000012B        // parking space parking
#define EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING 0x0000012C        // parking space no parking
#define EVENT_IVS_TRAFFIC_PEDESTRAIN            0x0000012D        // passerby
#define EVENT_IVS_TRAFFIC_THROW                 0x0000012E        // throw
#define EVENT_IVS_TRAFFIC_IDLE                  0x0000012F        // idle
#define EVENT_ALARM_VEHICLEACC                  0x00000130        // Vehicle ACC power outage alarm events
#define EVENT_ALARM_VEHICLE_TURNOVER            0x00000131        // Vehicle rollover alarm events
#define EVENT_ALARM_VEHICLE_COLLISION           0x00000132        // Vehicle crash alarm events
#define EVENT_ALARM_VEHICLE_LARGE_ANGLE         0x00000133        // On-board camera large Angle turn events
#define EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE  0x00000134        // Parking line pressing events
#define EVENT_IVS_MULTISCENESWITCH              0x00000135        // Many scenes switching events
#define EVENT_IVS_TRAFFIC_RESTRICTED_PLATE      0X00000136        // Limited license plate event
#define EVENT_IVS_TRAFFIC_OVERSTOPLINE          0X00000137        // Cross stop line event
#define EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT      0x00000138        // Traffic unfasten seat belt event
#define EVENT_IVS_TRAFFIC_DRIVER_SMOKING        0x00000139        // Driver smoking event
#define EVENT_IVS_TRAFFIC_DRIVER_CALLING        0x0000013A        // Driver call event
#define EVENT_IVS_OBJECT_DETECTION              0x00000141        // Object feature detection event
#define EVENT_ALARM_ANALOGALARM                 0x00000150        // Analog alarm channel??s alarm event(correspondingDEV_EVENT_ALARM_ANALOGALRM_INFO)
#define EVENT_IVS_CROSSLINEDETECTION_EX	        0x00000151        // Warning lineexpansion event
#define EVENT_ALARM_COMMON                      0x00000152        // Normal Record
#define EVENT_ALARM_VIDEOBLIND                  0x00000153        // Video tampering event
#define EVENT_ALARM_VIDEOLOSS                   0x00000154        // Video loss event
#define EVENT_IVS_GETOUTBEDDETECTION			0x00000155		  // Event of getting out bed detection
#define EVENT_IVS_PATROLDETECTION			    0x00000156		  // Event of patrol detection
#define EVENT_IVS_ONDUTYDETECTION				0x00000157		  // Event of on duty detection
#define EVENT_IVS_NOANSWERCALL                  0x00000158        // Event of VTO do not answer calling request
#define EVENT_IVS_STORAGENOTEXIST               0x00000159        // Event of storage do not exist
#define EVENT_IVS_STORAGELOWSPACE               0x0000015A        // Event of storage space low
#define EVENT_IVS_STORAGEFAILURE                0x0000015B        // Event of storage failure
#define EVENT_IVS_PROFILEALARMTRANSMIT          0x0000015C        // Event of profile alarm transmit
#define EVENT_IVS_VIDEOSTATIC                   0x0000015D        // Event of static video detect(corresponding DEV_EVENT_ALARM_VIDEOSTATIC_INFO)
#define EVENT_IVS_VIDEOTIMING                   0x0000015E        // Event of video timing detect(corresponding DEV_EVENT_ALARM_VIDEOTIMING_INFO)
    
#define EVENT_IVS_TRAFFIC_ALL                   0x000001FF        // All event start with [TRAFFIC]
    // EVENT_IVS_TRAFFICCONTROL -> EVENT_TRAFFICSNAPSHOT
    // EVENT_IVS_TRAFFIC_RUNREDLIGHT -> EVENT_IVS_TRAFFIC_UNDERSPEED
#define EVENT_IVS_VIDEOANALYSE                  0x00000200        // All IVS events
    
    //Traffic statistics event using macros
#define FLOWSTAT_ADDR_NAME                     16              //Has long place name
    
    // interface CLIENT_OperateTrafficList, All kinds of string length definition
#define DH_TARFFIC_NAME_LEN                     16
#define DH_CREATE_TIME_LEN                      32
#define DH_AUTHORITY_NUM                        16
    
    
    // Error type code. Corresponding to the return value of CLIENT_GetLastError
#define _EC(x)						(0x80000000|x)
#define NET_NOERROR 				0			// No error
#define NET_ERROR					-1			// Unknown error
#define NET_SYSTEM_ERROR			_EC(1)		// Windows system error
#define NET_NETWORK_ERROR			_EC(2)		// Protocol error it may result from network timeout
#define NET_DEV_VER_NOMATCH			_EC(3)		// Device protocol does not match
#define NET_INVALID_HANDLE			_EC(4)		// Handle is invalid
#define NET_OPEN_CHANNEL_ERROR		_EC(5)		// Failed to open channel
#define NET_CLOSE_CHANNEL_ERROR		_EC(6)		// Failed to close channel
#define NET_ILLEGAL_PARAM			_EC(7)		// User parameter is illegal
#define NET_SDK_INIT_ERROR			_EC(8)		// SDK initialization error
#define NET_SDK_UNINIT_ERROR		_EC(9)		// SDK clear error
#define NET_RENDER_OPEN_ERROR		_EC(10)		// Error occurs when apply for render resources.
#define NET_DEC_OPEN_ERROR			_EC(11)		// Error occurs when opening the decoder library
#define NET_DEC_CLOSE_ERROR			_EC(12)		// Error occurs when closing the decoder library
#define NET_MULTIPLAY_NOCHANNEL		_EC(13)		// The detected channel number is 0 in multiple-channel preview.
#define NET_TALK_INIT_ERROR			_EC(14)		// Failed to initialize record library
#define NET_TALK_NOT_INIT			_EC(15)		// The record library has not been initialized
#define	NET_TALK_SENDDATA_ERROR		_EC(16)		// Error occurs when sending out audio data
#define NET_REAL_ALREADY_SAVING		_EC(17)		// The real-time has been protected.
#define NET_NOT_SAVING				_EC(18)		// The real-time data has not been save.
#define NET_OPEN_FILE_ERROR			_EC(19)		// Error occurs when opening the file.
#define NET_PTZ_SET_TIMER_ERROR		_EC(20)		// Failed to enable PTZ to control timer.
#define NET_RETURN_DATA_ERROR		_EC(21)		// Error occurs when verify returned data.
#define NET_INSUFFICIENT_BUFFER		_EC(22)		// There is no sufficient buffer.
#define NET_NOT_SUPPORTED			_EC(23)		// The current SDK does not support this fucntion.
#define NET_NO_RECORD_FOUND			_EC(24)		// There is no searched result.
#define NET_NOT_AUTHORIZED			_EC(25)		// You have no operation right.
#define NET_NOT_NOW					_EC(26)		// Can not operate right now.
#define NET_NO_TALK_CHANNEL			_EC(27)		// There is no audio talk channel.
#define NET_NO_AUDIO				_EC(28)		// There is no audio.
#define NET_NO_INIT					_EC(29)		// The network SDK has not been initialized.
#define NET_DOWNLOAD_END			_EC(30)		// The download completed.
#define NET_EMPTY_LIST				_EC(31)		// There is no searched result.
#define NET_ERROR_GETCFG_SYSATTR	_EC(32)		// Failed to get system property setup.
#define NET_ERROR_GETCFG_SERIAL		_EC(33)		// Failed to get SN.
#define NET_ERROR_GETCFG_GENERAL	_EC(34)		// Failed to get general property.
#define NET_ERROR_GETCFG_DSPCAP		_EC(35)		// Failed to get DSP capacity description.
#define NET_ERROR_GETCFG_NETCFG		_EC(36)		// Failed to get network channel setup.
#define NET_ERROR_GETCFG_CHANNAME	_EC(37)		// Failed to get channel name.
#define NET_ERROR_GETCFG_VIDEO		_EC(38)		// Failed to get video property.
#define NET_ERROR_GETCFG_RECORD		_EC(39)		// Failed to get record setup
#define NET_ERROR_GETCFG_PRONAME	_EC(40)		// Failed to get decoder protocol name
#define NET_ERROR_GETCFG_FUNCNAME	_EC(41)		// Failed to get 232 COM function name.
#define NET_ERROR_GETCFG_485DECODER	_EC(42)		// Failed to get decoder property
#define NET_ERROR_GETCFG_232COM		_EC(43)		// Failed to get 232 COM setup
#define NET_ERROR_GETCFG_ALARMIN	_EC(44)		// Failed to get external alarm input setup
#define NET_ERROR_GETCFG_ALARMDET	_EC(45)		// Failed to get motion detection alarm
#define NET_ERROR_GETCFG_SYSTIME	_EC(46)		// Failed to get device time
#define NET_ERROR_GETCFG_PREVIEW	_EC(47)		// Failed to get preview parameter
#define NET_ERROR_GETCFG_AUTOMT		_EC(48)		// Failed to get audio maintenance setup
#define NET_ERROR_GETCFG_VIDEOMTRX	_EC(49)		// Failed to get video matrix setup
#define NET_ERROR_GETCFG_COVER		_EC(50)		// Failed to get privacy mask zone setup
#define NET_ERROR_GETCFG_WATERMAKE	_EC(51)		// Failed to get video watermark setup
#define NET_ERROR_GETCFG_MULTICAST	_EC(52)	    // Failed to get config??multicast port by channel
#define NET_ERROR_SETCFG_GENERAL	_EC(55)		// Failed to modify general property
#define NET_ERROR_SETCFG_NETCFG		_EC(56)		// Failed to modify channel setup
#define NET_ERROR_SETCFG_CHANNAME	_EC(57)		// Failed to modify channel name
#define NET_ERROR_SETCFG_VIDEO		_EC(58)		// Failed to modify video channel
#define NET_ERROR_SETCFG_RECORD		_EC(59)		// Failed to modify record setup
#define NET_ERROR_SETCFG_485DECODER	_EC(60)		// Failed to modify decoder property
#define NET_ERROR_SETCFG_232COM		_EC(61)		// Failed to modify 232 COM setup
#define NET_ERROR_SETCFG_ALARMIN	_EC(62)		// Failed to modify external input alarm setup
#define NET_ERROR_SETCFG_ALARMDET	_EC(63)		// Failed to modify motion detection alarm setup
#define NET_ERROR_SETCFG_SYSTIME	_EC(64)		// Failed to modify device time
#define NET_ERROR_SETCFG_PREVIEW	_EC(65)		// Failed to modify preview parameter
#define NET_ERROR_SETCFG_AUTOMT		_EC(66)		// Failed to modify auto maintenance setup
#define NET_ERROR_SETCFG_VIDEOMTRX	_EC(67)		// Failed to modify video matrix setup
#define NET_ERROR_SETCFG_COVER		_EC(68)		// Failed to modify privacy mask zone
#define NET_ERROR_SETCFG_WATERMAKE	_EC(69)		// Failed to modify video watermark setup
#define NET_ERROR_SETCFG_WLAN		_EC(70)		// Failed to modify wireless network information
#define NET_ERROR_SETCFG_WLANDEV	_EC(71)		// Failed to select wireless network device
#define NET_ERROR_SETCFG_REGISTER	_EC(72)		// Failed to modify the actively registration parameter setup.
#define NET_ERROR_SETCFG_CAMERA		_EC(73)		// Failed to modify camera property
#define NET_ERROR_SETCFG_INFRARED	_EC(74)		// Failed to modify IR alarm setup
#define NET_ERROR_SETCFG_SOUNDALARM	_EC(75)		// Failed to modify audio alarm setup
#define NET_ERROR_SETCFG_STORAGE    _EC(76)		// Failed to modify storage position setup
#define NET_AUDIOENCODE_NOTINIT		_EC(77)		// The audio encode port has not been successfully initialized.
#define NET_DATA_TOOLONGH			_EC(78)		// The data are too long.
#define NET_UNSUPPORTED				_EC(79)		// The device does not support current operation.
#define NET_DEVICE_BUSY				_EC(80)		// Device resources is not sufficient.
#define NET_SERVER_STARTED			_EC(81)		// The server has boot up
#define NET_SERVER_STOPPED			_EC(82)		// The server has not fully boot up
#define NET_LISTER_INCORRECT_SERIAL	_EC(83)		// Input serial number is not correct.
#define NET_QUERY_DISKINFO_FAILED	_EC(84)		// Failed to get HDD information.
#define NET_ERROR_GETCFG_SESSION	_EC(85)		// Failed to get connect session information.
#define NET_USER_FLASEPWD_TRYTIME	_EC(86)		// The password you typed is incorrect. You have exceeded the maximum number of retries.
#define NET_LOGIN_ERROR_PASSWORD	_EC(100)	// Password is not correct
#define NET_LOGIN_ERROR_USER		_EC(101)	// The account does not exist
#define NET_LOGIN_ERROR_TIMEOUT		_EC(102)	// Time out for log in returned value.
#define NET_LOGIN_ERROR_RELOGGIN	_EC(103)	// The account has logged in
#define NET_LOGIN_ERROR_LOCKED		_EC(104)	// The account has been locked
#define NET_LOGIN_ERROR_BLACKLIST	_EC(105)	// The account bas been in the black list
#define NET_LOGIN_ERROR_BUSY		_EC(106)	// Resources are not sufficient. System is busy now.
#define NET_LOGIN_ERROR_CONNECT		_EC(107)	// Time out. Please check network and try again.
#define NET_LOGIN_ERROR_NETWORK		_EC(108)	// Network connection failed.
#define NET_LOGIN_ERROR_SUBCONNECT	_EC(109)	// Successfully logged in the device but can not create video channel. Please check network connection.
#define NET_LOGIN_ERROR_MAXCONNECT  _EC(110)    // exceed the max connect number
#define NET_LOGIN_ERROR_PROTOCOL3_ONLY _EC(111)	// protocol 3 support
#define NET_LOGIN_ERROR_UKEY_LOST	_EC(112)	// There is no USB or USB info error
#define NET_LOGIN_ERROR_NO_AUTHORIZED _EC(113)  // Client-end IP address has no right to login
#define NET_RENDER_SOUND_ON_ERROR	_EC(120)	// Error occurs when Render library open audio.
#define NET_RENDER_SOUND_OFF_ERROR	_EC(121)	// Error occurs when Render library close audio
#define NET_RENDER_SET_VOLUME_ERROR	_EC(122)	// Error occurs when Render library control volume
#define NET_RENDER_ADJUST_ERROR		_EC(123)	// Error occurs when Render library set video parameter
#define NET_RENDER_PAUSE_ERROR		_EC(124)	// Error occurs when Render library pause play
#define NET_RENDER_SNAP_ERROR		_EC(125)	// Render library snapshot error
#define NET_RENDER_STEP_ERROR		_EC(126)	// Render library stepper error
#define NET_RENDER_FRAMERATE_ERROR	_EC(127)	// Error occurs when Render library set frame rate.
#define NET_RENDER_DISPLAYREGION_ERROR	_EC(128)// Error occurs when Render lib setting show region
#define NET_GROUP_EXIST				_EC(140)	// Group name has been existed.
#define	NET_GROUP_NOEXIST			_EC(141)	// The group name does not exist.
#define NET_GROUP_RIGHTOVER			_EC(142)	// The group right exceeds the right list!
#define NET_GROUP_HAVEUSER			_EC(143)	// The group can not be removed since there is user in it!
#define NET_GROUP_RIGHTUSE			_EC(144)	// The user has used one of the group right. It can not be removed.
#define NET_GROUP_SAMENAME			_EC(145)	// New group name has been existed
#define	NET_USER_EXIST				_EC(146)	// The user name has been existed
#define NET_USER_NOEXIST			_EC(147)	// The account does not exist.
#define NET_USER_RIGHTOVER			_EC(148)	// User right exceeds the group right.
#define NET_USER_PWD				_EC(149)	// Reserved account. It does not allow to be modified.
#define NET_USER_FLASEPWD			_EC(150)	// password is not correct
#define NET_USER_NOMATCHING			_EC(151)	// Password is invalid
#define NET_USER_INUSE				_EC(152)	// account in use
#define NET_ERROR_GETCFG_ETHERNET	_EC(300)	// Failed to get network card setup.
#define NET_ERROR_GETCFG_WLAN		_EC(301)	// Failed to get wireless network information.
#define NET_ERROR_GETCFG_WLANDEV	_EC(302)	// Failed to get wireless network device.
#define NET_ERROR_GETCFG_REGISTER	_EC(303)	// Failed to get actively registration parameter.
#define NET_ERROR_GETCFG_CAMERA		_EC(304)	// Failed to get camera property
#define NET_ERROR_GETCFG_INFRARED	_EC(305)	// Failed to get IR alarm setup
#define NET_ERROR_GETCFG_SOUNDALARM	_EC(306)	// Failed to get audio alarm setup
#define NET_ERROR_GETCFG_STORAGE    _EC(307)	// Failed to get storage position
#define NET_ERROR_GETCFG_MAIL		_EC(308)	// Failed to get mail setup.
#define NET_CONFIG_DEVBUSY			_EC(309)	// Can not set right now.
#define NET_CONFIG_DATAILLEGAL		_EC(310)	// The configuration setup data are illegal.
#define NET_ERROR_GETCFG_DST        _EC(311)    // Failed to get DST setup
#define NET_ERROR_SETCFG_DST        _EC(312)    // Failed to set DST
#define NET_ERROR_GETCFG_VIDEO_OSD  _EC(313)    // Failed to get video osd setup.
#define NET_ERROR_SETCFG_VIDEO_OSD  _EC(314)    // Failed to set video osd
#define NET_ERROR_GETCFG_GPRSCDMA   _EC(315)    // Failed to get CDMA\GPRS configuration
#define NET_ERROR_SETCFG_GPRSCDMA   _EC(316)    // Failed to set CDMA\GPRS configuration
#define NET_ERROR_GETCFG_IPFILTER   _EC(317)    // Failed to get IP Filter configuration
#define NET_ERROR_SETCFG_IPFILTER   _EC(318)    // Failed to set IP Filter configuration
#define NET_ERROR_GETCFG_TALKENCODE _EC(319)    // Failed to get Talk Encode configuration
#define NET_ERROR_SETCFG_TALKENCODE _EC(320)    // Failed to set Talk Encode configuration
#define NET_ERROR_GETCFG_RECORDLEN  _EC(321)    // Failed to get The length of the video package configuration
#define NET_ERROR_SETCFG_RECORDLEN  _EC(322)    // Failed to set The length of the video package configuration
#define	NET_DONT_SUPPORT_SUBAREA	_EC(323)	// Not support Network hard disk partition
#define	NET_ERROR_GET_AUTOREGSERVER	_EC(324)	// Failed to get the register server information
#define	NET_ERROR_CONTROL_AUTOREGISTER		_EC(325)	// Failed to control actively registration
#define	NET_ERROR_DISCONNECT_AUTOREGISTER	_EC(326)	// Failed to disconnect actively registration
#define NET_ERROR_GETCFG_MMS				_EC(327)	// Failed to get mms configuration
#define NET_ERROR_SETCFG_MMS				_EC(328)	// Failed to set mms configuration
#define NET_ERROR_GETCFG_SMSACTIVATION      _EC(329)	// Failed to get SMS configuration
#define NET_ERROR_SETCFG_SMSACTIVATION      _EC(330)	// Failed to set SMS configuration
#define NET_ERROR_GETCFG_DIALINACTIVATION	_EC(331)	// Failed to get activation of a wireless connection
#define NET_ERROR_SETCFG_DIALINACTIVATION	_EC(332)	// Failed to set activation of a wireless connection
#define NET_ERROR_GETCFG_VIDEOOUT           _EC(333)    // Failed to get the parameter of video output
#define NET_ERROR_SETCFG_VIDEOOUT			_EC(334)	// Failed to set the configuration of video output
#define NET_ERROR_GETCFG_OSDENABLE			_EC(335)	// Failed to get osd overlay enabling
#define NET_ERROR_SETCFG_OSDENABLE			_EC(336)	// Failed to set OSD overlay enabling
#define NET_ERROR_SETCFG_ENCODERINFO        _EC(337)    // Failed to set digital input configuration of front encoders
#define NET_ERROR_GETCFG_TVADJUST		    _EC(338)	// Failed to get TV adjust configuration
#define NET_ERROR_SETCFG_TVADJUST			_EC(339)	// Failed to set TV adjust configuration
#define NET_ERROR_CONNECT_FAILED			_EC(340)	// Failed to request to establish a connection
#define NET_ERROR_SETCFG_BURNFILE			_EC(341)	// Failed to request to upload burn files
#define NET_ERROR_SNIFFER_GETCFG			_EC(342)	// // Failed to get capture configuration information
#define NET_ERROR_SNIFFER_SETCFG			_EC(343)	// Failed to set capture configuration information
#define NET_ERROR_DOWNLOADRATE_GETCFG		_EC(344)	// Failed to get download restrictions information
#define NET_ERROR_DOWNLOADRATE_SETCFG		_EC(345)	// Failed to set download restrictions information
#define NET_ERROR_SEARCH_TRANSCOM			_EC(346)	// Failed to query serial port parameters
#define NET_ERROR_GETCFG_POINT				_EC(347)	// Failed to get the preset info
#define NET_ERROR_SETCFG_POINT				_EC(348)	// Failed to set the preset info
#define NET_SDK_LOGOUT_ERROR				_EC(349)    // SDK log out the device abnormally
#define NET_ERROR_GET_VEHICLE_CFG			_EC(350)	// Failed to get vehicle configuration
#define NET_ERROR_SET_VEHICLE_CFG			_EC(351)	// Failed to set vehicle configuration
#define NET_ERROR_GET_ATM_OVERLAY_CFG		_EC(352)	// Failed to get ATM overlay configuration
#define NET_ERROR_SET_ATM_OVERLAY_CFG		_EC(353)	// Failed to set ATM overlay configuration
#define NET_ERROR_GET_ATM_OVERLAY_ABILITY	_EC(354)	// Failed to get ATM overlay ability
#define NET_ERROR_GET_DECODER_TOUR_CFG		_EC(355)	// Failed to get decoder tour configuration
#define NET_ERROR_SET_DECODER_TOUR_CFG		_EC(356)	// Failed to set decoder tour configuration
#define NET_ERROR_CTRL_DECODER_TOUR			_EC(357)	// Failed to control decoder tour
#define NET_GROUP_OVERSUPPORTNUM			_EC(358)	// Beyond the device supports for the largest number of user groups
#define NET_USER_OVERSUPPORTNUM				_EC(359)	// Beyond the device supports for the largest number of users
#define NET_ERROR_GET_SIP_CFG				_EC(368)	// Failed to get SIP configuration
#define NET_ERROR_SET_SIP_CFG				_EC(369)	// Failed to set SIP configuration
#define NET_ERROR_GET_SIP_ABILITY			_EC(370)	// Failed to get SIP capability
#define NET_ERROR_GET_WIFI_AP_CFG			_EC(371)	// Failed to get "WIFI ap' configuration
#define NET_ERROR_SET_WIFI_AP_CFG			_EC(372)	// Failed to set "WIFI ap" configuration
#define NET_ERROR_GET_DECODE_POLICY		    _EC(373)	// Failed to get decode policy
#define NET_ERROR_SET_DECODE_POLICY			_EC(374)	// Failed to set decode policy
#define NET_ERROR_TALK_REJECT				_EC(375)	// refuse talk
#define NET_ERROR_TALK_OPENED				_EC(376)	// talk has opened by other client
#define NET_ERROR_TALK_RESOURCE_CONFLICIT   _EC(377)	// resource conflict
#define NET_ERROR_TALK_UNSUPPORTED_ENCODE   _EC(378)	// unsupported encode type
#define NET_ERROR_TALK_RIGHTLESS			_EC(379)	// no right
#define NET_ERROR_TALK_FAILED				_EC(380)	// request failed
#define NET_ERROR_GET_MACHINE_CFG			_EC(381)	// Failed to get device relative config
#define NET_ERROR_SET_MACHINE_CFG			_EC(382)	// Failed to set device relative config
#define NET_ERROR_GET_DATA_FAILED			_EC(383)	// get data failed
#define NET_ERROR_MAC_VALIDATE_FAILED       _EC(384)    // MAC validate failed
#define NET_ERROR_GET_INSTANCE              _EC(385)    // Failed to get server instance
#define NET_ERROR_JSON_REQUEST              _EC(386)    // Generated json string is error
#define NET_ERROR_JSON_RESPONSE             _EC(387)    // The responding json string is error
#define NET_ERROR_VERSION_HIGHER            _EC(388)    // The protocol version is lower than current version
#define NET_SPARE_NO_CAPACITY				_EC(389)	// Hotspare disk operation failed. The capacity is low
#define NET_ERROR_SOURCE_IN_USE				_EC(390)	// Display source is used by other output
#define NET_ERROR_REAVE                     _EC(391)    // advanced users grab low-level user resource
#define NET_ERROR_NETFORBID                 _EC(392)    // net forbid
#define NET_ERROR_GETCFG_MACFILTER			_EC(393)    // get MAC filter configuration error
#define NET_ERROR_SETCFG_MACFILTER			_EC(394)    // set MAC filter configuration error
#define NET_ERROR_GETCFG_IPMACFILTER		_EC(395)    // get IP/MAC filter configuration error
#define NET_ERROR_SETCFG_IPMACFILTER		_EC(396)    // set IP/MAC filter configuration error
#define NET_ERROR_OPERATION_OVERTIME        _EC(397)    // operation over time
#define NET_ERROR_SENIOR_VALIDATE_FAILED    _EC(398)    // senior validation failure
#define NET_ERROR_DEVICE_ID_NOT_EXIST		_EC(399)	// device ID is not exist
#define NET_ERROR_UNSUPPORTED               _EC(400)    // unsupport operation
#define NET_ERROR_PROXY_DLLLOAD				_EC(401)	// proxy dll load error
#define NET_ERROR_PROXY_ILLEGAL_PARAM		_EC(402)	// proxy user parameter is not legal
#define NET_ERROR_PROXY_INVALID_HANDLE		_EC(403)	// handle invalid
#define NET_ERROR_PROXY_LOGIN_DEVICE_ERROR	_EC(404)	// login device error
#define NET_ERROR_PROXY_START_SERVER_ERROR	_EC(405)	// start proxy server error
#define NET_ERROR_SPEAK_FAILED				_EC(406)	// request speak failed
#define NET_ERROR_NOT_SUPPORT_F6            _EC(407)    // unsupport F6
#define NET_ERROR_CD_UNREADY				_EC(408)	// CD is not ready
#define NET_ERROR_DIR_NOT_EXIST				_EC(409)	// Directory does not exist
#define NET_ERROR_UNSUPPORTED_SPLIT_MODE	_EC(410)	// The device does not support the segmentation model
#define NET_ERROR_OPEN_WND_PARAM			_EC(411)	// Open the window parameter is illegal
#define NET_ERROR_LIMITED_WND_COUNT			_EC(412)	// Open the window more than limit
#define NET_ERROR_UNMATCHED_REQUEST			_EC(413)	// Request command with the current pattern don't match
#define NET_RENDER_ENABLELARGEPICADJUSTMENT_ERROR	_EC(414)	// Render Library to enable high-definition image internal adjustment strategy error
#define NET_ERROR_UPGRADE_FAILED            _EC(415)    // Upgrade equipment failure
#define	NET_ERROR_NO_TARGET_DEVICE			_EC(416)	// Can't find the target device
#define	NET_ERROR_NO_VERIFY_DEVICE			_EC(417)	// Can't find the verify device
#define	NET_ERROR_CASCADE_RIGHTLESS			_EC(418)	// No cascade permissions
#define NET_ERROR_LOW_PRIORITY				_EC(419)	// low priority
#define NET_ERROR_REMOTE_REQUEST_TIMEOUT	_EC(420)	// The remote device request timeout
#define NET_ERROR_LIMITED_INPUT_SOURCE		_EC(421)	//Input source beyond maximum route restrictions
#define NET_ERROR_SET_LOG_PRINT_INFO        _EC(422)    // Failed to set log print
#define NET_ERROR_PARAM_DWSIZE_ERROR        _EC(423)    // "dwSize" is not initialized in input param
#define NET_ERROR_LIMITED_MONITORWALL_COUNT _EC(424)    // TV wall exceed limit
#define NET_ERROR_PART_PROCESS_FAILED       _EC(425)    // Fail to execute part of the process
#define NET_ERROR_TARGET_NOT_SUPPORT        _EC(426)    // Fail to transmit due to not supported by target
#define NET_ERROR_VISITE_FILE				_EC(510)	// Access to the file failed
#define NET_ERROR_DEVICE_STATUS_BUSY		_EC(511)	// Device busy
#define NET_USER_PWD_NOT_AUTHORIZED         _EC(512)    // Fail to change the password
#define NET_USER_PWD_NOT_STRONG             _EC(513)    // Password strength is not enough
#define NET_ERROR_NO_SUCH_CONFIG            _EC(513)    // No such kind of config
    
    /************************************************************************
     ** Enumeration Definition
     ***********************************************************************/
    //Card information types CLIENT_QueryNetStat interface using
    typedef enum tagEM_NET_QUERY_TYPE
    {
        NET_APP_DATA_STAT , // Statistics for protocol stack,(input struct NET_IN_NETAPP_NET_DATA_STAT,output struct NET_OUT_NETAPP_NET_DATA_STAT)
        NET_APP_LINK_STAT , // Access to physical link state,(input structNET_IN_NETAPP_LINK_STATUS,output struct NET_OUT_NETAPP_LINK_STATUS)
    }EM_NET_QUERY_TYPE;
    
    // Catch a figure type CLIENT_CapturePictureEx interface using
    typedef enum tagNET_CAPTURE_FORMATS
    {
        NET_CAPTURE_BMP,
        NET_CAPTURE_JPEG, // 100% quality JPEG
        NET_CAPTURE_JPEG_70, // 70% quality JPEG
        NET_CAPTURE_JPEG_50,
        NET_CAPTURE_JPEG_30,
    }NET_CAPTURE_FORMATS;
    
    // Device type
    typedef enum tagNET_DEVICE_TYPE
    {
        NET_PRODUCT_NONE = 0,
        NET_DVR_NONREALTIME_MACE,					// Non real-time MACE
        NET_DVR_NONREALTIME,						// Non real-time
        NET_NVS_MPEG1,								// Network video server
        NET_DVR_MPEG1_2,							// MPEG1 2-ch DVR
        NET_DVR_MPEG1_8,							// MPEG1 8-ch DVR
        NET_DVR_MPEG4_8,							// MPEG4 8-ch DVR
        NET_DVR_MPEG4_16,							// MPEG4 16-ch DVR
        NET_DVR_MPEG4_SX2,							// LB series DVR
        NET_DVR_MEPG4_ST2,							// GB  series DVR
        NET_DVR_MEPG4_SH2,							// HB  series DVR
        NET_DVR_MPEG4_GBE,							// GBE  series DVR
        NET_DVR_MPEG4_NVSII,						// II network video server
        NET_DVR_STD_NEW,							// New standard configuration protocol
        NET_DVR_DDNS,								// DDNS server
        NET_DVR_ATM,								// ATM series
        NET_NB_SERIAL,								// 2nd non real-time NB series DVR
        NET_LN_SERIAL,								// LN  series
        NET_BAV_SERIAL,								// BAV series
        NET_SDIP_SERIAL,							// SDIP series
        NET_IPC_SERIAL,								// IPC series
        NET_NVS_B,									// NVS B series
        NET_NVS_C,									// NVS H series
        NET_NVS_S,									// NVS S series
        NET_NVS_E,									// NVS E series
        NET_DVR_NEW_PROTOCOL,						// Search device type from QueryDevState. it is in string format
        NET_NVD_SERIAL,								// NVD
        NET_DVR_N5,									// N5
        NET_DVR_MIX_DVR,							// HDVR
        NET_SVR_SERIAL,								// SVR series
        NET_SVR_BS,									// SVR-BS
        NET_NVR_SERIAL,								// NVR series
        NET_DVR_N51,                                // N51
        NET_ITSE_SERIAL,							// ITSE Intelligent Analysis Box
        NET_ITC_SERIAL,                             // Intelligent traffic camera equipment
        NET_HWS_SERIAL,                             // radar speedometer HWS
        NET_PVR_SERIAL,                             // portable video record
        NET_IVS_SERIAL,                             // IVS(intelligent video server series)
        NET_IVS_B,                                  // universal intelligent detect video server series
        NET_IVS_F,                                  // face recognisation server
        NET_IVS_V,                                  // video quality diagnosis server
        NET_MATRIX_SERIAL,							// matrix
        NET_DVR_N52,								// N52
        NET_DVR_N56,								// N56
        NET_ESS_SERIAL,                             // ESS
        NET_IVS_PC,                                 // number statistic server
        NET_PC_NVR,                                 // pc-nvr
        NET_DSCON,									// screen controller
        NET_EVS,									// network video storage server
        NET_EIVS,									// an embedded intelligent video analysis system
        NET_DVR_N6,                                 // DVR-N6
        NET_UDS,                                    // K-Lite Codec Pack
        NET_AF6016,									// Bank alarm host
        NET_AS5008,									//Video network alarm host
        NET_AH2008,									//Network alarm host
        NET_A_SERIAL,								// Alarm host series
        NET_BSC_SERIAL,								// Access control series of products
        NET_NVS_SERIAL,                             // NVS series product
        NET_VTO_SERIAL,                             // VTO series product
        NET_VTNC_SERIAL,                            // VTNC series product
    }NET_DEVICE_TYPE ;
    
    // Language type
    typedef enum __LANGUAGE_TYPE
    {
        DH_LANGUAGE_ENGLISH,						// English
        DH_LANGUAGE_CHINESE_SIMPLIFIED,				// Simplified Chinese
        DH_LANGUAGE_CHINESE_TRADITIONAL,			// Traditional Chinese
        DH_LANGUAGE_ITALIAN,						// Italian
        DH_LANGUAGE_SPANISH,						// Spanish
        DH_LANGUAGE_JAPANESE,						// Japanese
        DH_LANGUAGE_RUSSIAN,						// Russian
        DH_LANGUAGE_FRENCH,							// French
        DH_LANGUAGE_GERMAN, 						// German
        DH_LANGUAGE_PORTUGUESE,						// Portuguese
        DH_LANGUAGE_TURKEY,							// Turkey
        DH_LANGUAGE_POLISH,							// Polish
        DH_LANGUAGE_ROMANIAN,						// Romanian
        DH_LANGUAGE_HUNGARIAN,						// Hungarian
        DH_LANGUAGE_FINNISH,						// Finnish
        DH_LANGUAGE_ESTONIAN,						// Estonian
        DH_LANGUAGE_KOREAN,							// Korean
        DH_LANGUAGE_FARSI,							// Farsi
        DH_LANGUAGE_DANSK,							// Denmark
        DH_LANGUAGE_CZECHISH,						// Czechish
        DH_LANGUAGE_BULGARIA,						// Bulgaria
        DH_LANGUAGE_SLOVAKIAN,						// Slovakian
        DH_LANGUAGE_SLOVENIA,						// Slovenia
        DH_LANGUAGE_CROATIAN,						// Croatian
        DH_LANGUAGE_DUTCH,							// Dutch
        DH_LANGUAGE_GREEK,							// Greek
        DH_LANGUAGE_UKRAINIAN,						// Ukrainian
        DH_LANGUAGE_SWEDISH,						// Swedish
        DH_LANGUAGE_SERBIAN,						// Serbian
        DH_LANGUAGE_VIETNAMESE,						// Vietnamese
        DH_LANGUAGE_LITHUANIAN,						// Lithuanian
        DH_LANGUAGE_FILIPINO,						// Filipino
        DH_LANGUAGE_ARABIC,							// Arabic
        DH_LANGUAGE_CATALAN,						// Catalan
        DH_LANGUAGE_LATVIAN,						// Latvian
        DH_LANGUAGE_THAI,							// Thai
        DH_LANGUAGE_HEBREW,							// Hebrew
        DH_LANGUAGE_Bosnian,						// Bosnian
    } DH_LANGUAGE_TYPE;
    
    // Upgrade type
    typedef enum __EM_UPGRADE_TYPE
    {
        DH_UPGRADE_BIOS_TYPE = 1,					// BIOS  upgrade
        DH_UPGRADE_WEB_TYPE,						// WEB upgrade
        DH_UPGRADE_BOOT_YPE,						// BOOT upgrade
        DH_UPGRADE_CHARACTER_TYPE,					// Chinese character library
        DH_UPGRADE_LOGO_TYPE,						// LOGO
        DH_UPGRADE_EXE_TYPE,						// EXE such as player
        DH_UPGRADE_DEVCONSTINFO_TYPE,               // upgrade device information
        DH_UPGRADE_PERIPHERAL_TYPE,                 // Peripheral access from (such as car 287 chip)
        DH_UPGRADE_GEOINFO_TYPE,                    // Geographic information positioning chip
        DH_UPGRADE_MENU,                            // Menu (equipment operation interface of the picture)
        DH_UPGRADE_ROUTE,                           // Line files (such as bus lines)
        DH_UPGRADE_ROUTE_STATE_AUTO,                // Stops the audio (with line stops audio)
        DH_UPGRADE_SCREEN,                          // Scheduling screen (e.g., bus operation panel)
    } EM_UPGRADE_TYPE;
    
    // Record related (schedule,motion detection,alarm)
    typedef enum __REC_TYPE
    {
        DH_REC_TYPE_TIM = 0,
        DH_REC_TYPE_MTD,
        DH_REC_TYPE_ALM,
        DH_REC_TYPE_NUM,
    } REC_TYPE;
    
    // network type
    typedef enum __GPRSCDMA_NETWORK_TYPE
    {
        DH_TYPE_AUTOSEL = 0,						// Automatic selection
        DH_TYPE_TD_SCDMA,							// TD-SCDMA network
        DH_TYPE_WCDMA,								// WCDMA network
        DH_TYPE_CDMA_1x,							// CDMA 1.x network
        DH_TYPE_EDGE,								// GPRS network
        DH_TYPE_EVDO,								// EVDO network
        DH_TYPE_WIFI,
    } EM_GPRSCDMA_NETWORK_TYPE;
    
    // Interface type,responding to the interface CLIENT_SetSubconnCallBack
    typedef enum __EM_INTERFACE_TYPE
    {
        DH_INTERFACE_OTHER = 0x00000000,			// Unknown interface
        DH_INTERFACE_REALPLAY,						// Realtime monitoring interface
        DH_INTERFACE_PREVIEW,						// Realtime multiple-window preview
        DH_INTERFACE_PLAYBACK,						// Playback interface
        DH_INTERFACE_DOWNLOAD,						// Download interface
        DH_INTERFACE_REALLOADPIC,                   // Download picture interface
    } EM_INTERFACE_TYPE;
    
    // realplay disconnect event
    typedef enum _EM_REALPLAY_DISCONNECT_EVENT_TYPE
    {
        DISCONNECT_EVENT_REAVE,                     // resources is taked by advanced user
        DISCONNECT_EVENT_NETFORBID,                 // forbidden
        DISCONNECT_EVENT_SUBCONNECT,                // sublink disconnect
    }EM_REALPLAY_DISCONNECT_EVENT_TYPE;
    
    // event file's tag type
    typedef enum __EM_EVENT_FILETAG
    {
        DH_ATMBEFOREPASTE = 1,                      // Before ATM Paste
        DH_ATMAFTERPASTE,                           // After ATM Paste
    }EM_EVENT_FILETAG;
    
    // IPC type
    typedef enum __EM_IPC_TYPE
    {
        DH_IPC_PRIVATE,                             // private
        DH_IPC_AEBELL,                              // AEBell
        DH_IPC_PANASONIC,                           // panasonic
        DH_IPC_SONY,                                // sony
        DH_IPC_DYNACOLOR,                           // Dynacolor
        DH_IPC_TCWS = 5 ,                           // TCWS
        DH_IPC_SAMSUNG,                             // Samsung
        DH_IPC_YOKO,                                // YOKO
        DH_IPC_AXIS,                                // AXIS
        DH_IPC_SANYO,							    // sanyo
        DH_IPC_BOSH = 10,							// Bosch
        DH_IPC_PECLO,								// PECLO
        DH_IPC_PROVIDEO,							// Provideo
        DH_IPC_ACTI,								// ACTi
        DH_IPC_VIVOTEK,								// Vivotek
        DH_IPC_ARECONT = 15,                        // Arecont
        DH_IPC_PRIVATEEH,			                // PrivateEH
        DH_IPC_IMATEK,					            // IMatek
        DH_IPC_SHANY,                               // Shany
        DH_IPC_VIDEOTREC,                           // videorec
        DH_IPC_URA = 20,                            // Ura
        DH_IPC_BITICINO,                            // Bticino
        DH_IPC_ONVIF,                               // Onvif protocol type
        DH_IPC_SHEPHERD,                            // Shepherd
        DH_IPC_YAAN,                                // Yaan
        DH_IPC_AIRPOINT = 25,                       // Airpoint
        DH_IPC_TYCO,                                // TYCO
        DH_IPC_XUNMEI,								// Xunmei
        DH_IPC_HIKVISION,							// HIKVISION
        DH_IPC_LG,                                  // LG
        DH_IPC_AOQIMAN = 30,                        // Aoqiman
        DH_IPC_BAOKANG,                             // baokang
        DH_IPC_WATCHNET,                            // Watchnet
        DH_IPC_XVISION,                             // Xvision
        DH_IPC_FUSITSU,                             // Fisitu
        DH_IPC_CANON = 35,							// Canon
        DH_IPC_GE,								    // GE
        DH_IPC_Basler,								// Basler
        DH_IPC_Patro,								// Patro
        DH_IPC_CPKNC,								// CPPLUS K series
        DH_IPC_CPRNC = 40,							// CPPLUS R series
        DH_IPC_CPUNC,								// CPPLUS U series
        DH_IPC_CPPLUS,								// cpplus oem
        DH_IPC_XunmeiS,								// XunmeiS
        DH_IPC_GDDW,									// guangdong power grid
        DH_IPC_PSIA = 45,                               // PSIA
        DH_IPC_GB2818,                                  // GB2818
        DH_IPC_GDYX,                                    // GDYX
        DH_IPC_OTHER,                                   // custom
        DH_IPC_CPUNR,									// CPPLUS NVR
        DH_IPC_CPUAR = 50,								// CPPLUS DVR
        DH_IPC_AIRLIVE,                                 // Airlive
        DH_IPC_NPE,										// NPE
        DH_IPC_AXVIEW,									// AXVIEW
        DH_IPC_DFWL,                                    // DFWL
        DH_IPC_HYUNDAI = 56,							// HYUNDAI DVR
        DH_IPC_APHD,									// APHD
        DH_IPC_WELLTRANS ,								// WELLTRANS
        DH_IPC_CDJF,									// CDJF
        DH_IPC_JVC = 60,						    	// JVC
        DH_IPC_INFINOVA,								// INFINOVA
        DH_IPC_ADT,										// ADT
        DH_IPC_SIVIDI,									// SIVIDI
        DH_IPC_CPUNP,									// CPPLUS PTZ
        DH_IPC_HX = 65,									// HX
        DH_IPC_TJGS,                                    // TJGS
        DH_IPC_MULTICAST = 79,                          // Multicast
        DH_IPC_RVI = 84,								// RVi
    }EM_IPC_TYPE;
    
    // H264 profile rank
    typedef enum __EM_H264_PROFILE_RANK
    {
        DH_PROFILE_BASELINE = 1,                 // offer I/P frame, only support progressive and CAVLC
        DH_PROFILE_MAIN,                         // offer I/P/B frame, support progressiv and interlaced,offer CAVLC and CABAC
        DH_PROFILE_EXTENDED,                     // offer I/P/B/SP/SI frame,only support progressive and CAVLC
        DH_PROFILE_HIGH,                         // FRExt,base on Main_Profile:8x8 intra prediction, custom quant, lossless video coding, more yuv
    }EM_H264_PROFILE_RANK;
    
    typedef enum __EM_DISK_TYPE
    {
        DH_DISK_READ_WRITE,                          // read write disk
        DH_DISK_READ_ONLY,                       // read only disk
        DH_DISK_BACKUP,	                         // back up disk or media disk
        DH_DISK_REDUNDANT,                       // redundancy disk
        DH_DISK_SNAPSHOT,	                     // snapshot disk
    }EM_DISK_TYPE;
    
    // stream encrypt algorithm work mode
    typedef enum  __EM_ENCRYPT_ALOG_WORKMODE
    {
        ENCRYPT_ALOG_WORKMODE_ECB,				// ECB mode
        ENCRYPT_ALOG_WORKMODE_CBC,				// CBC mode
        ENCRYPT_ALOG_WORKMODE_CFB,				// CFB mode
        ENCRYPT_ALOG_WORKMODE_OFB,				// OFB mode
    }EM_ENCRYPT_ALOG_WORKMODE;
    
    typedef enum __EM_MOBILE_PPP_STATE
    {
        MOBILE_PPP_UP = 0,							// connect has being build
        MOBILE_PPP_DOWN,							// ppp connect has being cut
        MOBILE_PPP_CONNECTING,						// be connecting
        MOBILE_PPP_CLOSEING,						// be closing PPP connect
    } EM_MOBILE_PPP_STATE;
    
    typedef enum __EM_3GMOBILE_STATE
    {
        MOBILE_MODULE_OFF,							// means 3g net card mod is closed
        MOBILE_MODULE_STARTING,						// means 3g net card mod is starting
        MOBILE_MODULE_WORKING,						// means 3g net card mod is working
    }EM_3GMOBILE_STATE;
    
    typedef enum tagEM_LOGIN_SPAC_CAP_TYPE
    {
        EM_LOGIN_SPEC_CAP_TCP               = 0,    // TCP login, default
        EM_LOGIN_SPEC_CAP_ANY               = 1,    // No criteria login
        EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2,    // auto sign up login
        EM_LOGIN_SPEC_CAP_MULTICAST         = 3,    // multicast login, default
        EM_LOGIN_SPEC_CAP_UDP               = 4,    // UDP method login
        EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6,    // only main connection login
        EM_LOGIN_SPEC_CAP_SSL               = 7,    // SSL encryption login
        EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9,    // login IVS box remote device
        EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10,   // login device do not config
        EM_LOGIN_SPEC_CAP_U_LOGIN           = 11,   // USB key device login
        EM_LOGIN_SPEC_CAP_LDAP              = 12,   // LDAP login
        EM_LOGIN_SPEC_CAP_AD                = 13,   // AD?¡§ActiveDirectory?? login
        EM_LOGIN_SPEC_CAP_RADIUS            = 14,   // Radius  login
        EM_LOGIN_SPEC_CAP_SOCKET_5          = 15,   // Socks5 login
        EM_LOGIN_SPEC_CAP_CLOUD             = 16,   // cloud login
        EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17,   // dual authentication loin
        EM_LOGIN_SPEC_CAP_TS                = 18,   // TS stream client login
        EM_LOGIN_SPEC_CAP_P2P               = 19,   // web private login
        EM_LOGIN_SPEC_CAP_MOBILE            = 20,   // mobile client login
        EM_LOGIN_SPEC_CAP_INVALID                   // invalid login
        
        
    }EM_LOGIN_SPAC_CAP_TYPE;
    
    /////////////////////////////////Monitor related/////////////////////////////////
    
    // Preview type.Corresponding to CLIENT_RealPlayEx
    typedef enum _RealPlayType
    {
        DH_RType_Realplay = 0,						// Real-time preview
        DH_RType_Multiplay,							// Multiple-channel preview
        DH_RType_Realplay_0,						// Real-time monitor-main stream. It is the same as DH_RType_Realplay
        DH_RType_Realplay_1,						// 1 Real-time monitor---extra stream 1
        DH_RType_Realplay_2,						// 2Real-time monitor-- extra stream 2
        DH_RType_Realplay_3,						// 3 Real-time monitor -- extra stream 3
        DH_RType_Multiplay_1,						// Multiple-channel preview-- 1-window
        DH_RType_Multiplay_4,						// Multiple-channel preview--4-window
        DH_RType_Multiplay_8,						// Multiple-channel preview--8-window
        DH_RType_Multiplay_9,						// Multiple-channel preview--9-window
        DH_RType_Multiplay_16,						// Multiple-channel preview--16-window
        DH_RType_Multiplay_6,						// Multiple-channel preview--6-window
        DH_RType_Multiplay_12,						// Multiple-channel preview--12-window
        DH_RType_Multiplay_25,                      // Multi-window tour??25 windows
        DH_RType_Multiplay_36,                      // Multi-window preview??36 windows
    } DH_RealPlayType;
    
    /////////////////////////////////About PTZ/////////////////////////////////
    
    // General PTZ control command
    typedef enum _PTZ_ControlType
    {
        DH_PTZ_UP_CONTROL = 0,						// Up
        DH_PTZ_DOWN_CONTROL,						// Down
        DH_PTZ_LEFT_CONTROL,						// Left
        DH_PTZ_RIGHT_CONTROL,						// Right
        DH_PTZ_ZOOM_ADD_CONTROL,					// +Zoom in
        DH_PTZ_ZOOM_DEC_CONTROL,					// -Zoom out
        DH_PTZ_FOCUS_ADD_CONTROL,					// +Zoom in
        DH_PTZ_FOCUS_DEC_CONTROL,					// -Zoom out
        DH_PTZ_APERTURE_ADD_CONTROL,				// + Aperture
        DH_PTZ_APERTURE_DEC_CONTROL,				// -Aperture
        DH_PTZ_POINT_MOVE_CONTROL,					// Go to preset
        DH_PTZ_POINT_SET_CONTROL,					// Set
        DH_PTZ_POINT_DEL_CONTROL,					// Delete
        DH_PTZ_POINT_LOOP_CONTROL,					// Tour
        DH_PTZ_LAMP_CONTROL							// Light and wiper
    } DH_PTZ_ControlType;
    
    // PTZ control extensive command
    typedef enum _EXTPTZ_ControlType
    {
        DH_EXTPTZ_LEFTTOP = 0x20,					// Upper left
        DH_EXTPTZ_RIGHTTOP,							// Upper right
        DH_EXTPTZ_LEFTDOWN,							// Down left
        DH_EXTPTZ_RIGHTDOWN,						// Down right
        DH_EXTPTZ_ADDTOLOOP,						// Add preset to tour		tour	 preset value
        DH_EXTPTZ_DELFROMLOOP,						// Delete preset in tour	tour	 preset value
        DH_EXTPTZ_CLOSELOOP,						// Delete tour				tour
        DH_EXTPTZ_STARTPANCRUISE,					// Begin pan rotation
        DH_EXTPTZ_STOPPANCRUISE,					// Stop pan rotation
        DH_EXTPTZ_SETLEFTBORDER,					// Set left limit
        DH_EXTPTZ_SETRIGHTBORDER,					// Set right limit
        DH_EXTPTZ_STARTLINESCAN,					// Begin scanning
        DH_EXTPTZ_CLOSELINESCAN,					// Stop scanning
        DH_EXTPTZ_SETMODESTART,						// Start mode	mode line
        DH_EXTPTZ_SETMODESTOP,						// Stop mode	mode line
        DH_EXTPTZ_RUNMODE,							// Enable mode	Mode line
        DH_EXTPTZ_STOPMODE,							// Disable mode	Mode line
        DH_EXTPTZ_DELETEMODE,						// Delete mode	Mode line
        DH_EXTPTZ_REVERSECOMM,						// Flip
        DH_EXTPTZ_FASTGOTO,							// 3D position	X address(8192)	Y address(8192)	zoom(4)
        DH_EXTPTZ_AUXIOPEN,							// auxiliary open	Auxiliary point
        DH_EXTPTZ_AUXICLOSE,						// Auxiliary close	Auxiliary point
        DH_EXTPTZ_OPENMENU = 0x36,					// Open dome menu
        DH_EXTPTZ_CLOSEMENU,						// Close menu
        DH_EXTPTZ_MENUOK,							// Confirm menu
        DH_EXTPTZ_MENUCANCEL,						// Cancel menu
        DH_EXTPTZ_MENUUP,							// menu up
        DH_EXTPTZ_MENUDOWN,							// menu down
        DH_EXTPTZ_MENULEFT,							// menu left
        DH_EXTPTZ_MENURIGHT,						// Menu right
        DH_EXTPTZ_ALARMHANDLE = 0x40,				// Alarm activate PTZ parm1:Alarm input channel;parm2:Alarm activation type  1-preset 2-scan 3-tour;parm 3:activation value,such as preset value.
        DH_EXTPTZ_MATRIXSWITCH = 0x41,				// Matrix switch parm1:monitor number(video output number);parm2:video input number;parm3:matrix number
        DH_EXTPTZ_LIGHTCONTROL,						// Light controller
        DH_EXTPTZ_EXACTGOTO,						// 3D accurately positioning parm1:Pan degree(0~3600); parm2: tilt coordinates(0~900); parm3:zoom(1~128)
        DH_EXTPTZ_RESETZERO,                        // Reset  3D positioning as zero
        DH_EXTPTZ_MOVE_ABSOLUTELY,                  // Absolute motion control commands??param4 corresponding struct PTZ_CONTROL_ABSOLUTELY
        DH_EXTPTZ_MOVE_CONTINUOUSLY,                // Continuous motion control commands??param4 corresponding struct PTZ_CONTROL_CONTINUOUSLY
        DH_EXTPTZ_GOTOPRESET,                       // PTZ control command, at a certain speed to preset locus??parm4 corresponding struct PTZ_CONTROL_GOTOPRESET
        DH_EXTPTZ_SET_VIEW_RANGE = 0x49,           	// Set to horizon(param4 corresponding struct PTZ_VIEW_RANGE_INFO)
        DH_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A,         	// Absolute focus(param4 corresponding struct PTZ_FOCUS_ABSOLUTELY)
        DH_EXTPTZ_HORSECTORSCAN = 0x4B,             // Level fan sweep(param4 corresponding PTZ_CONTROL_SECTORSCAN,param1??param2??param3 is invalid)
        DH_EXTPTZ_VERSECTORSCAN = 0x4C,             // Vertical sweep fan(param4correspondingPTZ_CONTROL_SECTORSCAN,param1??param2??param3 is invalid)
        DH_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D,         // Set absolute focus, focus on value, param1 for focal length, range: [0255], param2 as the focus, scope: [0255], param3, param4 is invalid
        DH_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E,          // Control fish eye PTZ??param4corresponding to structure PTZ_CONTROL_SET_FISHEYE_EPTZ
        
        DH_EXTPTZ_UP_TELE = 0x70,					// Up + TELE param1=speed (1-8)
        DH_EXTPTZ_DOWN_TELE,						// Down + TELE
        DH_EXTPTZ_LEFT_TELE,						// Left + TELE
        DH_EXTPTZ_RIGHT_TELE,						// Right + TELE
        DH_EXTPTZ_LEFTUP_TELE,						// Upper left + TELE
        DH_EXTPTZ_LEFTDOWN_TELE,					// Down left + TELE
        DH_EXTPTZ_TIGHTUP_TELE,						// Upper right + TELE
        DH_EXTPTZ_RIGHTDOWN_TELE,					// Down right + TELE
        DH_EXTPTZ_UP_WIDE,							// Up + WIDE param1=speed (1-8)
        DH_EXTPTZ_DOWN_WIDE,						// Down + WIDE
        DH_EXTPTZ_LEFT_WIDE,						// Left + WIDE
        DH_EXTPTZ_RIGHT_WIDE,						// Right + WIDE
        DH_EXTPTZ_LEFTUP_WIDE,						// Upper left + WIDE
        DH_EXTPTZ_LEFTDOWN_WIDE,					// Down left+ WIDE
        DH_EXTPTZ_TIGHTUP_WIDE,						// Upper right + WIDE
        DH_EXTPTZ_RIGHTDOWN_WIDE,					// Down right + WIDE
        DH_EXTPTZ_TOTAL,							// max command value
    } DH_EXTPTZ_ControlType;
    
    // Fish eye electronic PTZ control command
    typedef enum tagNET_FISHEYE_EPTZ_CMD
    {
        NET_FISHEYE_EPTZ_CMD_UNKOWN,          // unknown type
        NET_FISHEYE_EPTZ_CMD_ZOOMIN,          // Zoom in ??dwParam1 means step length, range 1??8
        NET_FISHEYE_EPTZ_CMD_ZOOMOUT,          // Zoom out??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_UP,            // Move up??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_DOWN,           // Move down??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_LEFT,           // Move left??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_RIGHT,           // Move right??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_ROTATECLOCK,        // Auto clockwise rotation ??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_ROTATEANTICLOCK,      // Auto counterclockwise rotation??dwParam1 means step length ?? range 1??8
        NET_FISHEYE_EPTZ_CMD_STOP,           // End auto rotation
        NET_FISHEYE_EPTZ_CMD_TAPVIEW,          // Display specific location, instant view??dwParam1 means eptz?¡§E-PTZ ?? focus coordinate??as The focus, the rectified image was in the abscissa, take the value does not exceed the rectified output image width
        // dwParam2 means eptz?¡§E-PTZ ??The focus of the cordinate, the rectified image was focus on the ordinate, take the value does not exceed the rectified output image
        NET_FISHEYE_EPTZ_CMD_SHOEREGION,        // Panel Zoom in ??wParam1 means selected rectangle center horizontal corrdinate??
        // dwParam2 means selected rectangle center horizontal coordinate??dwParam3 means selected rectangle width
        // dwParam4 means selected rectangle height
    }NET_FISHEYE_EPTZ_CMD;
    
    // Fish eye correction mode
    typedef enum tagNET_CALIBRATE_MODE
    {
        NET_FISHEYE_CALIBRATE_MODE_UNKOWN,           // unknown mode
        NET_FISHEYE_CALIBRATE_MODE_ORIGIAL,           // Original image mode
        NET_FISHEYE_CALIBRATE_MODE_CONFIG,           // config mode
        NET_FISHEYE_CALIBRATE_MODE_PANORAMA,          // global mode
        NET_FISHEYE_CALIBRATE_MODE_DOUBLEPANORAMA,       // dual global mode
        NET_FISHEYE_CALIBRATE_MODE_ORIGIALPLUSTHREEEPTZREGION, // 1+3 mode ?¡§one original Fish eye plus 3 EPtz images??
        NET_FISHEYE_CALIBRATE_MODE_SINGLE,           // Single image EPtz mode ?¡§only one EPtz video??
        NET_FISHEYE_CALIBRATE_MODE_FOUREPTZREGION,       // 4 image mode ?¡§4??EPtz control image??
        NET_FISHEYE_CALIBRATE_MODE_NORMAL,           // normal mode
    }NET_FISHEYE_CALIBRATE_MODE;
    
    typedef enum tagNET_FISHEYE_TYPE
    {
        NET_FISHEYE_UNKOWN =0  ,        // unknown
        NET_FISHEYE_CHIP    ,        //only support device port Fish eye correction
        NET_FISHEYE_PLUGIN   ,        //only support control Fish eye correction
        NET_FISHEYE_CHIP_PLUGIN ,        //support both
    }NET_FISHEYE_TYPE;
    
    // Fish eye installation mode
    typedef enum tagNET_FISHEYE_MOUNT_MODE
    {
        NET_FISHEYE_MOUNT_MODE_UNKOWN,             // unknown mode
        NET_FISHEYE_MOUNT_MODE_CEIL,              // ceiling mode
        NET_FISHEYE_MOUNT_MODE_WALL,              // wall mount mode
        NET_FISHEYE_MOUNT_MODE_FLOOR,              // ground mode
    }NET_FISHEYE_MOUNT_MODE;
    /////////////////////////////////About Log /////////////////////////////////
    
    // Log search type
    typedef enum _DH_LOG_QUERY_TYPE
    {
        DHLOG_ALL = 0,								// All logs
        DHLOG_SYSTEM,								// System logs
        DHLOG_CONFIG,								// Configuration logs
        DHLOG_STORAGE,								// Storage logs
        DHLOG_ALARM,								// Alarm logs
        DHLOG_RECORD,								// Record related
        DHLOG_ACCOUNT,								// Account related
        DHLOG_CLEAR,								// Clear log
        DHLOG_PLAYBACK,								// Playback related
        DHLOG_MANAGER                               // Concerning the front-end management and running
    } DH_LOG_QUERY_TYPE;
    
    // Log Type
    typedef enum _DH_LOG_TYPE
    {
        DH_LOG_REBOOT = 0x0000,						// Device reboot
        DH_LOG_SHUT,								// Shut down device
        DH_LOG_REPORTSTOP,
        DH_LOG_REPORTSTART,
        DH_LOG_UPGRADE = 0x0004,					// Device Upgrade
        DH_LOG_SYSTIME_UPDATE = 0x0005,             // system time update
        DH_LOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update
        DH_LOG_AUDIO_TALKBACK,	  					// Voice intercom, true representative open, false on behalf of the closed
        DH_LOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed
        DH_LOG_NET_TIMING,                          // Net sync
        DH_LOG_CONFSAVE = 0x0100,					// Save configuration
        DH_LOG_CONFLOAD,							// Read configuration
        DH_LOG_FSERROR = 0x0200,					// File system error
        DH_LOG_HDD_WERR,							// HDD write error
        DH_LOG_HDD_RERR,							// HDD read error
        DH_LOG_HDD_TYPE,							// Set HDD type
        DH_LOG_HDD_FORMAT,							// Format HDD
        DH_LOG_HDD_NOSPACE,							// Current working HDD space is not sufficient
        DH_LOG_HDD_TYPE_RW,							// Set HDD type as read-write
        DH_LOG_HDD_TYPE_RO,							// Set HDD type as read-only
        DH_LOG_HDD_TYPE_RE,							// Set HDD type as redundant
        DH_LOG_HDD_TYPE_SS,							// Set HDD type as snapshot
        DH_LOG_HDD_NONE,							// No HDD
        DH_LOG_HDD_NOWORKHDD,						// No work HDD
        DH_LOG_HDD_TYPE_BK,							// Set HDD type to backup HDD
        DH_LOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subarea
        DH_LOG_HDD_START_INFO = 0x20e ,             // note the boot-strap's hard disk info
        DH_LOG_HDD_WORKING_DISK,                    // note the disk number after the disk change
        DH_LOG_HDD_OTHER_ERROR,                     // note other errors of disk
        DH_LOG_HDD_SLIGHT_ERR,						// there has some little errors on disk
        DH_LOG_HDD_SERIOUS_ERR,                     // there has some serious errors on disk
        DH_LOG_HDD_NOSPACE_END,                     // the end of the alarm that current disk has no space left
        DH_LOG_HDD_TYPE_RAID_CONTROL,               // Raid control
        DH_LOG_HDD_TEMPERATURE_HIGH,				// excess temperature
        DH_LOG_HDD_TEMPERATURE_LOW,					//  lower die temperature
        DH_LOG_HDD_ESATA_REMOVE,					// remove eSATA
        DH_LOG_ALM_IN = 0x0300,						// External alarm begin
        DH_LOG_NETALM_IN,							// Network alarm input
        DH_LOG_ALM_END = 0x0302,					// External input alarm stop
        DH_LOG_LOSS_IN,								// Video loss alarm begin
        DH_LOG_LOSS_END,							// Video loss alarm stop
        DH_LOG_MOTION_IN,							// Motion detection alarm begin
        DH_LOG_MOTION_END,							// Motion detection alarm stop
        DH_LOG_ALM_BOSHI,							// Annunciator alarm input
        DH_LOG_NET_ABORT = 0x0308,					// Network disconnected
        DH_LOG_NET_ABORT_RESUME,					// Network connection restore
        DH_LOG_CODER_BREAKDOWN,						// Encoder error
        DH_LOG_CODER_BREAKDOWN_RESUME,				// Encoder error restore
        DH_LOG_BLIND_IN,							// Camera masking
        DH_LOG_BLIND_END,							// Restore camera masking
        DH_LOG_ALM_TEMP_HIGH,						// High temperature
        DH_LOG_ALM_VOLTAGE_LOW,						// Low voltage
        DH_LOG_ALM_BATTERY_LOW,						// Battery capacity is not sufficient
        DH_LOG_ALM_ACC_BREAK,						// ACC power off
        DH_LOG_ALM_ACC_RES,
        DH_LOG_GPS_SIGNAL_LOST,						// GPS signal lost
        DH_LOG_GPS_SIGNAL_RESUME,					// GPS signal resume
        DH_LOG_3G_SIGNAL_LOST,						// 3G signal lost
        DH_LOG_3G_SIGNAL_RESUME,					// 3G signal resume
        DH_LOG_ALM_IPC_IN,							// IPC external alarms
        DH_LOG_ALM_IPC_END,							// IPC external alarms recovery
        DH_LOG_ALM_DIS_IN,							//Broken network alarm
        DH_LOG_ALM_DIS_END,							// Broken network alarm recovery
        DH_LOG_INFRAREDALM_IN = 0x03a0,				// Wireless alarm begin
        DH_LOG_INFRAREDALM_END,						// Wireless alarm end
        DH_LOG_IPCONFLICT,							// IP conflict
        DH_LOG_IPCONFLICT_RESUME,					// IP restore
        DH_LOG_SDPLUG_IN,							// SD Card insert
        DH_LOG_SDPLUG_OUT,							// SD Card Pull-out
        DH_LOG_NET_PORT_BIND_FAILED,				// Failed to bind port
        DH_LOG_HDD_BEEP_RESET,                      // Hard disk error beep reset
        DH_LOG_MAC_CONFLICT,                        // MAC conflict
        DH_LOG_MAC_CONFLICT_RESUME,                 // MAC conflict resume
        DH_LOG_ALARM_OUT,							// alarm out
        DH_LOG_ALM_RAID_STAT_EVENT,                 // RAID state event
        DH_LOG_ABLAZE_ON,				            // Fire alarm, smoker or high temperature
        DH_LOG_ABLAZE_OFF,			                // Fire alarm reset
        DH_LOG_INTELLI_ALARM_PLUSE,					// Intelligence pulse alarm
        DH_LOG_INTELLI_ALARM_IN,					// Intelligence alarm start
        DH_LOG_INTELLI_ALARM_END,					// Intelligence alarm end
        DH_LOG_3G_SIGNAL_SCAN,						// 3G signal scan
        DH_LOG_GPS_SIGNAL_SCAN,						// GPS signal scan
        DH_LOG_AUTOMATIC_RECORD = 0x0400,			// Auto record
        DH_LOG_MANUAL_RECORD = 0x0401,				// Manual record
        DH_LOG_CLOSED_RECORD,						// Stop record
        DH_LOG_LOGIN = 0x0500,						// Log in
        DH_LOG_LOGOUT,								// Log off
        DH_LOG_ADD_USER,							// Add user
        DH_LOG_DELETE_USER,							// Delete user
        DH_LOG_MODIFY_USER,							// Modify user
        DH_LOG_ADD_GROUP,							// Add user group
        DH_LOG_DELETE_GROUP,						// Delete user group
        DH_LOG_MODIFY_GROUP,						// Modify user group
        DH_LOG_NET_LOGIN = 0x0508,					// Network Login
        DH_LOG_MODIFY_PASSWORD,						// Modify password
        DH_LOG_CLEAR = 0x0600,						// Clear log
        DH_LOG_SEARCHLOG,							// Search log
        DH_LOG_SEARCH = 0x0700,						// Search record
        DH_LOG_DOWNLOAD,							// Record download
        DH_LOG_PLAYBACK,							// Record playback
        DH_LOG_BACKUP,								// Backup recorded file
        DH_LOG_BACKUPERROR,							// Failed to backup recorded file
        DH_LOG_BACK_UPRT,							// Real-time backup, that is, copy CD
        DH_LOG_BACKUPCLONE,							//CD copy
        DH_LOG_DISK_CHANGED,						// Manual changed
        DH_LOG_IMAGEPLAYBACK,						// Image playback
        DH_LOG_LOCKFILE,							// Lock the video
        DH_LOG_UNLOCKFILE,							// Unlock the video
        DH_LOG_ATMPOS,								// Add log superposition of ATM card number
        DH_PLAY_PAUSE,								// Pause
        DH_PLAY_START,								// Start
        LOG_PLAY_STOP,								// Stop
        LOG_PLAY_BACK,								// Back
        LOG_PLAY_FAST,								// Fast
        LOG_PLAY_SLOW,								// Slow
        LOG_SMART_SEARCH,							// Search
        LOG_RECORD_SNAP,							// Snap
        LOG_ADD_TAG,								// Add tag
        LOG_DEL_TAG,								// Delete tag
        LOG_USB_IN,									// USB connected
        LOG_USB_OUT,								// USB disconnected
        LOG_BACKUP_FILE,							// Backup file
        LOG_BACKUP_LOG,								// Backup log
        LOG_BACKUP_CONFIG,							// Backup config
        
        DH_LOG_TIME_UPDATE  = 0x0800,               // Time update
        DH_LOG_REMOTE_STATE = 0x0850,               // remote diary
        DH_LOG_USER_DEFINE = 0x0900,
        DH_LOG_TYPE_NR = 10,
    } DH_LOG_TYPE;
    
    // Extensive log type. Correponding to CLIENT_QueryLogEx, Condition (int nType = 1; parameter reserved = &nType)
    typedef enum _DH_NEWLOG_TYPE
    {
        DH_NEWLOG_REBOOT = 0x0000,					// Device reboot
        DH_NEWLOG_SHUT,								// Shut down device
        DH_NEWLOG_REPORTSTOP,
        DH_NEWLOG_REPORTSTART,
        DH_NEWLOG_UPGRADE = 0x0004,					// Device upgrade
        DH_NEWLOG_SYSTIME_UPDATE = 0x0005,          // system time update
        DH_NEWLOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update
        
        DH_NEWLOG_AUDIO_TALKBACK,	  				// Voice intercom, true representative open, false on behalf of the closed
        DH_NEWLOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed
        DH_NEWLOG_NET_TIMING,						// NTP
        
        DH_NEWLOG_CONFSAVE = 0x0100,				// Save configuration
        DH_NEWLOG_CONFLOAD,							// Read configuration
        DH_NEWLOG_FSERROR = 0x0200,					// File system error
        DH_NEWLOG_HDD_WERR,							// HDD write error
        DH_NEWLOG_HDD_RERR,							// HDD read error
        DH_NEWLOG_HDD_TYPE,							// Set HDD type
        DH_NEWLOG_HDD_FORMAT,						// Format HDD
        DH_NEWLOG_HDD_NOSPACE,						// Current working HDD space is not sufficient
        DH_NEWLOG_HDD_TYPE_RW,						// Set HDD type as read-write
        DH_NEWLOG_HDD_TYPE_RO,						// Set HDD type as read-only
        DH_NEWLOG_HDD_TYPE_RE,						// Set HDD type as redundant
        DH_NEWLOG_HDD_TYPE_SS,						// Set HDD type as snapshot
        DH_NEWLOG_HDD_NONE,							// No HDD
        DH_NEWLOG_HDD_NOWORKHDD,					// No work HDD
        DH_NEWLOG_HDD_TYPE_BK,						// Set HDD type to backup HDD
        DH_NEWLOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subareas
        DH_NEWLOG_HDD_START_INFO = 0x20e ,          // note the boot-strap's hard disk info
        DH_NEWLOG_HDD_WORKING_DISK,                 // note the disk number after the disk change
        DH_NEWLOG_HDD_OTHER_ERROR,                  // note other errors of disk
        DH_NEWLOG_HDD_SLIGHT_ERR,					// there has some little errors on disk
        DH_NEWLOG_HDD_SERIOUS_ERR,                  // there has some serious errors on disk
        DH_NEWLOG_HDD_NOSPACE_END,                  // the end of the alarm that current disk has no space left
        
        DH_NEWLOG_HDD_TYPE_RAID_CONTROL,            // Raid operation
        DH_NEWLOG_HDD_TEMPERATURE_HIGH,				// excess temperature
        DH_NEWLOG_HDD_TEMPERATURE_LOW,				// lower die temperature
        DH_NEWLOG_HDD_ESATA_REMOVE,					// remove eSATA
        
        DH_NEWLOG_ALM_IN = 0x0300,					// External alarm begin
        DH_NEWLOG_NETALM_IN,						// Network alarm input
        DH_NEWLOG_ALM_END = 0x0302,					// External input alarm stop
        DH_NEWLOG_LOSS_IN,							// Video loss alarm begin
        DH_NEWLOG_LOSS_END,							// Video loss alarm stop
        DH_NEWLOG_MOTION_IN,						// Motion detection alarm begin
        DH_NEWLOG_MOTION_END,						// Motion detection alarm stop
        DH_NEWLOG_ALM_BOSHI,						// Annunciator alarm input
        DH_NEWLOG_NET_ABORT = 0x0308,				// Network disconnected
        DH_NEWLOG_NET_ABORT_RESUME,					// Network connection restore
        DH_NEWLOG_CODER_BREAKDOWN,					// Encoder error
        DH_NEWLOG_CODER_BREAKDOWN_RESUME,			// Encoder error restore
        DH_NEWLOG_BLIND_IN,							// Camera masking
        DH_NEWLOG_BLIND_END,						// Restore camera masking
        DH_NEWLOG_ALM_TEMP_HIGH,					// High temperature
        DH_NEWLOG_ALM_VOLTAGE_LOW,					// Low voltage
        DH_NEWLOG_ALM_BATTERY_LOW,					// Battery capacity is not sufficient
        DH_NEWLOG_ALM_ACC_BREAK,					// ACC power off
        DH_NEWLOG_ALM_ACC_RES,
        DH_NEWLOG_GPS_SIGNAL_LOST,					// GPS signal lost
        DH_NEWLOG_GPS_SIGNAL_RESUME,				// GPS signal resume
        DH_NEWLOG_3G_SIGNAL_LOST,					// 3G signal lost
        DH_NEWLOG_3G_SIGNAL_RESUME,					// 3G signal resume
        
        DH_NEWLOG_ALM_IPC_IN,						// IPC external alarms
        DH_NEWLOG_ALM_IPC_END,						// IPC external alarms recovery
        DH_NEWLOG_ALM_DIS_IN,						//Broken network alarm
        DH_NEWLOG_ALM_DIS_END,						// Broken network alarm recovery
        
        DH_NEWLOG_INFRAREDALM_IN = 0x03a0,			// Wireless alarm begin
        DH_NEWLOG_INFRAREDALM_END,					// Wireless alarm end
        DH_NEWLOG_IPCONFLICT,						// IP conflict
        DH_NEWLOG_IPCONFLICT_RESUME,				// IP restore
        DH_NEWLOG_SDPLUG_IN,						// SD Card insert
        DH_NEWLOG_SDPLUG_OUT,						// SD Card Pull-out
        DH_NEWLOG_NET_PORT_BIND_FAILED,				// Failed to bind port
        DH_NEWLOG_HDD_BEEP_RESET,                   // Hard disk error beep reset
        DH_NEWLOG_MAC_CONFLICT,                     // MAC conflict
        DH_NEWLOG_MAC_CONFLICT_RESUME,              // MAC conflict resume
        DH_NEWLOG_ALARM_OUT,						// alarm of output state
        DH_NEWLOG_ALM_RAID_STAT_EVENT,              // RAID state change
        DH_NEWLOG_ABLAZE_ON,				        // fire alarm, smoke or temperature
        DH_NEWLOG_ABLAZE_OFF,			            // fire alarm resume
        DH_NEWLOG_INTELLI_ALARM_PLUSE,				// alarm of pulse type
        DH_NEWLOG_INTELLI_ALARM_IN,					// begin of alarm
        DH_NEWLOG_INTELLI_ALARM_END,				// end of alarm
        DH_NEWLOG_3G_SIGNAL_SCAN,					// 3G signal scan
        DH_NEWLOG_GPS_SIGNAL_SCAN,					// GPS signal scan
        DH_NEWLOG_AUTOMATIC_RECORD = 0x0400,		// Auto record
        DH_NEWLOG_MANUAL_RECORD,					// Manual record
        DH_NEWLOG_CLOSED_RECORD,					// Stop record
        DH_NEWLOG_LOGIN = 0x0500,					// Log in
        DH_NEWLOG_LOGOUT,							// Log off
        DH_NEWLOG_ADD_USER,							// Add user
        DH_NEWLOG_DELETE_USER,						// Delete user
        DH_NEWLOG_MODIFY_USER,						// Modify user
        DH_NEWLOG_ADD_GROUP,						// Add user group
        DH_NEWLOG_DELETE_GROUP,						// Delete user group
        DH_NEWLOG_MODIFY_GROUP,						// Modify user group
        DH_NEWLOG_NET_LOGIN = 0x0508,				// Network user login
        DH_NEWLOG_CLEAR = 0x0600,					// Clear log
        DH_NEWLOG_SEARCHLOG,						// Search log
        DH_NEWLOG_SEARCH = 0x0700,					// Search record
        DH_NEWLOG_DOWNLOAD,							// Record download
        DH_NEWLOG_PLAYBACK,							// Record playback
        DH_NEWLOG_BACKUP,							// Backup recorded file
        DH_NEWLOG_BACKUPERROR,						// Failed to backup recorded file
        
        DH_NEWLOG_BACK_UPRT,						// Real-time backup, that is, copy CD
        DH_NEWLOG_BACKUPCLONE,						// CD copy
        DH_NEWLOG_DISK_CHANGED,						// Manual  changed
        DH_NEWLOG_IMAGEPLAYBACK,					// image palyback
        DH_NEWLOG_LOCKFILE,							// Lock the video
        DH_NEWLOG_UNLOCKFILE,						// Unlock the video
        DH_NEWLOG_ATMPOS,							// Add log superposition of ATM card number
        
        DH_NEWLOG_TIME_UPDATE  = 0x0800,            // Time update
        DH_NEWLOG_REMOTE_STATE = 0x0850,            // remote diary
        
        DH_NEWLOG_USER_DEFINE = 0x0900,
        DH_NEWLOG_TYPE_NR = 10,
    } DH_NEWLOG_TYPE;
    
    ///////////////////////////////About audio talk ///////////////////////////////
    
    // Audio encode type
    typedef enum __TALK_CODING_TYPE
    {
        DH_TALK_DEFAULT = 0,						// No-head PCM
        DH_TALK_PCM = 1,							// With head PCM
        DH_TALK_G711a,								// G711a
        DH_TALK_AMR,								// AMR
        DH_TALK_G711u,								// G711u
        DH_TALK_G726,								// G726
        DH_TALK_G723_53,							// G723_53
        DH_TALK_G723_63,							// G723_63
        DH_TALK_AAC,								// AAC
        DH_TALK_OGG,                                // OGG
        DH_TALK_ADPCM = 21,                         // ADPCM
        DH_TALK_MP3   = 22,							// MP3
    } DH_TALK_CODING_TYPE;
    
    // Record file type
    typedef enum __NET_RECORD_TYPE
    {
        NET_RECORD_TYPE_ALL,                        // All the video
        NET_RECORD_TYPE_NORMAL,                     // common  video
        NET_RECORD_TYPE_ALARM,                      // External alarm video
        NET_RECORD_TYPE_MOTION,                     // DM alarm video
    }NET_RECORD_TYPE;
    
    // Audio talk way
    typedef enum __EM_USEDEV_MODE
    {
        DH_TALK_CLIENT_MODE,						// Set client-end mode to begin audio talk
        DH_TALK_SERVER_MODE,						// Set server mode to begin audio talk
        DH_TALK_ENCODE_TYPE,						// Set encode format for audio talk
        DH_ALARM_LISTEN_MODE,						// Set alarm subscribe way
        DH_CONFIG_AUTHORITY_MODE,					// Set user right to realize configuration management
        DH_TALK_TALK_CHANNEL,						// set talking channel(0~MaxChannel-1)
        DH_RECORD_STREAM_TYPE,                      // set the stream type of the record for query(0-both main and extra stream,1-only main stream,2-only extra stream)
        DH_TALK_SPEAK_PARAM,                        // set speaking parameter,corresponding to NET_SPEAK_PARAM
        DH_RECORD_TYPE,                             // Set by time video playback and download the video file TYPE (see.net RECORD TYPE)
        DH_TALK_MODE3,								// Set voice intercom parameters of three generations of equipment and the corresponding structure NET TALK the EX
        DH_PLAYBACK_REALTIME_MODE ,                 // set real time playback function(0-off??1-on)
        DH_TALK_TRANSFER_MODE,                      // Judge the voice intercom if it was a forwarding mode, (corresponding to  NET_TALK_TRANSFER_PARAM)
    } EM_USEDEV_MODE;
    
    
    typedef enum __EM_TALK_DATA_TYPE
    {
        NET_TALK_DATA_LOCAL_AUDIO = 0,				// Local recording audio data from the library
        NET_TALK_DATA_RECV_AUDIO,					// Receiving device sending audio data
        NET_TALK_DATA_RESPOND,						// Intercom call response data
        NET_TALK_DATA_RECV_VIDEO,                   // Got device sent video data
    }EM_TALK_DATA_TYPE;
    
    typedef struct tagNET_TALK_VIDEO_FORMAT
    {
        DWORD				dwSize;
        DWORD				dwCompression;			// Video compression format
        int					nFrequency;				// Video sampling frequency
    }NET_TALK_VIDEO_FORMAT;
    // Three generations of equipment parameters of voice intercom, corresponding to the CLIENT SetDeviceMode DH TALK MODE3 () command
    typedef struct tagNET_TALK_EX
    {
        DWORD               dwSize;
        int					nChannel;               // channel number
        int                 nAudioPort;             // Audio transmission listener ports
        int					nWaitTime;              // Ms wait time, unit, use the default value is 0
        HWND				hVideoWnd;				// Visual talk video window
        NET_TALK_VIDEO_FORMAT stuVideoFmt;			// Video encode format
        char				szMulticastAddr[DH_MAX_IPADDR_LEN_EX]; // Multicast address
        WORD				wMulticastLocalPort;	// Multicast local port
        WORD				wMulticastRemotePort;	// Multicast remote port
    }NET_TALK_EX;
    
    // AMR Encode Type
    typedef enum __EM_ARM_ENCODE_MODE
    {
        DH_TALK_AMR_AMR475 = 1,						// AMR475
        DH_TALK_AMR_AMR515,							// AMR515
        DH_TALK_AMR_AMR59,							// AMR59
        DH_TALK_AMR_AMR67,							// AMR67
        DH_TALK_AMR_AMR74,							// AMR74
        DH_TALK_AMR_AMR795,							// AMR795
        DH_TALK_AMR_AMR102,							// AMR102
        DH_TALK_AMR_AMR122,							// AMR122
    } EM_ARM_ENCODE_MODE;
    
    typedef struct __NET_SPEAK_PARAM
    {
        DWORD           dwSize;                     // struct size
        int             nMode;                      // 0:talk back(default), 1: propaganda,from propaganda ro talk back,need afresh to configure
        int             nSpeakerChannel;            // reproducer channel
    } NET_SPEAK_PARAM;
    
    //Open the forwarding mode of intercom or not
    typedef struct tagNET_TALK_TRANSFER_PARAM
    {
        DWORD           dwSize;
        BOOL            bTransfer;                  // Open the forwarding mode of intercom or not, TRUE: yes, FALSE: no
    }NET_TALK_TRANSFER_PARAM;
    
    /////////////////////////////////Control Related/////////////////////////////////
    
    // Control type    Corresponding to CLIENT_ControlDevice
    typedef enum _CtrlType
    {
        DH_CTRL_REBOOT = 0,							// Reboot device
        DH_CTRL_SHUTDOWN,							// Shut down device
        DH_CTRL_DISK,								// HDD management
        DH_KEYBOARD_POWER = 3,						// Network keyboard
        DH_KEYBOARD_ENTER,
        DH_KEYBOARD_ESC,
        DH_KEYBOARD_UP,
        DH_KEYBOARD_DOWN,
        DH_KEYBOARD_LEFT,
        DH_KEYBOARD_RIGHT,
        DH_KEYBOARD_BTN0,
        DH_KEYBOARD_BTN1,
        DH_KEYBOARD_BTN2,
        DH_KEYBOARD_BTN3,
        DH_KEYBOARD_BTN4,
        DH_KEYBOARD_BTN5,
        DH_KEYBOARD_BTN6,
        DH_KEYBOARD_BTN7,
        DH_KEYBOARD_BTN8,
        DH_KEYBOARD_BTN9,
        DH_KEYBOARD_BTN10,
        DH_KEYBOARD_BTN11,
        DH_KEYBOARD_BTN12,
        DH_KEYBOARD_BTN13,
        DH_KEYBOARD_BTN14,
        DH_KEYBOARD_BTN15,
        DH_KEYBOARD_BTN16,
        DH_KEYBOARD_SPLIT,
        DH_KEYBOARD_ONE,
        DH_KEYBOARD_NINE,
        DH_KEYBOARD_ADDR,
        DH_KEYBOARD_INFO,
        DH_KEYBOARD_REC,
        DH_KEYBOARD_FN1,
        DH_KEYBOARD_FN2,
        DH_KEYBOARD_PLAY,
        DH_KEYBOARD_STOP,
        DH_KEYBOARD_SLOW,
        DH_KEYBOARD_FAST,
        DH_KEYBOARD_PREW,
        DH_KEYBOARD_NEXT,
        DH_KEYBOARD_JMPDOWN,
        DH_KEYBOARD_JMPUP,
        DH_KEYBOARD_10PLUS,
        DH_KEYBOARD_SHIFT,
        DH_KEYBOARD_BACK,
        DH_KEYBOARD_LOGIN ,                         // new network keyboard function
        DH_KEYBOARD_CHNNEL ,                        // switch video channel
        DH_TRIGGER_ALARM_IN = 100,					// Activate alarm input
        DH_TRIGGER_ALARM_OUT,						// Activate alarm output
        DH_CTRL_MATRIX,								// Matrix control
        DH_CTRL_SDCARD,								// SD card control(for IPC series). Please refer to HDD control
        DH_BURNING_START,							// Burner control:begin burning
        DH_BURNING_STOP,							// Burner control:stop burning
        DH_BURNING_ADDPWD,							// Burner control:overlay password(The string ended with '\0'. Max length is 8 bits. )
        DH_BURNING_ADDHEAD,							// Burner control:overlay head title(The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter.)
        DH_BURNING_ADDSIGN,							// Burner control:overlay dot to the burned information(No parameter)
        DH_BURNING_ADDCURSTOMINFO,					// Burner control:self-defined overlay (The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter)
        DH_CTRL_RESTOREDEFAULT,						// restore device default setup
        DH_CTRL_CAPTURE_START,						// Activate device snapshot
        DH_CTRL_CLEARLOG,							// Clear log
        DH_TRIGGER_ALARM_WIRELESS = 200,			// Activate wireless alarm (IPC series)
        DH_MARK_IMPORTANT_RECORD,					// Mark important record
        DH_CTRL_DISK_SUBAREA, 						// Network hard disk partition
        DH_BURNING_ATTACH,							// Annex burning
        DH_BURNING_PAUSE,							// Burn Pause
        DH_BURNING_CONTINUE,						// Burn Resume
        DH_BURNING_POSTPONE,						// Burn Postponed
        DH_CTRL_OEMCTRL,							// OEM control
        DH_BACKUP_START,							// Start to device backup
        DH_BACKUP_STOP,								// Stop to device backup
        DH_VIHICLE_WIFI_ADD,						// Add WIFI configuration manually for car device
        DH_VIHICLE_WIFI_DEC,						// Delete WIFI configuration manually for car device
        DH_BUZZER_START,                            // Start to buzzer control
        DH_BUZZER_STOP,                             // Stop to buzzer control
        DH_REJECT_USER,                             // Reject User
        DH_SHIELD_USER,                             // Shield User
        DH_RAINBRUSH,                               // Rain Brush
        DH_MANUAL_SNAP,                             // manual snap (struct MANUAL_SNAP_PARAMETER)
        DH_MANUAL_NTP_TIMEADJUST,                   // manual ntp time adjust
        DH_NAVIGATION_SMS,                          // navigation info and note
        DH_CTRL_ROUTE_CROSSING,                     // route info
        DH_BACKUP_FORMAT,							// backup device format
        DH_DEVICE_LOCALPREVIEW_SLIPT,               // local preview split(struct DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)
        DH_CTRL_INIT_RAID,							// RAID init
        DH_CTRL_RAID,								// RAID control
        DH_CTRL_SAPREDISK,							// sapredisk control
        DH_WIFI_CONNECT,							// wifi connect(struct WIFI_CONNECT)
        DH_WIFI_DISCONNECT,							// wifi disconnect(struct WIFI_CONNECT)
        DH_CTRL_ARMED,                              // Arm/disarm operation
        DH_CTRL_IP_MODIFY,                          // IP modify(struct DHCTRL_IPMODIFY_PARAM)
        DH_CTRL_WIFI_BY_WPS,                        // wps connect wifi(struct DHCTRL_CONNECT_WIFI_BYWPS)
        DH_CTRL_FORMAT_PATITION,					// format pattion (struct DH_FORMAT_PATITION)
        DH_CTRL_EJECT_STORAGE,						// eject storage device(struct DH_EJECT_STORAGE_DEVICE)
        DH_CTRL_LOAD_STORAGE,						// load storage device(struct DH_LOAD_STORAGE_DEVICE)
        DH_CTRL_CLOSE_BURNER,                       // close burner(struct NET_CTRL_BURNERDOOR) need wait 6s
        DH_CTRL_EJECT_BURNER,                       // eject burner(struct NET_CTRL_BURNERDOOR) need wait 4s
        DH_CTRL_CLEAR_ALARM,						// alarm elimination corresponding structure NET (CTRL CLEAR ALARM)
        DH_CTRL_MONITORWALL_TVINFO,					// TV wall information display corresponding structure NET (CTRL MONITORWALL TVINFO)
        DH_CTRL_START_VIDEO_ANALYSE,                //  start Intelligent VIDEO analysis (corresponding structure NET CTRL START VIDEO ANALYSE)
        DH_CTRL_STOP_VIDEO_ANALYSE,                 // STOP intelligent VIDEO analysis corresponding structure NET (CTRL STOP VIDEO ANALYSE)
        DH_CTRL_UPGRADE_DEVICE,                     //Controlled start equipment upgrades, independently complete the upgrade process by the equipment do not need to upgrade file
        DH_CTRL_MULTIPLAYBACK_CHANNALES,            // Multi-channel preview playback channel switching corresponding structure NET (CTRL MULTIPLAYBACK CHANNALES)
        DH_CTRL_SEQPOWER_OPEN,						// Turn on the switch power supply timing device output corresponding.net (CTRL SEQPOWER PARAM)
        DH_CTRL_SEQPOWER_CLOSE,						// Close the switch power supply timing device output corresponding.net (CTRL SEQPOWER PARAM)
        DH_CTRL_SEQPOWER_OPEN_ALL,					// Power timing group open the switch quantity output corresponding.net (CTRL SEQPOWER PARAM)
        DH_CTRL_SEQPOWER_CLOSE_ALL,					// Power sequence set close the switch quantity output corresponding.net (CTRL SEQPOWER PARAM)
        DH_CTRL_PROJECTOR_RISE,						// PROJECTOR up corresponding.net (CTRL PROJECTOR PARAM)
        DH_CTRL_PROJECTOR_FALL,						// PROJECTOR drop (corresponding to the.net CTRL PROJECTOR PARAM)
        DH_CTRL_PROJECTOR_STOP,						// PROJECTOR stop (corresponding to the.net CTRL PROJECTOR PARAM)
        DH_CTRL_INFRARED_KEY,						// INFRARED buttons (corresponding to the.net CTRL INFRARED KEY PARAM)
        DH_CTRL_START_PLAYAUDIO,					// Device START playback of audio file corresponding structure NET (CTRL START PLAYAUDIO)
        DH_CTRL_STOP_PLAYAUDIO,						// Equipment stop playback of audio file
        DH_CTRL_START_ALARMBELL,					// Corresponding structure NET open alarm (CTRL ALARMBELL)
        DH_CTRL_STOP_ALARMBELL,						// Close the warning signal corresponding structure NET (CTRL ALARMBELL)
        DH_CTRL_ACCESS_OPEN,						// OPEN ACCESS control - corresponding structure NET (CTRL ACCESS OPEN)
        DH_CTRL_SET_BYPASS,							//Corresponding structure NET BYPASS function (CTRL SET BYPASS)
        DH_CTRL_RECORDSET_INSERT,					// Add records to record set number (corresponding to the.net CTRL you INSERT PARAM)
        DH_CTRL_RECORDSET_UPDATE,					// Update a record of the number (corresponding to the.net CTRL you PARAM)
        DH_CTRL_RECORDSET_REMOVE,					// According to the record set number to delete a record (corresponding to the.net CTRL you PARAM)
        DH_CTRL_RECORDSET_CLEAR,					// Remove all RECORDSET information corresponding.net (CTRL you PARAM)
        DH_CTRL_ACCESS_CLOSE,						// Entrance guard control - CLOSE corresponding structure NET (CTRL ACCESS CLOSE)
        DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET,			// Alarm sub system activation setup(corresponding structure NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
        DH_CTRL_FORBID_OPEN_STROBE,                 // Disable device open gateway(corresponding to structure  NET_CTRL_FORBID_OPEN_STROBE)
        DH_CTRL_OPEN_STROBE,                        // Enable gateway(corresponding to structure  NET_CTRL_OPEN_STROBE)
        DH_CTRL_TALKING_REFUSE,                     // Talk no response(corresponding to structure  NET_CTRL_TALKING_REFUSE)
        DH_CTRL_ARMED_EX,                           // arm-disarm operation(corresponding to structure CTRL_ARM_DISARM_PARAM_EX), CTRL_ARM_DISARM_PARAM upgrade??recommended
        DH_CTRL_NET_KEYBOARD = 400,                 // Net keyboard control(corresponding to structure  DHCTRL_NET_KEYBOARD)
        DH_CTRL_AIRCONDITION_OPEN,                  // Open air conditioner(corresponding to structure  NET_CTRL_OPEN_AIRCONDITION)
        DH_CTRL_AIRCONDITION_CLOSE,                 // Close air-conditioner(corresponding to structure  NET_CTRL_CLOSE_AIRCONDITION)
        DH_CTRL_AIRCONDITION_SET_TEMPERATURE,       // Set temperature (corresponding to structure  NET_CTRL_SET_TEMPERATURE)
        DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE,    // Adjust temperature(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
        DH_CTRL_AIRCONDITION_SETMODE,               // Set air work mode(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
        DH_CTRL_AIRCONDITION_SETWINDMODE,           // Set fan mode(corresponding to structure  NET_CTRL_AIRCONDITION_SETMODE)
        DH_CTRL_RESTOREDEFAULT_EX ,                 // Recover device default and set new protocol(corresponding to structure NET_CTRL_RESTORE_DEFAULT)
        // Recover config and use this enumeration first, if port failed,
        // and CLIENT_GetLastError return NET_UNSUPPORTED, try again DH_CTRL_RESTOREDEFAULT restore config
        DH_CTRL_NOTIFY_EVENT,                       // send event to device (corresponding to  structure  NET_NOTIFY_EVENT_DATA)
        DH_CTRL_SILENT_ALARM_SET,                   // mute alarm setup
        DH_CTRL_START_PLAYAUDIOEX,                  // device start sound report(corresponding to  structure  NET_CTRL_START_PLAYAUDIOEX)
        DH_CTRL_STOP_PLAYAUDIOEX,                   // device stop sound report
        DH_CTRL_CLOSE_STROBE,                       // close gateway(corresponding to  structure  NET_CTRL_CLOSE_STROBE)
        DH_CTRL_SET_ORDER_STATE,                    // set parking reservation status (corresponding to  structure  NET_CTRL_SET_ORDER_STATE)
        DH_CTRL_RECORDSET_INSERTEX,                 // add record??get record collection no.(corresponding to NET_CTRL_RECORDSET_INSERT_PARAM)
        DH_CTRL_RECORDSET_UPDATEEX,                 // update record set no.??s record(corresponding to NET_CTRL_RECORDSET_PARAM)
        DH_CTRL_CAPTURE_FINGER_PRINT,               // fingerprint collection (corresponding to structure NET_CTRL_CAPTURE_FINGER_PRINT)
        DH_CTRL_ECK_LED_SET,                           // Parking lot entrance/exit controller LED setup(corresponding structure  NET_CTRL_ECK_LED_SET_PARAM)
        DH_CTRL_ECK_IC_CARD_IMPORT,                    // Intelligent parking system in/out device IC card info import (corresponding structure  NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
        DH_CTRL_ECK_SYNC_IC_CARD,                      // Intelligent parking system in/out device IC card info sync command, receive this command, device will delete original IC card info(corresponding structure  NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
        DH_CTRL_LOWRATEWPAN_REMOVE,                    // Delete specific wireless device(corresponding structure  NET_CTRL_LOWRATEWPAN_REMOVE)
        DH_CTRL_LOWRATEWPAN_MODIFY,                    // Modify wireless device info(corresponding structure  NET_CTRL_LOWRATEWPAN_MODIFY)
        DH_CTRL_ECK_SET_PARK_INFO,                     // Set up the vehicle spot information of the machine at the passageway of the intelligent parking system (corresponding to  NET_CTRL_ECK_SET_PARK_INFO_PARAM)
        DH_CTRL_VTP_DISCONNECT,                        // hang up the video phone (corresponding to NET_CTRL_VTP_DISCONNECT)
        DH_CTRL_UPDATE_FILES,                          // the update of the remote multimedia files (corresponding to NET_CTRL_UPDATE_FILES)
        DH_CTRL_MATRIX_SAVE_SWITCH,                    // Save up the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_SAVE_SWITCH)
        DH_CTRL_MATRIX_RESTORE_SWITCH,                 // recover the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_RESTORE_SWITCH)
        DH_CTRL_VTP_DIVERTACK,                         // video talk phone divert ack(corresponding to NET_CTRL_VTP_DIVERTACK)
        DH_CTRL_RAINBRUSH_MOVEONCE,                    // Rain-brush brush one time, efficient when set as manual mode(corresponding to NET_CTRL_RAINBRUSH_MOVEONCE)
        DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY,            // Rain-brush brush cyclic, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
        DH_CTRL_RAINBRUSH_STOPMOVE,                    // Rain-brush stop, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_STOPMOVE)
        DH_CTRL_ALARM_ACK,                             // affirm the alarm event(corresponding to NET_CTRL_ALARM_ACK)
        // DH_CTRL_ALARM_ACK DO NOT call this method in callback interface
    } CtrlType;
    
    // the parameter of saving the relationship between the hyponymy matrixes(corresponding to DH_CTRL_MATRIX_SAVE_SWITCH)
    typedef struct tagNET_CTRL_MATRIX_SAVE_SWITCH
    {
        DWORD           dwSize;
        const char*     pszName;                        //the relationship between the hyponymy matrixes
    } NET_CTRL_MATRIX_SAVE_SWITCH;
    
    // recover the relationship between the hyponymy matrixes (corresponding to DH_CTRL_MATRIX_RESTORE_SWITCH)
    typedef struct tagNET_CTRL_MATRIX_RESTORE_SWITCH
    {
        DWORD           dwSize;
        const char*     pszName;                        // the relationship between the hyponymy matrixes
    } NET_CTRL_MATRIX_RESTORE_SWITCH;
    
    // Restore default config new protocol input parameter
    typedef struct tagNET_CTRL_RESTORE_DEFAULT
    {
        DWORD			dwSize;
        const char*		szCfgNames;		// Config name and'&&' as interval, config see dhconfigsdk.h CLIENT_GetNewDevConfig and CLIENT_SetNewDevConfig port command
    }NET_CTRL_RESTORE_DEFAULT;
    
    // Open air-conditioner parameter(corresponding to DH_CTRL_AIRCONDITION_OPEN)
    typedef struct tagNET_CTRL_OPEN_AIRCONDITION
    {
        DWORD               dwSize;
        char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
    } NET_CTRL_OPEN_AIRCONDITION;
    
    // Close air-conditioner parameter(corresponding to command DH_CTRL_AIRCONDITION_CLOSE)
    typedef struct tagNET_CTRL_CLOSE_AIRCONDITION
    {
        DWORD               dwSize;
        char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
    } NET_CTRL_CLOSE_AIRCONDITION;
    
    // Set temperature parameter (corresponding command DH_CTRL_AIRCONDITION_SET_TEMPERATURE)
    typedef struct tagNET_CTRL_SET_TEMPERATURE
    {
        DWORD               dwSize;
        char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN
        int                 nTemperature;                           // Temperature value(??)
    } NET_CTRL_SET_TEMPERATURE;
    
    // Adjust temperature parameter(corresponding command DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE)
    typedef struct tagNET_CTRL_ADJUST_TEMPERATURE
    {
        DWORD               dwSize;
        char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN
        int                 nTemperatureScale;                      // Set value
    } NET_CTRL_ADJUST_TEMPERATURE;
    
    // Set air condition working mode parameter (corresponding command DH_CTRL_AIRCONDITION_SETMODE)
    typedef struct tagNET_CTRL_AIRCONDITION_SETMODE
    {
        DWORD                       dwSize;
        char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN
        EM_AIRCONDITION_MODE        emAirconditionMode;             // Air conditioner working mode
        int                         nTemperature;                   // Set value (??)
    } NET_CTRL_AIRCONDITION_SETMODE;
    
    // Set fan mode parameter(corresponding command DH_CTRL_AIRCONDITION_SETWINDMODE)
    typedef struct tagNET_CTRL_AIRCONDITION_SETWINDMODE
    {
        DWORD                       dwSize;
        char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN
        EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Fan mode??
    } NET_CTRL_AIRCONDITION_SETWINDMODE;
    
    // IO control command. Corresponding to CLIENT_QueryIOControlState
    typedef enum _IOTYPE
    {
        DH_ALARMINPUT = 1,							// Control alarm input
        DH_ALARMOUTPUT = 2,							// ontrol alarm output
        DH_DECODER_ALARMOUT = 3,					// Control alarm decoder output
        DH_WIRELESS_ALARMOUT = 5,					// Control wireless alarm output
        DH_ALARM_TRIGGER_MODE = 7,					// Alarm activation type(auto/manual/close). Use TRIGGER_MODE_CONTROL structure
    } DH_IOTYPE;
    
    /////////////////////////////////Configuration Related/////////////////////////////////
    
    // Resolution enumeration. For DH_DSP_ENCODECAP to use
    typedef enum _CAPTURE_SIZE
    {
        CAPTURE_SIZE_D1,							// 704*576(PAL)  704*480(NTSC)
        CAPTURE_SIZE_HD1,							// 352*576(PAL)  352*480(NTSC)
        CAPTURE_SIZE_BCIF,							// 704*288(PAL)  704*240(NTSC)
        CAPTURE_SIZE_CIF,							// 352*288(PAL)  352*240(NTSC)
        CAPTURE_SIZE_QCIF,							// 176*144(PAL)  176*120(NTSC)
        CAPTURE_SIZE_VGA,							// 640*480
        CAPTURE_SIZE_QVGA,							// 320*240
        CAPTURE_SIZE_SVCD,							// 480*480
        CAPTURE_SIZE_QQVGA,							// 160*128
        CAPTURE_SIZE_SVGA,							// 800*592
        CAPTURE_SIZE_XVGA,							// 1024*768
        CAPTURE_SIZE_WXGA,							// 1280*800
        CAPTURE_SIZE_SXGA,							// 1280*1024
        CAPTURE_SIZE_WSXGA,							// 1600*1024
        CAPTURE_SIZE_UXGA,							// 1600*1200
        CAPTURE_SIZE_WUXGA,							// 1920*1200
        CAPTURE_SIZE_LTF,							// 240*192
        CAPTURE_SIZE_720,							// 1280*720
        CAPTURE_SIZE_1080,							// 1920*1080
        CAPTURE_SIZE_1_3M,							// 1280*960
        CAPTURE_SIZE_2M,							// 1872*1408
        CAPTURE_SIZE_5M,							// 3744*1408
        CAPTURE_SIZE_3M,							// 2048*1536
        CAPTURE_SIZE_5_0M,                          // 2432*2050
        CPTRUTE_SIZE_1_2M,							// 1216*1024
        CPTRUTE_SIZE_1408_1024,                     // 1408*1024
        CPTRUTE_SIZE_8M,                            // 3296*2472
        CPTRUTE_SIZE_2560_1920,                     // 2560*1920(5M)
        CAPTURE_SIZE_960H,                          // 960*576(PAL) 960*480(NTSC)
        CAPTURE_SIZE_960_720,                       // 960*720
        CAPTURE_SIZE_NHD,							// 640*360
        CAPTURE_SIZE_QNHD,							// 320*180
        CAPTURE_SIZE_QQNHD,							// 160*90
        CAPTURE_SIZE_960_540,						// 960*540
        CAPTURE_SIZE_640_352,						// 640*352
        CAPTURE_SIZE_640_400,						// 640*400
        CAPTURE_SIZE_320_192,						// 320*192
        CAPTURE_SIZE_320_176,						// 320*176
        CAPTURE_SIZE_NR=255
    } CAPTURE_SIZE;
    
    // Configuration file type. For CLIENT_ExportConfigFile to use.
    typedef enum __DH_CONFIG_FILE_TYPE
    {
        DH_CONFIGFILE_ALL = 0,						// All configuration file
        DH_CONFIGFILE_LOCAL,						// Local configuration file
        DH_CONFIGFILE_NETWORK,						// Network configuration file
        DH_CONFIGFILE_USER,							// User configuration file
    } DH_CONFIG_FILE_TYPE;
    
    // NTP
    typedef enum __DH_TIME_ZONE_TYPE
    {
        DH_TIME_ZONE_0,								// {0, 0*3600,"GMT+00:00"}
        DH_TIME_ZONE_1,								// {1, 1*3600,"GMT+01:00"}
        DH_TIME_ZONE_2,								// {2, 2*3600,"GMT+02:00"}
        DH_TIME_ZONE_3,								// {3, 3*3600,"GMT+03:00"}
        DH_TIME_ZONE_4,								// {4, 3*3600+1800,"GMT+03:30"}
        DH_TIME_ZONE_5,								// {5, 4*3600,"GMT+04:00"}
        DH_TIME_ZONE_6,								// {6, 4*3600+1800,"GMT+04:30"}
        DH_TIME_ZONE_7,								// {7, 5*3600,"GMT+05:00"}
        DH_TIME_ZONE_8,								// {8, 5*3600+1800,"GMT+05:30"}
        DH_TIME_ZONE_9,								// {9, 5*3600+1800+900,"GMT+05:45"}
        DH_TIME_ZONE_10,							// {10, 6*3600,"GMT+06:00"}
        DH_TIME_ZONE_11,							// {11, 6*3600+1800,"GMT+06:30"}
        DH_TIME_ZONE_12,							// {12, 7*3600,"GMT+07:00"}
        DH_TIME_ZONE_13,							// {13, 8*3600,"GMT+08:00"}
        DH_TIME_ZONE_14,							// {14, 9*3600,"GMT+09:00"}
        DH_TIME_ZONE_15,							// {15, 9*3600+1800,"GMT+09:30"}
        DH_TIME_ZONE_16,							// {16, 10*3600,"GMT+10:00"}
        DH_TIME_ZONE_17,							// {17, 11*3600,"GMT+11:00"}
        DH_TIME_ZONE_18,							// {18, 12*3600,"GMT+12:00"}
        DH_TIME_ZONE_19,							// {19, 13*3600,"GMT+13:00"}
        DH_TIME_ZONE_20,							// {20, -1*3600,"GMT-01:00"}
        DH_TIME_ZONE_21,							// {21, -2*3600,"GMT-02:00"}
        DH_TIME_ZONE_22,							// {22, -3*3600,"GMT-03:00"}
        DH_TIME_ZONE_23,							// {23, -3*3600-1800,"GMT-03:30"}
        DH_TIME_ZONE_24,							// {24, -4*3600,"GMT-04:00"}
        DH_TIME_ZONE_25,							// {25, -5*3600,"GMT-05:00"}
        DH_TIME_ZONE_26,							// {26, -6*3600,"GMT-06:00"}
        DH_TIME_ZONE_27,							// {27, -7*3600,"GMT-07:00"}
        DH_TIME_ZONE_28,							// {28, -8*3600,"GMT-08:00"}
        DH_TIME_ZONE_29,							// {29, -9*3600,"GMT-09:00"}
        DH_TIME_ZONE_30,							// {30, -10*3600,"GMT-10:00"}
        DH_TIME_ZONE_31,							// {31, -11*3600,"GMT-11:00"}
        DH_TIME_ZONE_32,							// {32, -12*3600,"GMT-12:00"}
    } DH_TIME_ZONE_TYPE;
    
    typedef enum _SNAP_TYPE
    {
        SNAP_TYP_TIMING = 0,
        SNAP_TYP_ALARM,
        SNAP_TYP_NUM,
    } SNAP_TYPE;
    
    typedef enum _CONNECT_STATE
    {
        CONNECT_STATE_UNCONNECT  = 0,
        CONNECT_STATE_CONNECTING,
        CONNECT_STATE_CONNECTED,
        CONNECT_STATE_ERROR = 255,
    } CONNECT_STATE;
    
    // Snap mode
    typedef enum tagDH_TRAFFIC_SNAP_MODE
    {
        DH_TRAFFIC_SNAP_MODE_COIL = 1,				       // Loop snap
        DH_TRAFFIC_SNAP_MODE_COIL_PICANALYSIS,		       // Loop snap   picture analysis
        DH_TRAFFIC_SNAP_MODE_STREAM,				       // Video snap
        DH_TRAFFIC_SNAP_MODE_STREAM_IDENTIFY,		       // Video snap and recognize
    } DH_TRAFFIC_SNAP_MODE;
    
    // carport light type
    typedef enum
    {
        NET_CARPORTLIGHT_TYPE_RED,                           // red
        NET_CARPORTLIGHT_TYPE_GREEN,                         // green
    }NET_CARPORTLIGHT_TYPE;
    
    // carport light mode
    typedef enum
    {
        NET_CARPORTLIGHT_MODE_OFF,                           // off
        NET_CARPORTLIGHT_MODE_ON,                            // on
        NET_CARPORTLIGHT_MODE_GLINT,                         // glint
    }NET_CARPORTLIGHT_MODE;
    
    /////////////////////////////////Intelligent transportation related/////////////////////////////////
    //Black and white list type operation
    typedef enum _EM_OPERATE_TYPE
    {
        NET_TRAFFIC_LIST_INSERT	    ,								// Increase the record operation
        NET_TRAFFIC_LIST_UPDATE		,								// Record update operation
        NET_TRAFFIC_LIST_REMOVE		,								// Delete the record operation
        NET_TRAFFIC_LIST_MAX		,
    }EM_RECORD_OPERATE_TYPE ;
    
    //License plate type
    typedef enum _EM_NET_PLATE_TYPE
    {
        NET_PLATE_TYPE_UNKNOWN					,
        NET_PLATE_TYPE_NORMAL					,		// "Normal" Blue card black card
        NET_PLATE_TYPE_YELLOW					,		// "Yellow" yellow card
        NET_PLATE_TYPE_DOUBLEYELLOW				,		// "DoubleYellow" Double yellow back card
        NET_PLATE_TYPE_POLICE					,		// "Police" Police card
        NET_PLATE_TYPE_ARMED					,		// "Armed" Armed card
        NET_PLATE_TYPE_MILITARY					,		// "Military" Force plate
        NET_PLATE_TYPE_DOUBLEMILITARY			,		// "DoubleMilitary" Forces double
        NET_PLATE_TYPE_SAR						,		// "SAR" Hong Kong and Macao SAR plate
        NET_PLATE_TYPE_TRAINNING				,		// "Trainning" Drivers Ed plate
        NET_PLATE_TYPE_PERSONAL					,		// "Personal" Personality plate
        NET_PLATE_TYPE_AGRI						,		// "Agri" Agri-using card
        NET_PLATE_TYPE_EMBASSY					,		// "Embassy" The embassy of plate
        NET_PLATE_TYPE_MOTO						,		// "Moto" Motorcycle plate
        NET_PLATE_TYPE_TRACTOR					,		// "Tractor" The tractor plate
        NET_PLATE_TYPE_OFFICIALCAR				,		// "OfficialCar " officer's car
        NET_PLATE_TYPE_PERSONALCAR				,		// "PersonalCar" private car
        NET_PLATE_TYPE_WARCAR					,		// "WarCar"  for military use
        NET_PLATE_TYPE_OTHER					,		// "Other" The other plate
    }EM_NET_PLATE_TYPE;
    
    
    //The license plate color
    typedef enum _EM_NET_PLATE_COLOR_TYPE
    {
        NET_PLATE_COLOR_OTHER 						,				//	other colors
        NET_PLATE_COLOR_BLUE						,				//	blue		"Blue"
        NET_PLATE_COLOR_YELLOW						,				//	yellow		"Yellow"
        NET_PLATE_COLOR_WHITE						,				//	white		"White"
        NET_PLATE_COLOR_BLACK						,				//	black		"Black"
        NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT	,				//	 Yellow Bottom Positive Figure	"YellowbottomBlackText"
        NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT		,				//	blue-mask LCD"
        NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT		,				//	White on Black	"BlackBottomWhiteText"
    }EM_NET_PLATE_COLOR_TYPE;
    
    //vehicle type
    typedef enum _EM_NET_VEHICLE_TYPE
    {
        NET_VEHICLE_TYPE_UNKNOW					  ,				//  unknown type
        NET_VEHICLE_TYPE_MOTOR					  ,				// "Motor" Motor vehicles"
        NET_VEHICLE_TYPE_NON_MOTOR				  ,				// "Non-Motor"non-Motor vehicles"
        NET_VEHICLE_TYPE_BUS					  ,				// "Bus"bus
        NET_VEHICLE_TYPE_BICYCLE				  ,				// "Bicycle"Bicycle
        NET_VEHICLE_TYPE_MOTORCYCLE               ,             // "Motorcycle"
        NET_VEHICLE_TYPE_UNLICENSEDMOTOR		  ,				// "UnlicensedMotor": A motor vehicle without a license
        NET_VEHICLE_TYPE_LARGECAR				  ,				// "LargeCar"  LargeCar
        NET_VEHICLE_TYPE_MICROCAR				  ,				// "MicroCar" MicroCar
        NET_VEHICLE_TYPE_EMBASSYCAR				  ,				// "EmbassyCar" EmbassyCa
        NET_VEHICLE_TYPE_MARGINALCAR			  ,				// "MarginalCar" MarginalCar
        NET_VEHICLE_TYPE_AREAOUTCAR				  ,				// "AreaoutCar" AreaoutCar
        NET_VEHICLE_TYPE_FOREIGNCAR				  ,				// "ForeignCar" ForeignCar
        NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE	  ,				// "DualTriWheelMotorcycle"Two or three rounds of motorcycle
        NET_VEHICLE_TYPE_LIGHTMOTORCYCLE		  , 			// "LightMotorcycle"  light motorcycle
        NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE		  ,				// "EmbassyMotorcycle "The embassy of the motorcycle
        NET_VEHICLE_TYPE_MARGINALMOTORCYCLE		  ,				// "MarginalMotorcycle "Consulate motorcycle
        NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE		  ,				// "AreaoutMotorcycle "Outside the motorcycle
        NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE		  ,				// "ForeignMotorcycle "Foreign motorcycle
        NET_VEHICLE_TYPE_FARMTRANSMITCAR		  ,				// "FarmTransmitCar" agricultural vehicle
        NET_VEHICLE_TYPE_TRACTOR				  ,				// "Tractor" tractor
        NET_VEHICLE_TYPE_TRAILER				  ,				// "Trailer"  trailer
        NET_VEHICLE_TYPE_COACHCAR				  ,				// "CoachCar "Car coach
        NET_VEHICLE_TYPE_COACHMOTORCYCLE		  ,				// "CoachMotorcycle " coach Motorcycle
        NET_VEHICLE_TYPE_TRIALCAR				  ,				// "TrialCar" trial car
        NET_VEHICLE_TYPE_TRIALMOTORCYCLE,                   // "TrialMotorcycle "Test motorcycle
        NET_VEHICLE_TYPE_TEMPORARYENTRYCAR		  ,				// "TemporaryEntryCar"Temporary entry vehicle
        NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE ,				// "TemporaryEntryMotorcycle"Temporary entry of motorcycle
        NET_VEHICLE_TYPE_TEMPORARYSTEERCAR		  ,			    // "TemporarySteerCar"Temporary driving car
        NET_VEHICLE_TYPE_PASSENGERCAR			  ,				// "PassengerCar" passenger car
        NET_VEHICLE_TYPE_LARGETRUCK				  ,				// "LargeTruck" LargeTruck
        NET_VEHICLE_TYPE_MIDTRUCK				  ,				// "MidTruck" MidTruck
        NET_VEHICLE_TYPE_SALOONCAR				  ,				// "SaloonCar" SaloonCar
        NET_VEHICLE_TYPE_MICROBUS                 ,				// "Microbus" Microbus
        NET_VEHICLE_TYPE_MICROTRUCK				  ,				// "MicroTruck" MicroTruck
        NET_VEHICLE_TYPE_TRICYCLE				  ,				// "Tricycle" Tricycle
        NET_VEHICLE_TYPE_PASSERBY				  ,				// "Passerby" Passerby
    }EM_NET_VEHICLE_TYPE;
    
    
    //body color
    typedef enum _EM_NET_VEHICLE_COLOR_TYPE
    {
        NET_VEHICLE_COLOR_OTHER					,				//other color
        NET_VEHICLE_COLOR_WHITE					,				//white		"White"
        NET_VEHICLE_COLOR_BLACK					,				//black		"Black"
        NET_VEHICLE_COLOR_RED					,				//red		"Red"
        NET_VEHICLE_COLOR_YELLOW				,				//yellow		"Yellow"
        NET_VEHICLE_COLOR_GRAY					,				//grey		"Gray"
        NET_VEHICLE_COLOR_BLUE					,				//blue		"Blue"
        NET_VEHICLE_COLOR_GREEN					,				//green		"Green"
        NET_VEHICLE_COLOR_PINK					,				//pink	"Pink"
        NET_VEHICLE_COLOR_PURPLE				,				//purple		"Purple"
        NET_VEHICLE_COLOR_BROWN					,				//brown		"Brown"
    }EM_NET_VEHICLE_COLOR_TYPE;
    
    //Open the coil
    typedef enum _EM_NET_TRAFFIC_CAR_CONTROL_TYPE
    {
        NET_CAR_CONTROL_OTHER					,
        NET_CAR_CONTROL_OVERDUE_NO_CHECK		,				// Back inspection "OverdueNoCheck"
        NET_CAR_CONTROL_BRIGANDAGE_CAR			,				//  steal "BrigandageCar"
        NET_CAR_CONTROL_BREAKING				,				// hit-and-run "CausetroubleEscape"
        NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE		,				// break rules and regulations		"Breaking"
    }EM_NET_TRAFFIC_CAR_CONTROL_TYPE;
    
    typedef enum _EM_NET_AUTHORITY_TYPE
    {
        NET_AUTHORITY_UNKNOW					,
        NET_AUTHORITY_OPEN_GATE					,				//c
    }EM_NET_AUTHORITY_TYPE;
    
    typedef enum _EM_NET_RECORD_TYPE
    {
        NET_RECORD_UNKNOWN,
        
        NET_RECORD_TRAFFICREDLIST,              // Traffic white list account record
        // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure
        // record info corresponding to NET_TRAFFIC_LIST_RECORD structure
        NET_RECORD_TRAFFICBLACKLIST,            // Traffic black list account record
        // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure
        // record info corresponding to NET_TRAFFIC_LIST_RECORD structure
        NET_RECORD_BURN_CASE,                   // burning case record
        // search criteria corresponding to FIND_RECORD_BURN_CASE_CONDITION structure
        // record info corresponding to NET_BURN_CASE_INFO structure
        NET_RECORD_ACCESSCTLCARD,               // access control card
        // search criteria corresponding to FIND_RECORD_ACCESSCTLCARD_CONDITION structure
        // record info corresponding to NET_RECORDSET_ACCESS_CTL_CARD structure
        NET_RECORD_ACCESSCTLPWD,                // access control password
        // search criteria corresponding to FIND_RECORD_ACCESSCTLPWD_CONDITION structure
        // record info corresponding to NET_RECORDSET_ACCESS_CTL_PWD
        NET_RECORD_ACCESSCTLCARDREC,            // access control in/out record
        // search criteria corresponding to FIND_RECORD_ACCESSCTLCARDREC_CONDITION structure
        // record info corresponding to
        NET_RECORD_ACCESSCTLHOLIDAY,            // holiday record set
        // search criteria corresponding to FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION structure
        // record info corresponding to
        NET_RECORD_TRAFFICFLOW_STATE,           // search Traffic flow record
        // search criteria corresponding to FIND_RECORD_TRAFFICFLOW_CONDITION structure
        // record info corresponding to NET_RECORD_TRAFFIC_FLOW_STATE structure
        NET_RECORD_VIDEOTALKLOG,                // call record
        // search criteria corresponding to FIND_RECORD_VIDEO_TALK_LOG_CONDITION structure
        // record info corresponding to NET_RECORD_VIDEO_TALK_LOG structure
        NET_RECORD_REGISTERUSERSTATE,           // status record
        // search criteria corresponding to FIND_RECORD_REGISTER_USER_STATE_CONDITION structure
        // record info corresponding to NET_RECORD_REGISTER_USER_STATE structure
        NET_RECORD_VIDEOTALKCONTACT,            //contact record
        // search criteria corresponding to FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION structure
        // record info corresponding to NET_RECORD_VIDEO_TALK_CONTACT structure
    }EM_NET_RECORD_TYPE;
    
    // time type
    typedef enum
    {
        NET_TIME_TYPE_ABSLUTE,                                  // absolute time
        NET_TIME_TYPE_RELATIVE,                                 // Relative time, relative to the video file header frame as the time basis points, the first frame corresponding to the UTC (0000-00-00 00:00:00)
    }EM_TIME_TYPE;
    
    // color type
    typedef enum
    {
        NET_COLOR_TYPE_RED,                                     // red
        NET_COLOR_TYPE_YELLOW,                                  // yellow
        NET_COLOR_TYPE_GREEN,                                   // green
        NET_COLOR_TYPE_CYAN,                                    // cyan
        NET_COLOR_TYPE_BLUE,                                    // glue
        NET_COLOR_TYPE_PURPLE,                                  // purple
        NET_COLOR_TYPE_BLACK,                                   // black
        NET_COLOR_TYPE_WHITE,                                   // white
        NET_COLOR_TYPE_MAX,
    }EM_COLOR_TYPE;
    
    /////////////////////////////////Face recognition related/////////////////////////////////
    // Personnel type
    typedef enum
    {
        PERSON_TYPE_UNKNOWN,
        PERSON_TYPE_NORMAL,                                     // common person
        PERSON_TYPE_SUSPICION,                                  // Suspects
    }EM_PERSON_TYPE;
    
    // ID type
    typedef enum
    {
        CERTIFICATE_TYPE_UNKNOWN,
        CERTIFICATE_TYPE_IC,                                    // ID
        CERTIFICATE_TYPE_PASSPORT,                              // passport
    }EM_CERTIFICATE_TYPE;
    
    // Face recognition database operations
    typedef enum
    {
        NET_FACERECONGNITIONDB_UNKOWN,
        NET_FACERECONGNITIONDB_ADD,                        // Add personnel information and face samples, if researchers already exists, image data and the original data
        NET_FACERECONGNITIONDB_DELETE,                     // Delete the personnel information and face samples
    }EM_OPERATE_FACERECONGNITIONDB_TYPE;
    
    // Face contrast pattern
    typedef enum
    {
        NET_FACE_COMPARE_MODE_UNKOWN,
        NET_FACE_COMPARE_MODE_NORMAL,                  // normal
        NET_FACE_COMPARE_MODE_AREA,                    // Specify the face region combination area
        NET_FACE_COMPARE_MODE_AUTO,                    // Intelligent model, the algorithm according to the situation of facial regions automatically select combination
    }EM_FACE_COMPARE_MODE;
    
    // Face region
    typedef enum
    {
        NET_FACE_AREA_TYPE_UNKOWN,
        NET_FACE_AREA_TYPE_EYEBROW,                    // eyebrow
        NET_FACE_AREA_TYPE_EYE,                        // eye
        NET_FACE_AREA_TYPE_NOSE,                       // nose
        NET_FACE_AREA_TYPE_MOUTH,                      // mouth
        NET_FACE_AREA_TYPE_CHEEK,                      // face
    }EM_FACE_AREA_TYPE;
    
    // face data type
    typedef enum
    {
        NET_FACE_DB_TYPE_UNKOWN,
        NET_FACE_DB_TYPE_HISTORY,                      // History database, storage is to detect the human face information, usually does not contain face corresponding personnel information
        NET_FACE_DB_TYPE_BLACKLIST,                    // The blacklist database
        NET_FACE_DB_TYPE_WHITELIST,                    // The whitelist database
    }EM_FACE_DB_TYPE;
    
    // Face recognition event type
    typedef enum
    {
        NET_FACERECOGNITION_ALARM_TYPE_UNKOWN,
        NET_FACERECOGNITION_ALARM_TYPE_ALL,                // blacklist and whitelist
        NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST,          // The blacklist
        NET_FACERECOGNITION_ALARM_TYPE_WHITELIST,          // The whitelist
    }EM_FACERECOGNITION_ALARM_TYPE;
    
    // Face recognition face type
    typedef enum
    {
        EM_FACERECOGNITION_FACE_TYPE_UNKOWN,
        EM_FACERECOGNITION_FACE_TYPE_ALL,                  // All the faces
        EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS,          // recognition success
        EM_FACERECOGNITION_FACE_TYPE_REC_FAIL,             // recognition fail
    }EM_FACERECOGNITION_FACE_TYPE;
    
    // Frame type enumeration values
    typedef enum __EM_FRAME_TYPE
    {
        EM_FRAME_UNKOWN,                                   // unknown type
        EM_FRAME_TYPE_MOTION,                              // DM frame, corresponding frame information structure NET MOTION FRAM INFO
    }EM_FRAME_TYPE;
    
    /////////////////////////////////Cancelled Type/////////////////////////////////
    
    // Configuration type. The interface that uses the enumberaiton has been canceled. Please do not use.
    typedef enum _CFG_INDEX
    {
        CFG_GENERAL = 0,							// General
        CFG_COMM,									// COM
        CFG_NET,									// Network
        CFG_RECORD,									// Record
        CFG_CAPTURE,								// Video setup
        CFG_PTZ,									// PTZ
        CFG_DETECT,									// Motion detection
        CFG_ALARM,									// Alarm
        CFG_DISPLAY,								// Display
        CFG_RESERVED,								// Reserved to keet type consecutive
        CFG_TITLE = 10,								// channel title
        CFG_MAIL = 11,								// Mail function
        CFG_EXCAPTURE = 12,							// preview video setup
        CFG_PPPOE = 13,								// pppoe setup
        CFG_DDNS = 14,								// DDNS  setup
        CFG_SNIFFER	= 15,							// Network monitor capture setup
        CFG_DSPINFO	= 16,							// Encode capacity information
        CFG_COLOR = 126,							// Color setup information
        CFG_ALL,									// Reserved
    } CFG_INDEX;
    
    
    /************************************************************************
     ** Structure Definition
     ***********************************************************************/
    //display area relative to the original display area coordinates
    typedef struct
    {
        double				dleft;					//left
        double				dright;					//right
        double				dtop;					//top
        double				dbottom;				//bottom
    } DH_DISPLAYRREGION;
    // Time
    typedef struct
    {
        DWORD				dwYear;					// Year
        DWORD				dwMonth;				// Month
        DWORD				dwDay;					// Date
        DWORD				dwHour;					// Hour
        DWORD				dwMinute;				// Minute
        DWORD				dwSecond;				// Second
    } NET_TIME,*LPNET_TIME;
    
    typedef struct
    {
        DWORD				dwYear;					// Year
        DWORD				dwMonth;				// Month
        DWORD				dwDay;					// Date
        DWORD				dwHour;					// Hour
        DWORD				dwMinute;				// Minute
        DWORD				dwSecond;				// Second
        DWORD               dwMillisecond;          // Millisecond
        DWORD               dwReserved[2];          // reserved
    } NET_TIME_EX,*LPNET_TIME_EX;
    
    // The time definition in the log information
    typedef struct _DHDEVTIME
    {
        DWORD				second		:6;			// Second	1-60
        DWORD				minute		:6;			// Minute	1-60
        DWORD				hour		:5;			// Hour		1-24
        DWORD				day			:5;			// Date		1-31
        DWORD				month		:4;			// Month	1-12
        DWORD				year		:6;			// Year	2000-2063
    } DHDEVTIME, *LPDHDEVTIME;
    
    // callback data(Asynchronous interface)
    typedef struct __NET_CALLBACK_DATA
    {
        int					nResultCode;			// Result code;0:Success
        char				*pBuf;					// Receive data,buffer is opened by the user,from the interface parameters
        int					nRetLen;				// the length of receive data
        LLONG				lOperateHandle;			// Operating handle
        void*				userdata;				// User parameters
        char				reserved[16];
    } NET_CALLBACK_DATA, *LPNET_CALLBACK_DATA;
    
    ///////////////////////////////Monitor Related Definition ///////////////////////////////
    
    // Frame parameter structure of Callback video data frame
    typedef struct _tagVideoFrameParam
    {
        BYTE				encode;					// Encode type
        BYTE				frametype;				// I = 0, P = 1, B = 2...
        BYTE				format;					// PAL - 0, NTSC - 1
        BYTE				size;					// CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
        // SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15,
        DWORD				fourcc;					// If it is H264 encode it is always 0,Fill in FOURCC('X','V','I','D') in MPEG 4;
        DWORD				reserved;				// Reserved
        NET_TIME			struTime;				// Time information
    } tagVideoFrameParam;
    
    // Frame parameter structure of audio data callback
    typedef struct _tagCBPCMDataParam
    {
        BYTE				channels;				// Track amount
        BYTE				samples;				// sample 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
        BYTE				depth;					// Sampling depth. Value:8/16 show directly
        BYTE				param1;					// 0 - indication no symbol,1-indication with symbol
        DWORD				reserved;				// Reserved
    } tagCBPCMDataParam;
    
    // Data structure of channel video title overlay
    typedef struct _DH_CHANNEL_OSDSTRING
    {
        BOOL				bEnable;				// Enable
        DWORD				dwPosition[MAX_STRING_LINE_LEN];//Character position in each line. The value ranges from 1 to 9.Corresponding to the small keyboard.
        //		7upper left 	8upper		9upper right
        //		4left			5middle 	6right
        //		1down left		2down	    3down right
        char				szStrings[MAX_STRING_LINE_LEN][MAX_PER_STRING_LEN];	// Max 6 lines. Each line max 20 bytes.
    } DH_CHANNEL_OSDSTRING;
    
    // Para struct of YUV callback
    typedef struct _tagCBYUVDataParam
    {
        long				nWidth;                 // Width of image
        long				nHeight;				// Height of image
        DWORD				reserved[8];			// reserved
    } tagCBYUVDataParam;
    
    ///////////////////////////////Definition relate with playback///////////////////////////////
    // Type of video search
    typedef enum tagEmQueryRecordType
    {
        EM_RECORD_TYPE_ALL              = 0,            // All the recorded video
        EM_RECORD_TYPE_ALARM            = 1,            // The video of external alarm
        EM_RECORD_TYPE_MOTION_DETECT    = 2,            // The video of dynamic detection alarm
        EM_RECORD_TYPE_ALARM_ALL        = 3,            // All the alarmed video
        EM_RECORD_TYPE_CARD             = 4,            // query by the card number
        EM_RECORD_TYPE_CONDITION        = 5,            // query by condition
        EM_RECORD_TYPE_JOIN             = 6,            //combination query
        EM_RECORD_TYPE_CARD_PICTURE     = 8,            // query pictures by the card number??used by HB-U??NVS
        EM_RECORD_TYPE_PICTURE          = 9,            // query pictures??used by HB-U??NVS
        EM_RECORD_TYPE_FIELD            = 10,           // query by field
        EM_RECORD_TYPE_NET_DATA         = 15,           // query network data??used by Jinqiao Internet Bar
        EM_RECORD_TYPE_TRANS_DATA       = 16,           // query the video of serial data
        EM_RECORD_TYPE_IMPORTANT        = 17,           // query the important video
        EM_RECORD_TYPE_TALK_DATA        = 18,           // query the recording file
        
        EM_RECORD_TYPE_INVALID          = 256,          // invalid query type
        
    }EM_QUERY_RECORD_TYPE;
    
    // Record file information
    typedef struct
    {
        unsigned int		ch;						// Channel number
        char				filename[124];			// File name
        unsigned int        framenum;               // the total number of file frames
        unsigned int		size;					// File length
        NET_TIME			starttime;				// Start time
        NET_TIME			endtime;				// End time
        unsigned int		driveno;				// HDD number
        unsigned int		startcluster;			// Initial cluster number
        BYTE				nRecordFileType;		// Recorded file type  0:general record;1:alarm record ;2:motion detection;3:card number record ;4:image
        BYTE                bImportantRecID;		// 0:general record 1:Important record
        BYTE                bHint;					// Document Indexing
        BYTE                bRecType;               // 0-main stream record 1-sub1 stream record 2-sub2 stream record 3-sub3 stream record
    } NET_RECORDFILE_INFO, *LPNET_RECORDFILE_INFO;
    
    // info of enrichment record file
    typedef struct tagNET_SynopsisFileInfo
    {
        DWORD				dwSize;					// struct size
        char				szFileName[MAX_PATH];	// file name,like :\a.dav
        NET_TIME			stuStartTime;			// start time
        NET_TIME			stuEndTime;				// end time
        unsigned int		nTaskID;				// server mark,with szFileName[] a choise
        BYTE				bFileType;				// 1-record file, 2- source file
        BYTE				byMode;					// Download mode: 0 - by file downloads, 1 - according to the time to download, 2 - according to download file offset
        BYTE				bReserved[2];
        unsigned int		nFileLength;			// file length (byte)
        unsigned int		nStartFileOffset;		// Starting file offset, unit: KB
        unsigned int		nEndFileOffset;			// The end of the file offset, the unit: KB
    }NET_SYNOPSISFILE_INFO, *LPNET_SYNOPSISFILE_INFO;
    
    // Playback data callback function prototype
    typedef int (CALLBACK *fDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);
    
    typedef struct __NET_MULTI_PLAYBACK_PARAM
    {
        DWORD                      dwSize;
        int                        nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM]; // Preview the channel number
        int                        nChannelNum;                         // Preview the channel number
        int                        nType;                               // Playback file type, 0: ordinary video; 1: alarm video; 2: the mobile detection; 3: video card number; Picture 4:
        NET_TIME                   stStartTime;                         // Playback start time
        NET_TIME                   stEndTime;                           // The playback end time
        int                        nFPS;                                // Frame rate, 1 ~ 25
        int                        nBitRate;                            // Code flow values, 192 ~ 1024
        char                       szResolution[DH_MAX_CAPTURE_SIZE_NUM]; // Resolution, "D1", "HD1", "2 CIF", "CIF", "QCIF"
        int                        nWaitTime;                           // Timeout waiting time
        HWND                       hWnd;                                // Video playback window handle
        fDataCallBack              fDownLoadDataCallBack;               // Video data correction
        LDWORD                     dwDataUser;                          //
    }NET_MULTI_PLAYBACK_PARAM;
    
    // record state of everyday in one month
    typedef struct
    {
        BYTE 	    flag[32];						// has record this day 0-no, 1-yes
        BYTE		Reserved[64];					// reserved
    }NET_RECORD_STATUS, *LPNET_RECORD_STATUS;
    
    // Asynchronous query results callback function prototype, nError = 0 means query success, nError = 1 said memory application failure, timeout nError = 2, nError = 3 said equipment return data validation is not through, nError = 4 send query request failed
    typedef void (CALLBACK *fQueryRecordFileCallBack)(LLONG lQueryHandle, LPNET_RECORDFILE_INFO pFileinfos, int nFileNum, int nError, void *pReserved, LDWORD dwUser);
    
    // CLIENT_StartQueryRecordFile Interface input parameters
    typedef struct tagNET_IN_START_QUERY_RECORDFILE
    {
        DWORD               dwSize;                            // The structure size
        int                 nChannelId;                        // To query the channel number
        int                 nRecordFileType;                   // For video query types
        int                 nStreamType;                       // Query stream type, 0 to advocate complementary code stream, 1 - the main stream, 2 - auxiliary stream
        NET_TIME            stStartTime;                       // Query starting time
        NET_TIME            stEndTime;                         // Query the end time
        char*               pchCardid;                         // card id information
        int                 nWaitTime;                         // Timeout waiting time, ms
        fQueryRecordFileCallBack cbFunc;                       // The query results callback function
        LDWORD              dwUser;                            // userinfo
    }NET_IN_START_QUERY_RECORDFILE;
    
    typedef struct tagNET_OUT_START_QUERY_RECORDFILE
    {
        DWORD                dwSize;                           //The structure size
        LLONG                lQueryHandle;                     //return handle
    }NET_OUT_START_QUERY_RECORDFILE;
    
    // Playback process callback function original shape
    typedef void (CALLBACK *fDownLoadPosCallBack)(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, LDWORD dwUser);
    
    // Param in for interface CLIENT_PlayBackByTimeEx2
    typedef struct tagNET_IN_PLAY_BACK_BY_TIME_INFO
    {
        NET_TIME            stStartTime;                       // Begin time
        NET_TIME            stStopTime;                        // End time
        HWND                hWnd;                              // Play window
        fDownLoadPosCallBack cbDownLoadPos;                    // Download pos callback
        LDWORD              dwPosUser;                         // Pos user
        fDataCallBack       fDownLoadDataCallBack;             // Download data callback
        LDWORD              dwDataUser;                        // Data user
        int                 nPlayDirection;                    // Playback direction
        int                 nWaittime;                         // Watiting time
        BYTE                bReserved[1024];                   // Reserved
    }NET_IN_PLAY_BACK_BY_TIME_INFO;
    
    // Param out for interface CLIENT_PlayBackByTimeEx2
    typedef struct tagNET_OUT_PLAY_BACK_BY_TIME_INFO
    {
        BYTE                bReserved[1024];                   // Ô¤Áô×Ö½Ú
    }NET_OUT_PLAY_BACK_BY_TIME_INFO;
    
    typedef struct
    {
        unsigned short      left;                   // 0~8192
        unsigned short      right;                  // 0~8192
        unsigned short      top;                    // 0~8192
        unsigned short      bottom;                 // 0~8192
    } MotionDetectRect;
    
    // Smart Playback Information
    typedef struct
    {
        MotionDetectRect    motion_rect;             // MotionDetect area
        NET_TIME            stime;                   // PlayBack start time
        NET_TIME            etime;                   // PlayBack stop time
        BYTE                bStart;                  // 1,start,2:stop
        BYTE                reserved[116];
    } IntelligentSearchPlay, *LPIntelligentSearchPlay;
    
    // The first recording time
    typedef struct
    {
        int					nChnCount;				// Channel amount
        NET_TIME			stuFurthestTime[16];	// The first recording time, valid value is 0 to (nChnCount-1).If there is no video, the first recording time is 0.
        DWORD				dwFurthestTimeAllSize;	// when channel >16,use this field.means pStuFurthestTimeAll memory size.
        NET_TIME*			pStuFurthestTimeAll;	// when channel >16,use this field.need user apply, memory size(nChnCount*sizeof(NET_TIME)).
        BYTE				bReserved[376];			// Reserved words
    } NET_FURTHEST_RECORD_TIME;
    
    // CLIENT_FindFramInfo Interface input parameters
    typedef struct __NET_IN_FIND_FRAMEINFO_PRAM
    {
        DWORD                 dwSize;               // The structure size
        BOOL                  abFileName;           // Whether the file name as a valid query conditions, if the file name is valid, is don't have to fill the file information (stRecordInfo)
        char                  szFileName[MAX_PATH]; // file name
        NET_RECORDFILE_INFO   stuRecordInfo;        // file information
        DWORD                 dwFramTypeMask;       // Frame type mask, see the "frame type mask defined"
    }NET_IN_FIND_FRAMEINFO_PRAM;
    
    // CLIENT_FindFramInfo Interface input parameters
    typedef struct __NET_OUT_FIND_FRAMEINFO_PRAM
    {
        DWORD                 dwSize;               // The structure size
        LLONG                 lFindHandle;          // File search handle
    }NET_OUT_FIND_FRAMEINFO_PRAM;
    
    // DM frame information
    typedef struct __NET_MOTION_FRAME_INFO
    {
        DWORD                 dwSize;               //  The structure size
        NET_TIME              stuTime;              // The current frame, timestamp
        int					  nMotionRow;		    // The number of rows dynamic detection area
        int					  nMotionCol;		    // The number of columns of dynamic detection area
        BYTE				  byRegion[DH_MOTION_ROW][DH_MOTION_COL];// Detection area, up to 32 * 32 area
    }NET_MOTION_FRAME_INFO;
    
    // file frame information
    typedef struct __NET_FILE_FRAME_INFO
    {
        DWORD                 dwSize;               // The structure size
        int                   nChannelId;           // channel number
        NET_TIME              stuStartTime;         // the starting time
        NET_TIME              stuEndTime;           // the ending time
        WORD                  wRecType;             // 0- main stream video code 1-auxiliary stream video 2 - auxiliary stream 3 auxiliary stream video
        WORD                  wFameType;            // Frame TYPE, see EM FRAM TYPE
        void*                 pFramInfo;            // Corresponding to the type of frame information, the space application by the user
    }NET_FILE_FRAME_INFO;
    
    // CLIENT_FindNextFramInfo Interface input parameters
    typedef struct __NET_IN_FINDNEXT_FRAMEINFO_PRAM
    {
        DWORD                 dwSize;               // The structure size
        int                   nFramCount;           // To query the frame number, 0, said all the frame information query conforms to the query conditions
    }NET_IN_FINDNEXT_FRAMEINFO_PRAM;
    
    // CLIENT_FindNextFramInfo Interface output parameters
    typedef struct __NET_OUT_FINDNEXT_FRAMEINFO_PRAM
    {
        DWORD                 dwSize;               // The structure size
        NET_FILE_FRAME_INFO*   pFramInfos;           // Frame information, by the user application space, the space size of sizeof (.net FILE FRAM INFO) * nMaxFramCount
        int                   nMaxFramCount;        // The number of the frame of information in the user application
        int                   nRetFramCount;        // The actual returns the number of frame information
    }NET_OUT_FINDNEXT_FRAMEINFO_PRAM;
    
    ///////////////////////////////Alarm Related Definition ///////////////////////////////
    
    // General alarm informaiton
    typedef struct
    {
        int					channelcount;
        int					alarminputcount;
        unsigned char		alarm[16];				// External alarm
        unsigned char		motiondection[16];		// Motion detection
        unsigned char		videolost[16];			// Video loss
    } NET_CLIENT_STATE;
    
    // General alarm information
    typedef struct
    {
        int					channelcount;
        int					alarminputcount;
        unsigned char		alarm[32];				// External alarm
        unsigned char		motiondection[32];		// Motion detection
        unsigned char		videolost[32];			// Video loss
        BYTE                bReserved[32];
    } NET_CLIENT_STATE_EX;
    
    // struct of input alarm
    typedef struct
    {
        DWORD              dwSize;
        int				   alarminputcount;
        DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
    }NET_CLIENT_ALARM_STATE;
    
    // struct of video loss alarm
    typedef struct
    {
        DWORD              dwSize;
        int				   channelcount;
        DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
    }NET_CLIENT_VIDEOLOST_STATE;
    
    // struct of motion alarm
    typedef struct
    {
        DWORD              dwSize;
        int				   channelcount;
        DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
    }NET_CLIENT_MOTIONDETECT_STATE;
    
    // struct of blind alarm
    typedef struct
    {
        DWORD              dwSize;
        int				   channelcount;
        DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
    }NET_CLIENT_VIDEOBLIND_STATE;
    
    // struct of querying detailed motion alarm
    typedef struct
    {
        DWORD              dwSize;
        int                nChannelID;				// channel id
        BOOL               bAlarm;					// alarm or not,value is TRUE/FALSE
        int                nLevel;					// alarm level,in 1/1000 as a unit
    }NET_CLIENT_DETAILEDMOTION_STATE;
    
    // Alarm IO control
    typedef struct
    {
        unsigned short		index;					// Port serial number
        unsigned short		state;					// Port status
    } ALARM_CONTROL;
    
    //Activation type
    typedef struct
    {
        unsigned short		index;					// Port serial number
        unsigned short		mode;					// Activation way(0:close.1:manual.2:auto); The SDK reserves the original setup if you do not set channel here.
        BYTE				bReserved[28];
    } TRIGGER_MODE_CONTROL;
    
    // Alarm decoder control
    typedef struct
    {
        int					decoderNo;				// Alarm decoder. It begins from 0.
        unsigned short		alarmChn;				// Alarm output port. It begin from o.,
        unsigned short		alarmState;				// Alarm output status;1:open,0:close.
    } DECODER_ALARM_CONTROL;
    
    // Call No-response Alarm Event
    typedef struct __ALARM_NO_RESPONSE_INFO
    {
        DWORD		dwSize;
        char        szCallID[DH_MAX_CALLID];                             //Call ID
    }ALARM_NO_RESPONSE_INFO;
    
    // Alarm information of alarm upload function
    typedef struct
    {
        DWORD				dwAlarmType;			// Alarm type,when dwAlarmType = DH_UPLOAD_EVENT,dwAlarmMask and bAlarmDecoderIndex are invalid.
        DWORD				dwAlarmMask;			// Alarm information subnet mask. Bit represents each alarm status
        char				szGlobalIP[DH_MAX_IPADDR_LEN];				// Client-end IP address
        char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// Client-end domain name
        int					nPort;					// The port client-end connected when upload alarm
        char				szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// Alarm occurred time
        BYTE				bAlarmDecoderIndex;		// It means which alarm decoder. It is valid when dwAlarmType = DH_UPLOAD_DECODER_ALARM.
        BYTE				bReservedSpace[15];
    } NEW_ALARM_UPLOAD;
    
    // Smoke alarm events, alarm center
    typedef struct __ALARM_UPLOAD_SMOKESENSOR_INFO
    {
        DWORD			dwSize;
        char			szGlobalIP[DH_MAX_IPADDR_LEN];				// Remote IP address
        char			szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// The client domain name
        int				nPort;										// When alarm upload client connection port
        char			szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// The time of the alarm
        int             nChannel;									// Alarm channel Starting from 0
        BYTE            byHighTemperature;							// 1: high temperature alarm, 0: high temperature alarm
        BYTE            bySmoke;									// 1: smoke alarm, 0: smoke alarm over
    }ALARM_UPLOAD_SMOKESENSOR_INFO;
    
    // intelligent alarm center
    typedef struct __ALARM_UPLOAD_IVS_INFO
    {
        DWORD				dwSize;
        NET_TIME			stuTime;                                  // occur time
        char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	  // client domain name
        int					nChannelID;                               // channel,from 0
        char				szType[MAX_PATH];                         // alarm type,check rule
        int					nState;                                   // alarm state, 0-reset,1-setting,2-pulse
        char                szRuleName[DH_COMMON_STRING_128];         // Rule Name
        char                szIPAddress[DH_MAX_IPADDR_LEN_EX];        // Device IP Address
        int                 nPort;                                    // Device Port No.
        char                szMacAddress[DH_MACADDR_LEN];             // Device-end mac address
        char                szPicFilePath[MAX_PATH];                  // Picture Storage Path
        int                 nPicFileNum;                              // Current alarm folder number
        int                 nUploadPicFileNum;                        // Uploaded FTP picture  number
        DWORD               dwChannelMask;                            // Snapshot video channel mask??15 means this alarm has 1,2,3,4 channels
    } ALARM_UPLOAD_IVS_INFO;
    
    // Alarm center external alarm extension info
    typedef struct _ALARM_UPLOAD_ALARMEX_INFO
    {
        DWORD           dwSize;
        NET_TIME        stuTime;                                    // Event time
        char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // Client domain name
        DWORD           dwAlarmMask;                                // Alarm info mask??by bit means each alarm channel status, 7 means 1,2,3 alarm input channel
        char            szDevMac[DH_MACADDR_LEN];                   // Device port mac address
        char            szPicFilePath[MAX_PATH];                    // Picture storage file path
        int             nPicFileNum;                                // Current alarm corresponding picture file quantity
        int             nUploadPicFileNum;                          // Uploaded FTP picture file quantity
        char            szAreaName[DH_COMMON_STRING_128];           // Zone name
        DWORD           dwChannelMask;                              // Snapshot video channel mask??15 means this alarm has 1,2,3,4 channels
    }ALARM_UPLOAD_ALARMEX_INFO;
    
    typedef enum _EM_LOGIN_FAILED_TYPE
    {
        LOGIN_FAILED_UNKNOW = 0 ,
        LOGIN_FAILED_PASSWORD   ,           //Password error
        LOGIN_FAILED_USER       ,           //User error
        LOGIN_FAILED_TIMEOUT    ,           //Time out
        LOGIN_FAILED_RELOGGIN   ,           //Relogin
        LOGIN_FAILED_LOCKED     ,           //Account locked
        LOGIN_FAILED_BLACKLIST  ,           //Account in black list
        LOGIN_FAILED_ERROR_BUSY ,           //Resource is busy
        LOGIN_FAILED_VERSION    ,           //Vesion error
    }EM_LOGIN_FAILED_TYPE;
    
    //Login failed alarm upload
    typedef struct  __ALARM_UPLOAD_LOGIN_FAILED_INFO
    {
        DWORD                   dwSize;
        EM_LOGIN_FAILED_TYPE    emFailedType;                       //Failed type
        char                    szDeviceIP[DH_COMMON_STRING_64];    //Device ip
        DWORD                   nDevicePort;                        //Device port
    }ALARM_UPLOAD_LOGIN_FAILED_INFO;
    
    // Recording-changed alarm information
    typedef struct
    {
        int					nChannel;				// Record channel number
        char				reserved[12];
    } ALARM_RECORDING_CHANGED;
    
#define NET_MAX_WINDINGID_NUM    8
    
    // CoilFault alarm event
    typedef struct __ALARM_WINGDING_INFO
    {
        int                 nDriveWayID;            // road number
        int                 nWindingID;             // coil ID
        NET_TIME            stuTime;                // event happen time
        int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
        DWORD				dwChannel;				// Channel of alarm
        char                reserve[28];
        int                 nWindingIDNum;          // Coil ID number
        int                 nWindingIDs[NET_MAX_WINDINGID_NUM];// Detailed coil ID
    } ALARM_WINGDING_INFO;
    
    // traffic congestion alarm
    typedef struct __ALARM_TRAF_CONGESTION_INFO
    {
        int                 nDriveWayID;            // road number
        int                 nCongestionLevel;       // traffic congestion grade:1,2,3,4,5,6;1 indicate the most one
        NET_TIME            stuTime;                // event happen time
        int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
        DWORD				dwChannel;				// Channel of alarm
        char                reserve[28];
    } ALARM_TRAF_CONGESTION_INFO;
    
    // traffic exception alarm
    typedef struct __ALARM_TRAF_EXCEPTION_INFO
    {
        int                 nDriveWayID;            // road number
        NET_TIME            stuTime;                // event happen time
        int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
        DWORD				dwChannel;				// Channel of alarm
        char                reserve[28];
    } ALARM_TRAF_EXCEPTION_INFO;
    
    // fill equipment alarm
    typedef struct __ALARM_EQUIPMENT_FILL_INFO
    {
        int                 nDriveWayID;            // road number
        NET_TIME            stuTime;                // event happen time
        int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
        DWORD				dwChannel;				// Channel of alarm
        char                reserve[28];
    } ALARM_EQUIPMENT_FILL_INFO;
    
    // alarm arm disarm state info
    typedef struct __ALARM_ARM_DISARM_STATE_INFO
    {
        BYTE                bState;                 // arm-disarm,0 means disarm,1 means arm, 2 means ForceOn
        char                reserve[31];
    } ALARM_ARM_DISARM_STATE_INFO;
    
    // 3G flow exceed state info
    typedef struct __DHDEV_3GFLOW_EXCEED_STATE_INFO
    {
        BYTE                bState;                 //  3G flow exceed state,0 means not exceed,1 means exceed
        char                reserve[31];
    } DHDEV_3GFLOW_EXCEED_STATE_INFO;
    
    // alarm of speed limit (DH_DEVSTATE_SPEED_LIMIT)
    typedef struct __ALARM_SPEED_LIMIT
    {
        char                szType[DH_SPEEDLIMIT_TYPE_LEN];   // alarm type oLowerSpeed, UpperSpeed
        int                 iSpeedLimit;            // limit speed KM/H
        int                 iSpeed;                 // speed KM/H
        char                szCrossingID[DH_MAX_CROSSING_ID]; // crossing ID
        DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
        DWORD				dwLatidude;				// latidude(millionth degree,0-180)
        DHDEVTIME           stTime;                 // time
        BYTE                bOffline;               // 0-in real time,1-to fill
        char				reserve[19];
    }ALARM_SPEED_LIMIT;
    
    // alarm of over loading
    typedef struct __ALARM_OVER_LOADING
    {
        NET_TIME			stuCurTime;             // current time
        DWORD				dwLatidude;				// latidude(millionth degree,0-180)
        DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
        char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
        DWORD				dwCurSpeed;             // current speed
        BYTE				byReserved[128];
    }ALARM_OVER_LOADING;
    
    // alarm of hard braking
    typedef struct __ALARM_HARD_BRAKING
    {
        NET_TIME			stuCurTime;             // current time
        DWORD				dwLatidude;				// latidude(millionth degree,0-180)
        DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
        char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
        DWORD				dwCurSpeed;             // current speed
        BYTE				byReserved[128];
    }ALARM_HARD_BRAKING;
    
    // alarm of smoke sensor
    typedef struct __ALARM_SMOKE_SENSOR
    {
        NET_TIME			stuCurTime;             // current time
        int					nChannel;               // channel
        BYTE				byHighTemperature;      // 1:hight temperature alarm start,0:end
        BYTE				bySmoke;                // 1:smoke alarm start,0:end
        BYTE				byReservrd[126];
    }ALARM_SMOKE_SENSOR;
    
    // alarm of traffic light
    typedef struct _LIGHT_INFO
    {
        BYTE               byDirection;            // direction: 1-left,2-right,3-straight , 4-turn round
        BYTE               byState;                // light state: 1-fault,2-normal
        BYTE               byReserved[62];         // reserved
    }LIGHT_INFO;
    
    typedef struct __ALARM_TRAFFIC_LIGHT_FAULT
    {
        NET_TIME           stTime;                 // alarm time
        int                nInfoNumber;            // info number
        LIGHT_INFO         stLightInfo[8];         // info
        BYTE               byReserved[128];        // reserved
    }ALARM_TRAFFIC_LIGHT_FAULT;
    
    // Flux alarm channel information
    typedef struct __ALARM_TRAFFIC_FLUX_LANE_INFO
    {
        NET_TIME            stuCurTime;            // current time
        int                 nLane;                 // lane number
        int                 nState;                // state:1-traffic jam, 2-traffic jam recover, 3-normal 4-break, 5-break recover
        int                 nFlow;                 // flow value,unit:per/second
        BYTE                byReserved[124];       // reserved
    }ALARM_TRAFFIC_FLUX_LANE_INFO;
    
    // SIP state alarm
    typedef struct __ALARM_SIP_STATE
    {
        int					nChannelID;
        BYTE				byStatus;               //0:succeed,1:unregistered ,2:invalid,3:registing,4:talking
        BYTE				bReserved[63];			//reserved
    }ALARM_SIP_STATE;
    
    // vehicle info uploading (DH_DEVSTATE_VIHICLE_INFO_UPLOAD)
    typedef struct __ALARM_VEHICLE_INFO_UPLOAD
    {
        char                szType[DH_VEHICLE_TYPE_LEN];            //type: DriverCheck ,Driver check in or check out
        char                szCheckInfo[DH_VEHICLE_INFO_LEN];       //Check in, Check out
        char                szDirverNO[DH_VEHICLE_DRIVERNO_LEN];    //Driver NO. string
        DHDEVTIME           stTime;                                      // time
        BYTE                bOffline;                                    // 0-real time 1-to fill
        char                reserved[59];
    }ALARM_VEHICLE_INFO_UPLOAD;
    
    // card record uploading
    typedef struct __ALARM_CARD_RECORD_INFO_UPLOAD
    {
        int					nChannel;				// channel id
        BOOL				bEnable;				// is recording
        char				szCardInfo[DH_MAX_CARD_INFO_LEN];	// card info
        NET_TIME			stuTime;				// card start time
        BOOL                bPreviewOverlayEn;      // preview overlay enable
        BYTE                byOverlayPos;           // overlay position,1-left top,2-left bottom,3-right top,4-right bottom
        char				reserved[59];
    }ALARM_CARD_RECORD_INFO_UPLOAD;
    
    
    typedef enum __ATMTradeTypes{
        TRADE_TYPE_INC = 0,							// INSERTCARD
        TRADE_TYPE_WDC,								// WITHDRAWCARD
        TRADE_TYPE_CKT,								// CHECKTIME
        TRADE_TYPE_INQ,								// Query
        TRADE_TYPE_CWD,								// draw
        TRADE_TYPE_PIN,								// change password
        TRADE_TYPE_TFR,								// debit
        TRADE_TYPE_DEP,								// deposit
        TRADE_TYPE_NCINQ,							// card less query
        TRADE_TYPE_NCDEP,							// card less deposit
        TRADE_TYPE_OTHERS,							// other
        TRADE_TYPE_ALL,								// all
    }DH_eATMTradeTypes;
    
    typedef struct __ALARM_ATM_INFO_UPLOAD_CHNL
    {
        int					nChannel;				// channel
        char				szATMID[32];			// ATM id
        char				szCardNo[32];			// card number, 6222421541208230456
        char				szTradetime[32];		// trade time, 20111118112200 means 2011-11-18 11:22:00
        DH_eATMTradeTypes	emTradeType;			// trade type
        int					nAmount;				// trade mount	0-4294967296
        BYTE				byRerved[32];			// reserved
    }ALARM_ATM_INFO_UPLOAD_CHNL;
    
    // ATM trade info uploading info
    typedef struct __ALARM_ATM_INFO_UPLOAD
    {
        int							nCnt;
        ALARM_ATM_INFO_UPLOAD_CHNL	m_stAtmInfo[DH_MAX_CHANNUM];
    }ALARM_ATM_INFO_UPLOAD;
    
    // camera move alarm
    typedef struct __ALARM_CAMERA_MOVE_INFO
    {
        int                         nChannelNum;                        // the number of alarm channel
        unsigned char               alarmChannels[DH_MAX_CHANNUM_EX];   // the channel information of alarm happened
        BYTE                        byReserved[128];
    }ALARM_CAMERA_MOVE_INFO;
    
    // detailed motion alarm
    typedef struct __ALARM_DETAILEDMOTION_CHNL_INFO
    {
        DWORD              dwSize;
        int                nChannelID;    // channel
        BOOL               bAlarm;        // alarm or not,value is TRUE/FALSE
        int                nLevel;        // alarm level,in 1/1000 as a unit
    }ALARM_DETAILEDMOTION_CHNL_INFO;
    
    // storage failure alarm info
    typedef struct __ALARM_STORAGE_FAILURE
    {
        DWORD     dwSize;                                     // struct size
        UINT      ActionType;                                 // 0:stop 1:start
        char      szProtocol[DH_MAX_STRING_LEN];              // protocol type
        char      szServerAddr[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // server device's ip
        DWORD     dwPort;                                     // port number
        NET_TIME  stuTime;                                    // event happen time
        int		  nChannel;									  // channel, from 1, 0 means does not distinguish
    }ALARM_STORAGE_FAILURE;
    
    // front IPC disconnect alarm info
    typedef struct __ALARM_FRONTDISCONNET_INFO
    {
        DWORD              dwSize;                           // struct size
        int                nChannelID;                       // channel id
        int                nAction;                          // 0:stop 1:start
        NET_TIME           stuTime;                          // event happen time
        char               szIpAddress[MAX_PATH];            // front IP's address
    }ALARM_FRONTDISCONNET_INFO;
    
    // battery low power alarm info
    typedef struct __ALARM_BATTERYLOWPOWER_INFO
    {
        DWORD             dwSize;                            // struct size
        int               nAction;                           // 0:stop 1:start
        int               nBatteryLeft;                      // battery left, unit:%
        NET_TIME          stTime;                            // event happen time
        
    }ALARM_BATTERYLOWPOWER_INFO;
    
    // temperature alarm info
    typedef struct __ALARM_TEMPERATURE_INFO
    {
        DWORD              dwSize;                           // struct size
        char               szSensorName[DH_MACHINE_NAME_NUM];// sensor name
        int                nChannelID;                       // channel id
        int                nAction;                          // 0:stop 1:start
        float              fTemperature;                     // current temperature, unit:degree centigrade
        NET_TIME           stTime;                           // event happen time
    }ALARM_TEMPERATURE_INFO;
    
    // Fatigue Driving Alarm
    typedef struct __ALARM_TIREDDRIVE_INFO
    {
        DWORD             dwSize;                            // struct size
        int               nAction;                           // 0:stop 1:start
        int               nDriveTime;                        // drive time, unit:minute
        NET_TIME          stTime;                            // event happen time
    }ALARM_TIREDDRIVE_INFO;
    
    //Alarm of record loss
    typedef struct __ALARM_LOST_RECORD
    {
        DWORD     dwSize;                                     //Structure size
        UINT      ActionType;                                 // 0: Stop, 1: start
        UINT      nChannelID;                                 // Channel ID, start from 1
        UINT      nStreamType;                                // Bit Stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
        NET_TIME  stuTime;                                    // Event occurrence time
    }ALARM_LOST_RECORD;
    
    // Alarm of High CPU Occupancy rate, temporarily we set the max limit as 95%
    typedef struct __ALARM_HIGH_CPU
    {
        DWORD     dwSize;                                     //Structure size
        UINT      ActionType;                                 // 0: Stop, 1: start
        UINT      nUsed;                                      // 1000 times of  CPU Occupancy rate
        NET_TIME  stuTime;                                    // Event occurrence time
    }ALARM_HIGH_CPU;
    
    
    // Alarm of netpackage loss
    typedef struct __ALARM_LOST_NETPACKET
    {
        DWORD     dwSize;                                     //Structure size
        UINT      ActionType;                                 //0: Stop, 1: start
        UINT      nChannelID;                                 // Channel ID, start from 1
        UINT      nStreamType;                                // Bit stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
        char      szRemoteIP[DH_MAX_IPADDR_LEN];              // IP address of sending
        DWORD     dwRemotePort;                               // Port address of sending
        NET_TIME  stuTime;                                    // Event occurrence time
    }ALARM_LOST_NETPACKET;
    
    // Alarm of High memory Occupancy rate, temporarily we set the max limit as 95%
    typedef struct __ALARM_HIGH_MEMORY
    {
        DWORD     dwSize;                                     //Structure size
        UINT      ActionType;                                 // 0: Stop, 1: start
        UINT      nUsed;                                      // 1000 times of  memory Occupancy rate
        NET_TIME  stuTime;                                    // Event occurrence time
    }ALARM_HIGH_MEMORY;
    
    // black list snap info
    typedef struct __DH_BLACKLIST_SNAP_INFO
    {
        DWORD     dwSize;
        char      szPlateNumber[32];                          // number of plate
        NET_TIME  stuTime;                                    // time
    }DH_BLACKLIST_SNAP_INFO;
    
    // disk flux abnormal
    typedef struct __ALARM_DISK_FLUX
    {
        DWORD				dwSize;
        DWORD				dwAction;							// 0-start, 1-stop
        DWORD				dwDataFlux;							// data flux,KB
        NET_TIME			stuTime;							// time
    } ALARM_DISK_FLUX;
    
    // net flux abnormal
    typedef struct __ALARM_NET_FLUX
    {
        DWORD				dwSize;
        DWORD				dwAction;							// 0-start, 1-stop
        DWORD				dwDataFlux;							// data flux,KB
        NET_TIME			stuTime;							// time
    } ALARM_NET_FLUX;
    
    // fan speed abnormal
    typedef struct __ALARM_FAN_SPEED
    {
        DWORD				dwSize;
        DWORD				dwAction;							// 0-start, 1-stop
        DWORD				dwIndex;							// index
        char				szName[DH_MACHINE_NAME_NUM];		// name
        NET_TIME			stuTime;							// time
        DWORD				dwCurrent;							// current speed
    } ALARM_FAN_SPEED;
    
    // disk alarm
    typedef struct __ALARM_DISK_INFO
    {
        DWORD				dwSize;
        DWORD				nChannel;							// channel number
        DWORD				nHDDNumber;							// number, 0: main trank,1: extern trank1, 2: extern trank2
        DWORD				nHDDState;							// state, 0: Unknown, 1: Running, 2: Offline, 3: Warning, 4: Failed
    } ALARM_DISK_INFO;
    
    // alarm of file system
    typedef struct __ALARM_FILE_SYSTEM_INFO
    {
        DWORD				dwSize;
        char				szMountDir[MAX_PATH];				// mount name
        DWORD				nState;								// state, 0: Unkown, 1: Normal, 2: Error
    } ALARM_FILE_SYSTEM_INFO;
    
    // alarm of remote
    typedef struct __ALARM_REMOTE_ALARM_INFO
    {
        DWORD      dwSize;
        int        nChannelID;                               // channel ID,from 1
        int        nState;                                   // state,0-reset,1-setting
    }ALARM_REMOTE_ALARM_INFO;
    
    // alarm of ivs
    typedef struct __ALARM_IVS_INFO
    {
        DWORD      dwSize;
        NET_TIME   stuTime;                                  // time
        int        nChannelID;                               // channel ID,from 0
        char	   szType[MAX_PATH];                         // type
        int        nState;                                   // state,0-reset,1-setting,2-pulse
    }ALARM_IVS_INFO;
    
    // alarm of good weight
    typedef struct __ALARM_GOODS_WEIGHT_INFO
    {
        DWORD		dwSize;
        int			nAction;							// 0-start, 1-stop
        int			nAlarmType;							// 0-greater than dwMaxGoodsWeight, 1-less than dwMinGoodsWeight, 2-the change greater than dwAlarmWeight
        DWORD		dwGoodsWeight;						// good weight(kg)
        DWORD		dwSelfWeight;						// self weight(kg)
        DWORD		dwTotalWeight;						// total weight(kg)
        DWORD		dwStandardWeight;					// standard weight(kg)
        DWORD		dwWeightScale;						// weight scale
        DWORD		dwMaxGoodsWeight;					// the max(kg)
        DWORD		dwMinGoodsWeight;					// the min(kg)
        DWORD		dwAlarmWeight;						// alarm of threshold(kg)
        int			nWeightChange;						// whight change when gather(kg)
        int			nCheckTime;							// gather time(s)
    } ALARM_GOODS_WEIGHT_INFO;
    
    // goods weight upload
    typedef struct __ALARM_GOODS_WEIGHT_UPLOAD_INFO
    {
        DWORD		dwSize;
        DWORD		dwGoodsWeight;						// goods weight(kg)
        DWORD		dwSelfWeight;						// self weight(kg)
        DWORD		dwTotalWeight;						// total weight(kg)
        DWORD		dwStandardWeight;					// standard weight(kg)
        DWORD		dwWeightScale;						// weight scale
        char        szCardNO[DH_MAX_CARDINFO_LEN];      //card number
    } ALARM_GOODS_WEIGHT_UPLOAD_INFO;
    
    // GPS status info
    typedef struct _NET_GPS_STATUS_INFO
    {
        NET_TIME                revTime;				    // time
        char                    DvrSerial[50];			    // device number
        double                  longitude;				    // longitude(1/1000000,range[0-360])
        double                  latidude;				    // latitude(1/1000000,range[0-180])
        double                  height;					    // highness(m)
        double                  angle;					    // angle(north is source point,clockwise is positive)
        double                  speed;					    // speed(sea mile,speed/1000*1.852km/h)
        WORD                    starCount;				    // star count
        NET_THREE_STATUS_BOOL   antennaState;			    // antenna state(true good, false bad)
        NET_THREE_STATUS_BOOL   orientationState;		    // orientation state(true orientation, false not)
        int                     workStae;                   // working state(true normal, false abnormity)
        
        int                     nAlarmCount;                 // alarm count
        int                     nAlarmState[128];            // alarm type
        BYTE                    bOffline;                    // 0- real time 1-fill
        BYTE                    byRserved[127];              // reserve
    } NET_GPS_STATUS_INFO,*LPNET_GPS_STATUS_INFO;
    
    // alarm of disk burned full
    typedef struct __ALARM_DISKBURNED_FULL_INFO
    {
        DWORD		dwSize;
        int         nIndex;                             //index
    }ALARM_DISKBURNED_FULL_INFO;
    
    // alarm of storage low space
    typedef struct tagALARM_STORAGE_LOW_SPACE_INFO
    {
        DWORD				dwSize;
        int					nAction;						// 0:start 2:stop
        char				szName[DH_EVENT_NAME_LEN];		// name
        char				szDevice[DH_STORAGE_NAME_LEN];	// device name
        char				szGroup[DH_STORAGE_NAME_LEN];	// group name
        INT64				nTotalSpace;					// total space byte
        INT64				nFreeSpace;						// free space byte
        int					nPercent;						// used percent
    } ALARM_STORAGE_LOW_SPACE_INFO;
    
    // storage error
    typedef enum __EM_STORAGE_ERROR
    {
        STORAGE_ERROR_NONE,							// no error
        STORAGE_ERROR_PATITION,						// patition error
        STORAGE_ERROR_INIT_FS,						// init system file error
        STORAGE_ERROR_READ_DATA,					// read data error
        STORAGE_ERROR_WRITE_DATA,					// write data error
        STORAGE_ERROR_RAID_FAILED,					// RAID error
        STORAGE_ERROR_RAID_DEGRADED,				// RAID degranded
        STORAGE_ERROR_ISCSI_FAILED,                     // iSCSI error
    } EM_STORAGE_ERROR;
    
    // alarm of storage failure
    typedef struct __ALARM_STORAGE_FAILURE_EX
    {
        DWORD				dwSize;
        int					nAction;						// 0:start 1:stop
        char				szName[DH_EVENT_NAME_LEN];		// name
        char				szDevice[DH_STORAGE_NAME_LEN];	// device name
        char				szGroup[DH_STORAGE_NAME_LEN];	// group name
        char				szPath[MAX_PATH];				// path
        EM_STORAGE_ERROR	emError;						// error type
    } ALARM_STORAGE_FAILURE_EX;
    
    // alarm of record failed
    typedef struct __ALARM_RECORD_FAILED_INFO
    {
        DWORD				dwSize;
        int					nAction;						// 0:start 1:stop
        int					nIndex;							// index
    } ALARM_RECORD_FAILED_INFO;
    
    // storage break down
    typedef struct __ALARM_STORAGE_BREAK_DOWN_INFO
    {
        DWORD				dwSize;
        int					nAction;						// 0:start 1:stop
    } ALARM_STORAGE_BREAK_DOWN_INFO;
    
    typedef enum tagEM_NET_UPS_STATUS
    {
        EM_NET_UPS_SYS_SIGN=0	 	,	//System temperature the sign bit. 1: negative temperature; 0:positive temperature
        EM_NET_UPS_SYS_SHUTDOWN 	,	//System shutdown. 1: shutdown activated state
        EM_NET_UPS_SYS_TEST 		,	//System tests. 1: said tests
        EM_NET_UPS_SYS_TYPE 		,	//UPS type. 1: backup machine; 0: said online machine
        EM_NET_UPS_SYS_FAULT 		,	//UPS fault. 1: UPS internal fault; Zero: normal
        EM_NET_UPS_ELE_SUPPLY 		,	//The bypass/inverter state. 1: AC power supply; 0: batteries
        EM_NET_UPS_VOL_LOW 			,	//Low battery voltage. 1: low battery voltage; Zero: it means the battery is normal
        EM_NET_UPS_BYPASS_STATUS	,	//Mains failure. 1: mains failure; Zero: it means the mains is normal
        EM_NET_UPS_MAX = 64			,	//
    }EM_NET_UPS_STATUS;
    
    typedef struct tagNET_UPS_INFO
    {
        DWORD dwSize;
        float fInputVoltage;						//Specific reference input voltage intelligent transportation special power communication protocol (V1.2), blue shield special definition
        float fInputAbnormalVoltage;				//Abnormal input voltage
        float fOutputVoltage;						//output voltage
        float fOutputCurrent;						//Output current percentage, the unit (%)
        float fInputFrequency;						//incoming frequency
        float fVoltage;								//voltage
        float fTemp;								// temperature
        BYTE  bStatusInfo[EM_NET_UPS_MAX];			//Set UPS STATUS, see.net UPS STATUS enumeration
        char  szVersionInfo[DH_MAX_VERSION_STR];	//version
    }NET_UPS_INFO;
    
    typedef struct tagALARM_COMM_PORT_EVENT_INFO
    {
        DWORD           dwSize;
        UINT      		nEventAction;	// Event Action??0=Impulse Event,1=Begin a Continued Event,2=the Event End;
        NET_UPS_INFO	stUPSInfo;		// UPS's COM Information
    }ALARM_COMM_PORT_EVENT_INFO;
    
    // ininvalid of video input channel(example:)DH_ALARM_VIDEO_ININVALID
    typedef struct __ALARM_VIDEO_ININVALID_INFO
    {
        DWORD               dwSize;                         // struct size
        int                 nChannelID;                     // channel ID,from 0
    } ALARM_VIDEO_ININVALID_INFO;
    
    
    // No Information of Event in Storage Group
    typedef struct tagALARM_STORAGE_NOT_EXIST_INFO
    {
        DWORD			dwSize;
        char			szName[DH_EVENT_NAME_LEN];		// Event Name
        char			szDevice[DH_STORAGE_NAME_LEN];	// Storage Device Name
        char			szGroup[DH_STORAGE_NAME_LEN];	// Storage Droup Name
        NET_TIME		stuTime;						// the Time of Event triggering)
    }ALARM_STORAGE_NOT_EXIST_INFO;
    
    //the Type of Network Fault Event)
    typedef enum __EM_NETABORT_EVENT_TYPE
    {
        EM_NETABORT_EVENT_TYPE_WIRE = 0,				// Wired Network Fault Event
        EM_NETABORT_EVENT_TYPE_WIRELESS,				// Wireless Network Fault Event
        EM_NETABORT_EVENT_TYPE_3G,						//3G Network Fault Event
    }EM_NETABORT_EVENT_TYPE;
    
    // Network Fault Event
    typedef struct tagALARM_NETABORT_INFO
    {
        DWORD			dwSize;
        int				nAction;						//0=Start 1=Stop
        EM_NETABORT_EVENT_TYPE	emNetAbortType;			// Event Type
        NET_TIME		stuTime;						// Event Triggering Time
    }ALARM_NETABORT_INFO;
    
    // IP Clash Event
    typedef struct tagALARM_IP_CONFLICT_INFO
    {
        DWORD			dwSize;
        int				nAction;						//0=Start 1=Stop
        NET_TIME		stuTime;						// Event Triggering Time)
    }ALARM_IP_CONFLICT_INFO;
    
    
    // MAC Clash Evnet)
    typedef struct tagALARM_MAC_CONFLICT_INFO
    {
        DWORD			dwSize;
        int				nAction;						// 0=Start 1=Stop
        NET_TIME		stuTime;						// Event Triggering Time
    }ALARM_MAC_CONFLICT_INFO;
    
    
    // Power Type
    typedef enum __EM_POWER_TYPE
    {
        EM_POWER_TYPE_MAIN = 0,							// Main Power
        EM_POWER_TYPE_BACKUP,							// Spare Power
    }EM_POWER_TYPE;
    
    // the Type of Power Fault Event
    typedef enum __EM_POWERFAULT_EVENT_TYPE
    {
        EM_POWERFAULT_EVENT_LOST = 0					// Power Down
    }EM_POWERFAULT_EVENT_TYPE;
    
    // Power Fault Event
    typedef struct tagALARM_POWERFAULT_INFO
    {
        DWORD					dwSize;
        EM_POWER_TYPE			emPowerType;			// Power Type
        EM_POWERFAULT_EVENT_TYPE	emPowerFaultEvent;	// Power Fault Event
        NET_TIME				stuTime;				// Alarm Event Begin Time
        int						nAction;				// 0=Start 1=Stop
    }ALARM_POWERFAULT_INFO;
    
    // Tamper Alarm Event
    typedef struct tagALARM_CHASSISINTRUDED_INFO
    {
        DWORD				dwSize;
        int					nAction;				//  0=Start 1=Stop
        NET_TIME			stuTime;				// Alarm Event Begin Time
        int                 nChannelID;             // Channel ID
        char				szReaderID[DH_COMMON_STRING_32];// Reader ID
    }ALARM_CHASSISINTRUDED_INFO;
    
    // Expand Module Alarm Event
    typedef struct tagALARM_ALARMEXTENDED_INFO
    {
        DWORD				dwSize;
        int                 nChannelID;             //  Channel ID
        int					nAction;				// 0=Start 1=Stop (1=stop)
        NET_TIME			stuTime;				//  Alarm Event Begin Time
    }ALARM_ALARMEXTENDED_INFO;
    
    
    // Interphone's Initiator
    typedef enum __EM_TALKING_CALLER
    {
        EM_TALKING_CALLER_UNKNOWN = 0,				// Uunbeknown Initiator
        EM_TALKING_CALLER_PLATFORM,					//Interphone's initiator is Platform
    }EM_TALKING_CALLER;
    
    // Alarm Event TypeDH_ALARM_TALKING_INVITE Device ask Other Side InitiateInterphone Event )Corresponding Data Description Information
    typedef struct tagALARM_TALKING_INVITE_INFO
    {
        DWORD                dwSize;
        EM_TALKING_CALLER    emCaller;                      // Interphone's Initiator is Device Desired
        NET_TIME             stuTime;                       // Event Triggering Time
        char                 szCallID[DH_COMMON_STRING_64];	// Unique ID for calling
    }ALARM_TALKING_INVITE_INFO;
    
    // Alarm Event Type DH_ALARM_TALKING_HANGUP corresponding data description
    typedef struct tagALARM_TALKING_HANGUP_INFO
    {
        DWORD               dwSize;
        NET_TIME            stuTime;                // Event trigger time
    }ALARM_TALKING_HANGUP_INFO;
    
    // Station Update Event Status
    typedef enum tagEM_GUARD_EVENT_STATE
    {
        EM_GUARD_EVENT_STATE_UNKNOWN = 0,	// unknown status
        EM_GUARD_EVNET_STATE_ONGUARD,		// on guard
        EM_GUARD_EVENT_STATE_OFFGUARD		// off guard
    }EM_GUARD_EVENT_STATE;
    
    // station info update event ,DH_ALARM_GUARD_INFO_UNPDATE data description info
    typedef struct tagALARM_GUARD_UPDATE_INFO
    {
        DWORD				 dwSize;
        EM_GUARD_EVENT_STATE emEventState;							// station update event status
        int					 nIDCount;								// trigger detection event staff ID number
        int					 nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];// staff ID group
        NET_TIME			 stuTime;								// event trigger time
    }ALARM_GUARD_UPDATE_INFO;
    
    // station detection event ,DH_ALARM_GUARD_DETECTcorresponding to data description info
    typedef struct tagALARM_GUARD_DETECT_INFO
    {
        DWORD				dwSize;
        int					nAction;								// 0: start 1: stop
        int					nIndex;									// station detection config mark
        int					nIDCount;								// trigger detection event staff ID number
        int					nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];	// staff ID group number
        NET_TIME			stuTime;								// event trigger time
    }ALARM_GUARD_DETECT_INFO;
    
    //Bank card event DH_ALARM_BANKCARDINSERT corresponding data info
    typedef struct tagALARM_BANKCARDINSERT_INFO
    {
        DWORD               dwSize;
        int                 nAction;                // -1:unknown 0: start 1:stop
    }ALARM_BANKCARDINSERT_INFO;
    
#define MAX_CARD_RECORD_FIELD_NUM 16            // card no. max domain quantity
    
    // event trigger record,stop storage strategy
    typedef enum tagNET_RECORD_SAVEFLAG
    {
        NET_RECORD_SAVEFLAG_UNKNOWN = 0,            //unknown type
        NET_RECORD_SAVEFLAG_MARK,                   //save record and lock
        NET_RECORD_SAVEFLAG_SAVE,                   //only save record
    }NET_RECORD_SAVEFLAG;
    
    //card no. record event DH_ALARM_CARD_RECORD corresponding to group decryption info
    typedef struct tagALARM_CARD_RECORD_INFO
    {
        DWORD               dwSize;
        int                 nAction;                // -1:unknown 0:start 1:stop
        int                 nChannelID;             // channel no.??from 0
        unsigned int        nFieldCount;            // domain quantity
        char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256]; // domain info
        NET_RECORD_SAVEFLAG emRecordSaveFlag;       // event trigger record??stop storage strategy ,see  NET_RECORD_SAVEFLAG
    }ALARM_CARD_RECORD_INFO;
    
    // CLIENT_ControlDevice port DH_CTRL_NOTIFY_EVNENT command parameter(send event to device)
    typedef struct tagNET_NOTIFY_EVENT_DATA
    {
        DWORD                       dwSize;
        LONG                        lCommand;       // event type
        void*                       pEventData;     // event content,and lCommandcorresponding to structure indicator
    }NET_NOTIFY_EVENT_DATA;
    
    // Sensor's Sense Method Enumeration Type
    typedef enum tagNET_SENSE_METHOD
    {
        NET_SENSE_UNKNOWN = -1,		//Unknowed type
        NET_SENSE_DOOR=0,			//Door Contact
        NET_SENSE_PASSIVEINFRA,		//Passive Infrared
        NET_SENSE_GAS,				//Gase Induce)
        NET_SENSE_SMOKING,			//Smoking Induce
        NET_SENSE_WATER,			//Wwater Induce)
        NET_SENSE_ACTIVEFRA,		//Initiative Infrared
        NET_SENSE_GLASS,			//Glass Broken
        NET_SENSE_EMERGENCYSWITCH,	//Emergency switch
        NET_SENSE_SHOCK,			//Shock
        NET_SENSE_DOUBLEMETHOD,		//Double Method(Infrare+Microwave)
        NET_SENSE_THREEMETHOD,		//Three Method
        NET_SENSE_TEMP,				//Temperature
        NET_SENSE_HUMIDITY,			//Humidity
        NET_SENSE_WIND,             //Wind
        NET_SENSE_CALLBUTTON,		//Call button
        NET_SENSE_GASPRESSURE,      //Gas Pressure
        NET_SENSE_GASCONCENTRATION, //Gas Concentration
        NET_SENSE_GASFLOW,          //Gas Flow
        NET_SENSE_OTHER,			//Other
        NET_SENSE_OIL,              //oil detection??gasoline, diesel vehicles detection
        NET_SENSE_MILEAGE,          //mileage detection
        NET_SENSE_URGENCYBUTTON,    //Urgency button
        NET_SENSE_STEAL,            //Steal
        NET_SENSE_PERIMETER,        //Permeter
        NET_SENSE_PREVENTREMOVE,    //Prevent remove
        NET_SENSE_DOORBELL,         //Door bell
        NET_SENSE_ALTERVOLT,        //Alter voltage sensor
        NET_SENSE_DIRECTVOLT,       //Direct voltage sensor
        NET_SENSE_ALTERCUR,         //Alter current sensor
        NET_SENSE_DIRECTCUR,        //Direct current sensor
        NET_SENSE_RSUGENERAL,       //RSU general analog sensor, 4~20mA or 0~5V
        NET_SENSE_RSUDOOR,          //RSU door sensor
        NET_SENSE_RSUPOWEROFF,      //RSU power off sensor
        NET_SENSE_TEMP1500 ,        //1500 temperature sensor
        NET_SENSE_TEMPDS18B20 ,     //DS18B20 temperature sensor
        NET_SENSE_HUMIDITY1500,     //1500 humidity sensor
        NET_SENSE_NUM,				//Number of enumeration type
    }NET_SENSE_METHOD;
    
    // Local Alarm Event (DH_ALARM_ALARM_EX Update
    typedef struct tagALARM_ALARM_INFO_EX2
    {
        DWORD		dwSize;
        int			nChannelID;             // Channel ID
        int			nAction;				// 0=Start 1=Stop
        NET_TIME	stuTime;				// Alarm Event Begin Time
        NET_SENSE_METHOD emSenseType;		// The Sensor's Type
    }ALARM_ALARM_INFO_EX2;
    
    // Protect/Cancel Protect Mode
    typedef enum tagNET_ALARM_MODE
    {
        NET_ALARM_MODE_UNKNOWN = -1,	// Unknown
        NET_ALARM_MODE_DISARMING,		// Cancel Protect
        NET_ALARM_MODE_ARMING,			// Install protect
        NET_ALARM_MODE_FORCEON,			// Forceon protect
    }NET_ALARM_MODE;
    
    // Arm/Disarm scene mode
    typedef enum tagNET_SCENE_MODE
    {
        NET_SCENE_MODE_UNKNOWN,			// Unknown scene
        NET_SCENE_MODE_OUTDOOR,			// Outdoor mode
        NET_SCENE_MODE_INDOOR,			// Inner mode
        NET_SCENE_MODE_WHOLE,           // global mode
        NET_SCENE_MODE_RIGHTNOW,        // immediate mode
    }NET_SCENE_MODE;
    
    // trigger mode
    typedef enum tagNET_EM_TRIGGER_MODE
    {
        NET_EM_TRIGGER_MODE_UNKNOWN = 0,
        NET_EM_TRIGGER_MODE_NET,            // Network user(Platform?¨°Web)
        NET_EM_TRIGGER_MODE_KEYBOARD,       // keyboard
        NET_EM_TRIGGER_MODE_REMOTECONTROL,  // remote control
    }NET_EM_TRIGGER_MODE;
    
    // Protect Transformate Event's Information
    typedef struct tagALARM_ARMMODE_CHANGE_INFO
    {
        DWORD				dwSize;
        NET_TIME			stuTime;			// Alarm Event Begin Time
        NET_ALARM_MODE		bArm;				// Statue of Transformated
        NET_SCENE_MODE		emSceneMode;		// ContextualMode
        DWORD               dwID;               // ID number, remote control number or keypad address, emTriggerMode=0 when  belong to NET_EM_TRIGGER_MODE_NET
        NET_EM_TRIGGER_MODE emTriggerMode;      // trigger mode
    }ALARM_ARMMODE_CHANGE_INFO;
    
    // defence zone type
    typedef enum
    {
        NET_DEFENCEAREA_TYPE_UNKNOWN,		//Unknown Type Defence Area
        NET_DEFENCEAREA_TYPE_ALARM,			// Switching Value Defence Area
    }NET_DEFENCEAREA_TYPE;
    
    // Bypass Statue Type
    typedef enum
    {
        NET_BYPASS_MODE_UNKNOW,			//UnknownBypass Statue
        NET_BYPASS_MODE_BYPASS,			//Bypass
        NET_BYPASS_MODE_NORMAL,			//Normal
        NET_BYPASS_MODE_ISOLATED,		//Isolated
    }NET_BYPASS_MODE;
    
    // The Information of Bypass's Statue Change Event
    typedef struct tagALARM_BYPASSMODE_CHANGE_INFO
    {
        DWORD                   dwSize;
        int	                    nChannelID;                 // Channel ID
        NET_TIME                stuTime;                    // Alarm Event Begin Time
        NET_DEFENCEAREA_TYPE    emDefenceType;              // Defence Area Type
        int                     nIsExtend;                  // Whether or not It Is Expand?¡§Channel??Defence Area ??1=Expand Channel??0=Non Expand Channel)
        NET_BYPASS_MODE	        emMode;	                    // Changed Mode
        DWORD                   dwID;                       // ID number, remote control number or keypad address, emTriggerMode=0 when belong to NET_EM_TRIGGER_MODE_NET
        NET_EM_TRIGGER_MODE     emTriggerMode;              // trigger mode
    }ALARM_BYPASSMODE_CHANGE_INFO;
    
    
    // Emergency Event?¡§Correspond DH_URGENCY_ALARM_EX2,DH_URGENCY_ALARM_EX Update??That is Artificially Triggered Emergency,General Treatment is Linkage External Communications Functions for Help??
    typedef struct tagALARM_URGENCY_ALARM_EX2
    {
        DWORD		dwSize;
        NET_TIME	stuTime;			//Event Begin Time
        DWORD           nID;                         // used to mark different emergency event
    }ALARM_URGENCY_ALARM_EX2;
    
    // Alarm Input Source Event Details(As Long As There Will Have to Change The Input Event, Regardless of the Current Mode of The Defence Zone Can not be Shielded)
    typedef struct tagALARM_INPUT_SOURCE_SIGNAL_INFO
    {
        DWORD		dwSize;
        int			nChannelID;             // Channel ID
        int			nAction;				//0=Start 1=Stop
        NET_TIME	stuTime;				// Alarm Event Begin Time
    }ALARM_INPUT_SOURCE_SIGNAL_INFO;
    
    // Analog Input Channel Alarm Event Information(Corresponding DH_ALARM_ANALOGALARM_EVENT)??
    typedef struct tagALARM_ANALOGALARM_EVENT_INFO
    {
        DWORD		dwSize;
        int			nChannelID;             // Alarm Event Begin Time
        int			nAction;				// 0=Start 1=Stop
        NET_TIME	stuTime;				//  Alarm Event Begin Time
        NET_SENSE_METHOD	emSensorType;	// the Sensor's Type
        char		szName[DH_COMMON_STRING_128];	// Channel Name
        int             nIsValid;                           // Data is valid or not,-1: unknown,0:invalid,1:valid
        int             nStatus;                            // Data status, -1: unknown,0:noemal,1:invalid data(over limit),
        // 2:over threshold value1,3: over threshold value 2,4: over threshold value 3,5: over threshold value 4,
        // 6:below threshold value 1,7: below threshold value2,8: below threshold value3,9: below threshold value4
        float           fValue;                             // Detector value
        NET_TIME        stuCollectTime;                     // Data collection time(UTC)
        NET_GPS_STATUS_INFO stGPSStatus;                    // GPS status
    }ALARM_ANALOGALARM_EVENT_INFO;
    
    
    // Access Control Status Type
    typedef enum tagNET_ACCESS_CTL_STATUS_TYPE
    {
        NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN = 0,
        NET_ACCESS_CTL_STATUS_TYPE_OPEN,		// Open
        NET_ACCESS_CTL_STATUS_TYPE_CLOSE,		// Close
    }NET_ACCESS_CTL_STATUS_TYPE;
    
    // Access control status event
    typedef struct tagALARM_ACCESS_CTL_STATUS_INFO
    {
        DWORD		dwSize;
        int			nDoor;						// Door channel no.
        NET_TIME	stuTime;					// Event time
        NET_ACCESS_CTL_STATUS_TYPE	emStatus;	// Access control status
    }ALARM_ACCESS_CTL_STATUS_INFO;
    
    // Access Control Snapshot Type
    typedef enum tagNET_ACCESS_SNAP_TYPE
    {
        NET_ACCESS_SNAP_TYPE_UNKNOWN = 0,
        NET_ACCESS_SNAP_TYPE_CARD,                          // Swipe
        NET_ACCESS_SNAP_TYPE_PASSWORD,                      // Password
    }NET_ACCESS_SNAP_TYPE;
    
    // Access Control Snapshot Event
    typedef struct tagALARM_ACCESS_SNAP_INFO
    {
        DWORD           dwSize;
        NET_ACCESS_SNAP_TYPE emType;                        // Type
        char            szCardNO[DH_COMMON_STRING_32];      // Card no., swipe card valie
        char            szPassword[DH_COMMON_STRING_64];    // Password, valid when unlock by password
        char            szFtpUrl[MAX_PATH];                 // ftp upload address, picturepath
        int             nImageNum;                          // Snapshot picture
        NET_TIME        stuTime;                            // Event time
    }ALARM_ACCESS_SNAP_INFO;
    
    // Clear Alarm Event
    typedef struct tagALARM_ALARMCLEAR_INFO
    {
        DWORD           dwSize;
        int             nChannelID;                         // Channel No.
        NET_TIME        stuTime;                            // Alarm event time
    }ALARM_ALARMCLEAR_INFO;
    
    // CID Event
    typedef struct tagALARM_CIDEVENT_INFO
    {
        DWORD           dwSize;
        NET_TIME        stuTime;                            // Alarm event time
        char			szCID[DH_COMMON_STRING_32];         // CID code, standard protocolcode, string length is 16??string value is 0~F
        // 4 bit user code + 2 bit recognition code + 1 bit event limit code + 3 bit event code + 2 bit system code + 3 bit zone code + 1 bit parity code
    }ALARM_CIDEVENT_INFO;
    
    // Emergency Help Event Type
    typedef enum tagEM_RCEMERGENCY_CALL_TYPE
    {
        EM_RCEMERGENCY_CALL_UNKNOWN = 0,
        EM_RCEMERGENCY_CALL_FIRE,                           // Fire
        EM_RCEMERGENCY_CALL_DURESS,                         // Forced
        EM_RCEMERGENCY_CALL_ROBBER,                         // Robber
        EM_RCEMERGENCY_CALL_MEDICAL,                        // Medical
        EM_RCEMERGENCY_CALL_EMERGENCY,                      // Emergency
    }EM_RCEMERGENCY_CALL_TYPE;
    
    // alarm method
    typedef enum tagEM_RCEMERGENCY_MODE_TYPE
    {
        EM_RCEMERGENCY_MODE_UNKNOWN = 0,
        EM_RCEMERGENCY_MODE_KEYBOARD,                       //  keyboard
        EM_RCEMERGENCY_MODE_WIRELESS_CONTROL,               // remote control
    }EM_RCEMERGENCY_MODE_TYPE;
    
    // Emergency Help Event Details
    typedef struct tagALARM_RCEMERGENCY_CALL_INFO
    {
        DWORD                   dwSize;
        int                     nAction;                    // 0:start 1:stop
        EM_RCEMERGENCY_CALL_TYPE  emType;                   // emergency type
        NET_TIME                stuTime;                    // event time
        EM_RCEMERGENCY_MODE_TYPE  emMode;                   // alarm method
        DWORD                   dwID;                       // for different emergency events (only emMode is remote control type, it is valid , means remote control no. , 0 means invalid ID)
    }ALARM_RCEMERGENCY_CALL_INFO;
    
    // multi-people unlock event(corresponding to DH_ALARM_OPENDOORGROUP type)
    typedef struct tagALARM_OPEN_DOOR_GROUP_INFO
    {
        DWORD           dwSize;
        int             nChannelID;                         // door channel(from 0)
        NET_TIME        stuTime;                            // event time
    }ALARM_OPEN_DOOR_GROUP_INFO;
    
    // get fingerprint event(corresponding to DH_ALARM_FINGER_PRINT type)
    typedef struct tagALARM_CAPTURE_FINGER_PRINT_INFO
    {
        DWORD           dwSize;
        int             nChannelID;                         // door channel no.( from 0)
        NET_TIME        stuTime;                            // event time
        char            szReaderID[DH_COMMON_STRING_32];    // card reader ID
        int             nPacketLen;                         // single fingerprint data length
        int             nPacketNum;                         // fingerprint data number
        char*           szFingerPrintInfo;                  // fingerprint data(data total length as nPacketLen*nPacketNum)
    }ALARM_CAPTURE_FINGER_PRINT_INFO;
    
    // sub system status type
    typedef enum __EM_SUBSYSTEM_STATE_TYPE
    {
        EM_SUBSYSTEM_STATE_UNKNOWN = 0,                     // unknown
        EM_SUBSYSTEM_STATE_ACTIVE,                          // activated
        EM_SUBSYSTEM_STATE_INACTIVE,                        // not activated
    }EM_SUBSYSTEM_STATE_TYPE;
    
    // sub system statua change event
    typedef struct tagALARM_SUBSYSTEM_STATE_CHANGE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                 // sub system no.(from 0)
        NET_TIME                stuTime;                    // event time
        EM_SUBSYSTEM_STATE_TYPE emState;                    // changed status
    }ALARM_SUBSYSTEM_STATE_CHANGE_INFO;
    
    // battery scheduled notice event
    typedef struct tagALARM_BATTERYPOWER_INFO
    {
        DWORD       dwSize;
        int         nChannel;                                  // battery no.
        NET_TIME    stuTime;                                   // event time
        int         nPercent;                                  // battery percentage
    }ALARM_BATTERYPOWER_INFO;
    
    //bell status event
    typedef struct tagALARM_BELLSTATUS_INFO
    {
        DWORD       dwSize;
        int         nChannel;                                   // bell channel no.
        NET_TIME    stuTime;                                    // event time
        int         nAction;                                    // 0:start 1:stop
    }ALARM_BELLSTATUS_INFO;
    
    // zone status change event, corresponding to event type DH_ALARM_DEFENCE_STATE_CHANGE_EVENT
    typedef struct tagALARM_DEFENCE_STATUS_CHANGE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // zone ID??as alarm input channel no.(from 0)
        NET_TIME                stuTime;                        // event time
        EM_DEFENCE_STATE_TYPE   emStatus;                       // zone changed status
    }ALARM_DEFENCE_STATUS_CHANGE_INFO;
    
    // login failed event
    typedef struct tagALARM_LOGIN_FAILIUR_INFO
    {
        DWORD                   dwSize;
        int                     nAction;                        // 0:start 1:stop
        unsigned int            nSequence;                      // no.
        char                    szName[DH_EVENT_NAME_LEN];      // event name??fill in user name
        char                    szType[DH_COMMON_STRING_128];   // login type
        char                    szAddr[DH_MAX_IPADDR_EX_LEN];   // source IP address
        int                     nError;                         // user login failed error code
    }ALARM_LOGIN_FAILIUR_INFO;
    
    // ticket statistics info event corresponding to event type DH_ALARM_TICKET_STATISTIC
    typedef struct tagALARM_TICKET_STATISTIC
    {
        DWORD                   dwSize;
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
        NET_TIME                stuTime;                        // event report time
        int                     nNormalCount;                   // general ticket number
        int                     nDiscountCount;                 // discount ticket
        int                     nSubsidyCount;                  // yound and old ticket number
        int                     nDriverCount;                   // driver ticket number
        int                     nNormalPrice;                   // general ticket price
        int                     nDiscountPrice;                 // discount ticket price
        int                     nSubsidyPrice;                  // young and old ticket price
    }ALARM_TICKET_STATISTIC;
    
#define MAX_ALARMEXT_MODULE_NUM     256                     // max expansionmodule quantity
    
    // BUS type
    typedef enum tagNET_BUS_TYPE
    {
        NET_BUS_TYPE_UNKNOWN = 0,
        NET_BUS_TYPE_MBUS,                                      // M-BUS
    }NET_BUS_TYPE;
    
    // expansion module offline event  corresponding to event type DH_ALARM_MODULE_LOST
    typedef struct tagALARM_MODULE_LOST_INFO
    {
        DWORD                   dwSize;
        NET_TIME                stuTime;                        // event report time
        int                     nSequence;                      // expansion module BUS no.(from 0)
        NET_BUS_TYPE            emBusType;                      // BUS type
        int                     nAddr;                          // offline expansion module quantity
        int                     anAddr[MAX_ALARMEXT_MODULE_NUM];// offline expansionmodule no.(from 0)
    }ALARM_MODULE_LOST_INFO;
    
    // PSTN offline event
    typedef struct tagALARM_PSTN_BREAK_LINE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                 // tel wire no.(from 0)
        int                     nAction;                    // 0:start  1:stop
        NET_TIME                stuTime;                    // event time
    }ALARM_PSTN_BREAK_LINE_INFO;
    
    // analog alarm event(instant event), specific sensot type(as overspeed, mealige, oil)trigger
    typedef struct tagALARM_ANALOGPULSE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // analog alarm channel no.
        NET_TIME                stuEventTime;                   // alarm event time
        NET_SENSE_METHOD        emSense;                        // sensor type
        char                    szName[DH_COMMON_STRING_128];   // sensor name
        int                     nStatus;                        // data status, -1:unknown,0:normal,1:invalid data(over range),
        // 2:over threshold 1,3:over threshold 2,4: over threshold 3,5 over threshold 4,
        // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
        float                   fValue;                         // senspr value
        NET_TIME                stuCollectTime;                 // collection time
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
    }ALARM_ANALOGPULSE_INFO;
    
    //dispatch info confirmation type
    typedef enum tagNET_MISSION_CONFIRM_TYPE
    {
        NET_MISSION_CONFIRM_UNKNOWN = 0 ,                        // unknown
        NET_MISSION_CONFIRM_YES ,                                // agree and execute
        NET_MISSION_CONFIRM_NO ,                                 // refuse
    }NET_MISSION_CONFIRM_TYPE;
    
    // task confirmation event(corresponding to command DH_ALARM_MISSION_CONFIRM)
    typedef struct tagALARM_MISSION_CONFIRM_INFO
    {
        DWORD                   dwSize;
        char                    szTitle[DH_COMMON_STRING_256];    // task name
        char                    szMissionID[DH_COMMON_STRING_256];// task ID
        char                    szComment[DH_COMMON_STRING_256];  // replay content
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                 // GPS info
        NET_MISSION_CONFIRM_TYPE emConfirmType;                   //dispatch info confirmation type
    }ALARM_MISSION_CONFIRM_INFO;
    
    // collect Node group  type
    typedef enum tagNET_CLUSTER_GROUP_TYPE
    {
        NET_CLUSTER_GROUP_UNKNOWN,             // unknown
        NET_CLUSTER_GROUP_IDLE,               // stand alone
        NET_CLUSTER_GROUP_MASTER,              // host
        NET_CLUSTER_GROUP_SLAVE,              // spare
    }NET_CLUSTER_GROUP_TYPE;
    
    // Node activate event , corresponding to event type DH_ALARM_NODE_ACTIVE
    typedef struct tagALARM_NODE_ACTIVE_INFO
    {
        DWORD          dwSize;
        int           nChannelID;         // collect node no.
        NET_TIME        stuTime;          // event occurred event
        NET_CLUSTER_GROUP_TYPE emGroup;          //  current Node group
    }ALARM_NODE_ACTIVE_INFO;
    
    // collect Node status
    typedef struct tagNET_CLUSTER_STATE_INFO
    {
        DWORD          dwSize;
        NET_CLUSTER_GROUP_TYPE emGroup;          //  current Node group
    }NET_CLUSTER_STATE_INFO;
    
    // device alarm mode
    typedef enum tagEM_ALARM_VIDEO_STATIC_MODE
    {
        EM_ALARM_VIDEO_STATIC_MODE_UNKNOWN,         // unknown
        EM_ALARM_VIDEO_STATIC_MODE_INDOOR,         // indoor mode "Indoor"
        EM_ALARM_VIDEO_STATIC_MODE_OUTDOOR,         // outdoor mode "Outdoor"
    }EM_ALARM_VIDEO_STATIC_MODE;
    
    // video statis detection event , corresponding to event type DH_ALARM_VIDEO_STATIC
    typedef struct tagALARM_VIDEO_STATIC_INFO
    {
        DWORD            dwSize;
        DWORD            dwAction;            // event action, 0:Start, 1:Stop
        EM_ALARM_VIDEO_STATIC_MODE emMode;             // device alarm mode
        int             nChannelID;           // video statis detection alarm channel no.
    }ALARM_VIDEO_STATIC_INFO;
    
    // active registration device re-login event , corresponding to event type DH_ALARM_REGISTER_REONLINE
    typedef struct tagALARM_REGISTER_REONLINE_INFO
    {
        DWORD      dwSize;
    }ALARM_REGISTER_REONLINE_INFO;
    
    // connection status
    typedef enum tagEM_ALARM_ISCSI_STATUS
    {
        EM_ALARM_ISCSI_STATUS_UNKNOWN,         // unknown
        EM_ALARM_ISCSI_STATUS_CONNECTED,        // connected
        EM_ALARM_ISCSI_STATUS_NOT_CONNECTED,      // unconnected
        EM_ALARM_ISCSI_STATUS_CONNECT_FAILED,      // connection failed
        EM_ALARM_ISCSI_STATUS_AUTHENTICATION_FAILED,  // authentication failed
        EM_ALARM_ISCSI_STATUS_CONNECT_TIMEOUT,     // connection timed out
        EM_ALARM_ISCSI_STATUS_NOT_EXIST,        // device does not exist
    }EM_ALARM_ISCSI_STATUS;
    
    // ISCSI alarm event , corresponding to event type DH_ALARM_ISCSI_STATUS
    typedef struct tagALARM_ISCSI_STATUS_INFO
    {
        DWORD          dwSize;
        int           nIndex;               // means ISCSIdevice index no.
        char          szAddress[DH_COMMON_STRING_32];   // server address
        char          szName[DH_COMMON_STRING_64];    // Target name
        char          szUserName[DH_COMMON_STRING_64];  // username
        EM_ALARM_ISCSI_STATUS  emStatus;              // connection status
    }ALARM_ISCSI_STATUS_INFO;
    
    // detection collection device alarm event , corresponding to event type DH_ALARM_SCADA_DEV_ALARM
    typedef struct tagALARM_SCADA_DEV_INFO
    {
        DWORD       dwSize;
        int         nChannel;                           // channel no.
        NET_TIME    stuTime;                            // event occur time
        char        szDevName[DH_COMMON_STRING_64];     // failure device name
        char        szDesc[DH_COMMON_STRING_256];       // alarm description
        int         nAction;                            // -1:unknown, 0:pulse, 1:start, 2:stop
        char        szID[DH_COMMON_STRING_32];          // point ID, current len is 16 bytes
        char        szSensorID[DH_COMMON_STRING_32];    // sensor ID, current len is 16 bytes
        char        szDevID[DH_COMMON_STRING_32];       // device ID, current len is 16 bytes
        char        szPointName[DH_COMMON_STRING_64];   // point name, matching with spot chart
    }ALARM_SCADA_DEV_INFO;
    
    // vehicle ACC alarm event, correspond event: DH_ALARM_VEHICLE_ACC
    typedef struct tagALARM_VEHICLE_ACC_INFO
    {
        DWORD                   dwSize;
        int                     nACCStatus;                         // ACC state, 0:invalid, 1:open, 2:close
        int                     nAction;                            // event action, 0:Start, 1:Stop
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPS informmation
        int                     nConstantElectricStatus;            // Constant electric states, 0:unknown, 1:connect, 2:break
    }ALARM_VEHICLE_ACC_INFO;
    
    typedef NET_ACCESS_CTL_STATUS_TYPE  NET_ACCESS_LOCK_STATUS_TYPE;
    
    // locked status, correspond to DH_ALARM_ACCESS_LOCK_STATUS
    typedef struct tagALARM_ACCESS_LOCK_STATUS_INFO
    {
        DWORD                       dwSize;
        int                         nChannel;                       // door channal (from 0)
        NET_TIME                    stuTime;                        // the time of event occurs
        NET_ACCESS_LOCK_STATUS_TYPE emLockStatus;                   // locked status
    }ALARM_ACCESS_LOCK_STATUS_INFO;
    
    // SEVER TYPE
    typedef enum tagEM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE
    {
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_UNKNOWN,         // Unknown
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_BANLANCE,        // Balance
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_TRADITION,       // Tradition
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_CONSULTANT,      // Consultant
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_OTHER,           // Other
    }EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE;
    
    // Finace event, correspond to DH_ALARM_FINACE_SCHEME
    typedef struct tagALARM_FINACE_SCHEME_INFO
    {
        DWORD                       dwSize;
        int                         nChannel;                                   // channel ID
        char                        szBusinessSeverID[DH_COMMON_STRING_64];     // business sever ID
        EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE  emBusinessSeverType;        // business sever type
        NET_TIME                    stuFinaceSchemeTime;                        // finance scheme time
        NET_TIME                    stuSchemeStartTime;                         // scheme start time
        NET_TIME                    stuSchemeEndTime;                           // scheme end time
        char                        szProductName[DH_COMMON_STRING_128];        // product name
        char                        szCardNo[DH_COMMON_STRING_64];              // card ID
        char                        szPersonID[DH_COMMON_STRING_64];            // persion ID
        char                        szPersonName[DH_COMMON_STRING_64];          // persion name
        char                        szOrgNo[DH_COMMON_STRING_64];               // subbranch No
        char                        szStuffID[DH_COMMON_STRING_64];             // stuff ID
        NET_TIME                    stuRecStartTime;                            // record start time
        NET_TIME                    stuRecEndTime;                              // record end time
    }ALARM_FINACE_SCHEME_INFO;
    
    //////////////////////////////////////////////////////////////////////////
    
    // New Record Set Operation(Insert)Parameter
    typedef struct tagNET_CTRL_RECORDSET_IN
    {
        DWORD	dwSize;
        EM_NET_RECORD_TYPE	emType;					// Record Information Type
        void*	pBuf;								// Record Information Cache,The EM_NET_RECORD_TYPE Note is Details
        int		nBufLen;							// Record Information Cache Size
    }NET_CTRL_RECORDSET_INSERT_IN;
    
    // Record New Operation(Insert) Parameter
    typedef struct tagNET_CTRL_RECORDSET_OUT
    {
        DWORD           dwSize;
        int             nRecNo;                             // Record Number(The Device Come Back When New Insert )
    }NET_CTRL_RECORDSET_INSERT_OUT;
    
    // Record New Operation (Insert)Parameter
    typedef struct tagNET_CTRL_RECORDSET_INSERT_PARAM
    {
        DWORD                           dwSize;
        NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // Record Information(User Write)
        NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // Record Information(the Device Come Back)
    }NET_CTRL_RECORDSET_INSERT_PARAM;
    
    // Record Operation Parameter
    typedef struct tagNET_CTRL_RECORDSET_PARAM
    {
        DWORD               dwSize;
        EM_NET_RECORD_TYPE  emType;                         // Record Information Type
        void*               pBuf;                           // New/Renew/Inquire,It is Record Information Cache??the EM_NET_RECORD_TYPE Note is Details)
        // Delete,It is Record Number(Int Model)
        int                    nBufLen;                     // Record Information Cache Size
    }NET_CTRL_RECORDSET_PARAM;
    
    // Card Statue
    typedef enum tagNET_ACCESSCTLCARD_STATE
    {
        NET_ACCESSCTLCARD_STATE_UNKNOWN = -1,
        NET_ACCESSCTLCARD_STATE_NORMAL = 0,                 // Normal
        NET_ACCESSCTLCARD_STATE_LOSE   = 0x01,              // Lose
        NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02,              // Logoff
        NET_ACCESSCTLCARD_STATE_FREEZE = 0x04,              // Freeze
        NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08,           // Arrears
        NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10,             // Overdue
    }NET_ACCESSCTLCARD_STATE;
    
    // Card Type
    typedef enum tagNET_ACCESSCTLCARD_TYPE
    {
        NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1,
        NET_ACCESSCTLCARD_TYPE_GENERAL,                     // General Card
        NET_ACCESSCTLCARD_TYPE_VIP,                         // VIP Card
        NET_ACCESSCTLCARD_TYPE_GUEST,                       // Guest Card
        NET_ACCESSCTLCARD_TYPE_PATROL,                      // Patrol Card
        NET_ACCESSCTLCARD_TYPE_BLACKLIST,                   // Blacklist Card
        NET_ACCESSCTLCARD_TYPE_CORCE,                       // Corce Card
        NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff,           // Mother Card
    }NET_ACCESSCTLCARD_TYPE;
    
#define DH_MAX_DOOR_NUM               32                // Max Door Number
#define DH_MAX_TIMESECTION_NUM        32                // Max Time Section Number
#define DH_MAX_CARDNAME_LEN           64                // access control naming max length
#define DH_MAX_CARDNO_LEN             32                // Max Card-Number Len
#define DH_MAX_USERID_LEN             32                // Max User ID Len
    
    //fingerprint data
    typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET
    {
        DWORD   dwSize;
        int		nLength;		// single number pack length??unit byte
        int		nCount;			// pack number
        char*	pPacketData;	// all fingerprint pack lengths?¡§total length as nLength*nCount??
    }NET_ACCESSCTLCARD_FINGERPRINT_PACKET;
    
    //Entrance Guard Record Information
    typedef struct tagNET_RECORDSET_ACCESS_CTL_CARD
    {
        DWORD           dwSize;
        int             nRecNo;                                 // Record Number,Read-Only
        NET_TIME        stuCreateTime;                          // Creat Time
        char            szCardNo[DH_MAX_CARDNO_LEN];            // Card number
        char            szUserID[DH_MAX_USERID_LEN];            // User's ID
        NET_ACCESSCTLCARD_STATE       emStatus;                 // Card Stetue
        NET_ACCESSCTLCARD_TYPE        emType;                   // Card Type
        char            szPsw[DH_MAX_CARDPWD_LEN];              // Card Password
        int             nDoorNum;                               // Valid Door Number;
        int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
        int             nTimeSectionNum;                        // the Number of Effective Open Time
        int             sznTimeSectionNo[DH_MAX_TIMESECTION_NUM];  // Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
        int             nUserTime;                              // Frequency of Use
        NET_TIME        stuValidStartTime;                      // Valid Start Time
        NET_TIME        stuValidEndTime;                        // Valid End Time
        BOOL            bIsValid;                               // Wether Valid,True =Valid,False=Invalid
        NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;// fingerprint data info
        BOOL            bFirstEnter;                            // has first card or not
        char            szCardName[DH_MAX_CARDNAME_LEN];        // card naming
        char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position
        BOOL            bHandicap;                              // Card for handicap, TRUE:yes, FALSE:no
    }NET_RECORDSET_ACCESS_CTL_CARD;
    
    // Entrance Guard Record  Information
    typedef struct tagNET_RECORDSET_ACCESS_CTL_PWD
    {
        DWORD           dwSize;
        int             nRecNo;                                 // Record Number,Read-Only
        NET_TIME        stuCreateTime;                          // Create Time
        char            szUserID[DH_MAX_USERID_LEN];            // User's ID
        char            szDoorOpenPwd[DH_MAX_CARDPWD_LEN];      // Open Password
        char            szAlarmPwd[DH_MAX_CARDPWD_LEN];         // Alarm Password
        int             nDoorNum;                               // Valid Door Number
        int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
        char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position
    }NET_RECORDSET_ACCESS_CTL_PWD;
    
    
    // Door Open Method(Entrance Guard Configure,One Way of Door Work )
    typedef enum tagNET_DOOR_OPEN_METHOD
    {
        NET_DOOR_OPEN_METHOD_UNKNOWN = 0,
        NET_DOOR_OPEN_METHOD_PWD_ONLY,                          // Password Open is Only
        NET_DOOR_OPEN_METHOD_CARD,                              // Card  open is Only
        NET_DOOR_OPEN_METHOD_PWD_OR_CARD,                       // Password or Card
        NET_DOOR_OPEN_METHOD_CARD_FIRST,                        // First Card then Password
        NET_DOOR_OPEN_METHOD_PWD_FIRST,                         // First Card then Password
        NET_DOOR_OPEN_METHOD_SECTION,                           // Sub-Periods
    }NET_DOOR_OPEN_METHOD;
    
    // Door Open Method(Entrance Guard Event,Entrance Guard get In/Out Record??Actual Open Door Method)
    typedef enum tagNET_ACCESS_DOOROPEN_METHOD
    {
        NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0,
        NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY,                    // Password
        NET_ACCESS_DOOROPEN_METHOD_CARD,                        // Card
        NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST,                  // First Card Then Password
        NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST,                   // First Password Then Card
        NET_ACCESS_DOOROPEN_METHOD_REMOTE,                      // Long-Range Open,Such as Through theIndoor Unit or Unlock the Door Machine Platform
        NET_ACCESS_DOOROPEN_METHOD_BUTTON,                      // Open Door Button
        NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT,                 // fingerprint lock
        NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT,        // password+swipe card+fingerprint combination unlock
        NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10,        // password+fingerprint combination unlock
        NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11,       // swipe card+fingerprint combination unlock
        NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12,                // multi-people unlock
        NET_ACCESS_DOOROPEN_METHOD_KEY = 13,                    // Key
    }NET_ACCESS_DOOROPEN_METHOD;
    
    // Access Control card Record Information
    typedef struct tagNET_RECORDSET_ACCESS_CTL_CARDREC
    {
        DWORD           dwSize;
        int             nRecNo;                                 // Record Number,Read-Only
        char            szCardNo[DH_MAX_CARDNO_LEN];            // Card Number
        char            szPwd[DH_MAX_CARDPWD_LEN];              // Password
        NET_TIME        stuTime;                                // Swing Card Time
        BOOL            bStatus;                                // Swing Card Result,True is Success,False is Fail
        NET_ACCESS_DOOROPEN_METHOD    emMethod;                 // Open Door Method
        int             nDoor;                                  // Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
        char            szUserID[DH_MAX_USERID_LEN];            // user ID
        int             nReaderID;                              // card reader ID
    }NET_RECORDSET_ACCESS_CTL_CARDREC;
    
    // Holiday Record Iinformation
    typedef struct tagNET_RECORDSET_HOLIDAY
    {
        DWORD           dwSize;
        int             nRecNo;                                 // Record Number,Read-Only
        int             nDoorNum;                               // Valid Door Number
        int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
        NET_TIME        stuStartTime;                           // Start Time
        NET_TIME        stuEndTime;                             // End Time
        BOOL            bEnable;                                // Holiday Enable
        char            szHolidayNo[DH_COMMON_STRING_32];       // Holiday No
    }NET_RECORDSET_HOLIDAY;
    
    // call type
    typedef enum tagEM_VIDEO_TALK_LOG_CALLTYPE
    {
        EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0,     // unknown
        EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING,      // call in
        EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING,      // call out
        EM_VIDEO_TALK_LOG_CALLTYPE_MAX,         //
    }EM_VIDEO_TALK_LOG_CALLTYPE;
    
    // terminal status
    typedef enum tagEM_VIDEO_TALK_LOG_ENDSTATE
    {
        EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0,     // unknown
        EM_VIDEO_TALK_LOG_ENDSTATE_MISSED,       // missed
        EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED,      // answered
        EM_VIDEO_TALK_LOG_ENDSTATE_MAX,         //
    }EM_VIDEO_TALK_LOG_ENDSTATE;
    
    // opposite type
    typedef enum tagEM_VIDEO_TALK_LOG_PEERTYPE
    {
        EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0,     // unknown
        EM_VIDEO_TALK_LOG_PEERTYPE_VTO,         // VTO
        EM_VIDEO_TALK_LOG_PEERTYPE_VTH,         // VTH
        EM_VIDEO_TALK_LOG_PEERTYPE_VTS,         // management centre server
    }EM_VIDEO_TALK_LOG_PEERTYPE;
    
    // call record record set info
    typedef struct tagNET_RECORD_VIDEO_TALK_LOG
    {
        DWORD              dwSize;
        int               nRecNo;               // record set no., read-only
        NET_TIME            stuCreateTime;           // start time
        EM_VIDEO_TALK_LOG_CALLTYPE   emCallType;             // call type
        EM_VIDEO_TALK_LOG_ENDSTATE   emEndState;             // terminal status
        char              szPeerNumber[DH_COMMON_STRING_64]; // opposite number	may be short no. or middle no., long no.
        EM_VIDEO_TALK_LOG_PEERTYPE   emPeerType;             // opposite type
        char              szLocalNumber[DH_COMMON_STRING_64]; // local no.	may be short no. or middle no., long no.
        int               nTalkTime;             // talk time	unit second
        int               nMessageTime;            // message time	unit second
        char              szPicturePath[DH_COMMON_STRING_128];//
    }NET_RECORD_VIDEO_TALK_LOG;
    
    
    // audio talk status
    typedef enum tagEM_REGISTER_USER_STATE
    {
        EM_REGISTER_USER_STATE_UNKNOWN = 0,         // unknown
        EM_REGISTER_USER_STATE_IDLE,                // initial status
        EM_REGISTER_USER_STATE_CALLING,             // call status ?¡§no response??
        EM_REGISTER_USER_STATE_RINGING,             // ring status ?¡§opposite response??but no response??
        EM_REGISTER_USER_STATE_PREVIEWING,          // previewing
        EM_REGISTER_USER_STATE_LEAVINGMESSAGE,      // messaging
        EM_REGISTER_USER_STATE_TALKING,             // talking
        EM_REGISTER_USER_STATE_MAX,                 //
    }EM_REGISTER_USER_STATE;
    
    // device type
    typedef enum tagEM_REGISTER_USER_STATE_DEV_TYPE
    {
        EM_REGISTER_USER_STATE_DEV_TYPE_UNKNOWN = 0,            // unknown
        EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTH,              // digital VTH
        EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTH,             // analogue VTH
        EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTO,              // digital VTO
        EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTO,             // analogue VTO
        EM_REGISTER_USER_STATE_DEV_TYPE_MAX,                    //
    }EM_REGISTER_USER_STATE_DEV_TYPE;
    
    // support lock or not
    typedef enum tagEM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE
    {
        EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_UNKNOWN = 0,                // Unknown
        EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_SUPPORTLOCK,                // Support
        EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_NOT_SUPPORTLOCK,            // Do not support
    }EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE;
    
    // status  record set info
    typedef struct tagNET_RECORD_REGISTER_USER_STATE
    {
        DWORD                                   dwSize;
        int                                     nRecNo;	                        // record set no., read-only
        NET_TIME                                stuCreateTime;                  // create time
        char                                    szUserID[DH_MAX_USERID_LEN];    // user ID
        BOOL                                    bOnline;                        // online or not
        char                                    szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];   // network address
        int                                     nPort;                          // port no.
        EM_REGISTER_USER_STATE                  emVideoTalkState;               // audio talk status
        NET_TIME                                stuOnlineTime;                  // online time
        NET_TIME                                stuOfflineTime;                 // offline time
        EM_REGISTER_USER_STATE_DEV_TYPE         emDevType;                      // device type
        EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE	emSupportLock;                  // whether support lock
    }NET_RECORD_REGISTER_USER_STATE;
    
    // visual talk analog VTH input mode
    typedef enum tagEM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE
    {
        EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_UNKNOWN,       // unknown
        EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEADDRESS,     // via SlaveAddress
        EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEID_SLAVEPORT,  // via SlaveID+SlavePort
    }EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE;
    
    // user type
    typedef enum tagEM_VIDEO_TALK_CONTACT_TYPE
    {
        EM_VIDEO_TALK_CONTACT_TYPE_UNKNOWN,       // unknown
        EM_VIDEO_TALK_CONTACT_TYPE_VTH,         // "VTH" VTH
        EM_VIDEO_TALK_CONTACT_TYPE_VTO,         // "VTO" VTO
    }EM_VIDEO_TALK_CONTACT_TYPE;
    
    // registration method
    typedef enum tagEM_VIDEO_TALK_CONTACT_REGISTER_TYPE
    {
        EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_UNKNOWN,        // unknown
        EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_PUBLIC,         // "public"
        EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_LOCAL,         // "local"
    }EM_VIDEO_TALK_CONTACT_REGISTER_TYPE;
    
    // contact record set info
    typedef struct tagNET_RECORD_VIDEO_TALK_CONTACT
    {
        DWORD                  dwSize;
        int                   nRecNo;                 // record  set no.??read-only
        NET_TIME                stuCreateTime;             // create time
        char                  szFirstName[DH_COMMON_STRING_32];    // name
        char                  szFamilyName[DH_COMMON_STRING_32];   // last name
        char                  szVTShortNumber[DH_COMMON_STRING_16];  // visual talk short no.
        char                  szVTMiddleNumber[DH_COMMON_STRING_32]; // visual talk middle no.
        char                  szVTLongNumber[DH_COMMON_STRING_64];  // visual talk long no.??or VTH analogue VTH SN
        char                  szVTNetAddress[DH_MAX_IPADDR_LEN_EX];  // visual talk network address
        char                  szVTOPosition[DH_COMMON_STRING_64];   // VTH link to VTO position
        EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE  emVTSlaveBindMode;           // visual talk analogue VTH input mode
        char                  szVTSlaveId[DH_COMMON_STRING_32];    // visual talk analogue  VTH input distributor address
        char                  szVTSlavePort[DH_COMMON_STRING_32];   // visual talk analogue  VTH input distributor port
        char                  szVTSlaveAddress[DH_COMMON_STRING_64]; // visual talk analogue VTH address
        char                  szNickname[DH_COMMON_STRING_64];    // nickname
        char                  szNotes[DH_COMMON_STRING_64];      // note
        EM_VIDEO_TALK_CONTACT_TYPE       emType;                 // user type
        EM_VIDEO_TALK_CONTACT_REGISTER_TYPE   emRegisterType;             // registration method
        char                  szVTHPassword[DH_COMMON_STRING_64];   // registration password
        char                  szVTOBuilding[DH_COMMON_STRING_64];   // building no.
        char                  szVTOUnit[DH_COMMON_STRING_64];     // unit no.
        char                  szGroupNumber[DH_COMMON_STRING_64];   // group
    }NET_RECORD_VIDEO_TALK_CONTACT;
    
    
    // entrance guard don't close event details information
    typedef struct tagALARM_ACCESS_CTL_NOT_CLOSE_INFO
    {
        DWORD           dwSize;
        int             nDoor;                                  // Door Channel Number
        char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
        NET_TIME        stuTime;                                // Alarm Event Triggered Time
        int             nAction;                                // 0=Start 1=Stop
    }ALARM_ACCESS_CTL_NOT_CLOSE_INFO;
    
    // Break Event Detail Information
    typedef struct tagALARM_ACCESS_CTL_BREAK_IN_INFO
    {
        DWORD           dwSize;
        int             nDoor;                                  // Door Channel Number
        char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
        NET_TIME        stuTime;                                // Alarm Event Triggered Time
    }ALARM_ACCESS_CTL_BREAK_IN_INFO;
    
    
    // Repeatedly Entry  Event Detail Information
    typedef struct tagALARM_ACCESS_CTL_REPEAT_ENTER_INFO
    {
        DWORD           dwSize;
        int             nDoor;                                  // Door Channel Number
        char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
        NET_TIME        stuTime;                                // Alarm Event Triggered Time
    }ALARM_ACCESS_CTL_REPEAT_ENTER_INFO;
    
    
    // Forced Card Swing Card  Event Detail Information
    typedef struct tagALARM_ACCESS_CTL_DURESS_INFO
    {
        DWORD           dwSize;
        int             nDoor;                                  // Door Channel Number
        char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
        char            szCardNo[DH_MAX_CARDNO_LEN];            // Forced Card Number
        NET_TIME        stuTime;                                // Alarm Event Triggered Time
    }ALARM_ACCESS_CTL_DURESS_INFO;
    
    
    // Entrance Guard Event Type
    typedef enum tagNET_ACCESS_CTL_EVENT_TYPE
    {
        NET_ACCESS_CTL_EVENT_UNKNOWN = 0,
        NET_ACCESS_CTL_EVENT_ENTRY,                             // Get In
        NET_ACCESS_CTL_EVENT_EXIT,                              // Get Out
    }NET_ACCESS_CTL_EVENT_TYPE;
    
    
    // Entrance Guard Event
    typedef struct tagALARM_ACCESS_CTL_EVENT_INFO
    {
        DWORD                       dwSize;
        int                         nDoor;                              // Door Channel Number
        char                        szDoorName[DH_MAX_DOORNAME_LEN];    // Entrance Guard Name
        NET_TIME                    stuTime;                            // Alarm Event Triggered Time
        NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // Entrance Guard Event Type
        BOOL                        bStatus;                            // Swing Card Result,True is Success,False is Fail
        NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
        NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // Open The Door Method
        char                        szCardNo[DH_MAX_CARDNO_LEN];        // Card Number
        char                        szPwd[DH_MAX_CARDPWD_LEN];          // Password
        char                        szReaderID[DH_COMMON_STRING_32];    // Reader ID
        char                        szUserID[DH_COMMON_STRING_64];      // unlock user
        char                        szSnapURL[DH_COMMON_STRING_256];    // snapshot picture storage address
        int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
        // 0x00 no error
        // 0x10 unauthorized
        // 0x11 card lost or cancelled
        // 0x12 no door right
        // 0x13 unlock mode error
        // 0x14 valid period error
        // 0x15 anti sneak into mode
        // 0x16 forced alarm not unlocked
        // 0x17 door NC status
        // 0x18 AB lock status
        // 0x19 patrol card
        // 0x1A device is under intrusion alarm status
        // 0x20 period error
        // 0x21 unlock period error in holiday period
        // 0x30 first card right check required
        // 0x40 card correct, input password error
        // 0x41 card correct, input password timed out
        // 0x42 card correct, input fingerprint error
        // 0x43 card correct, input fingerprint timed out
        // 0x44 fingerprint correct, input password error
        // 0x45 fingerprint correct, input password timed out
        // 0x50 group unlock sequence error
        // 0x51 test required for group unlock
        // 0x60 test passed, control unauthorized
    }ALARM_ACCESS_CTL_EVENT_INFO;
    
    ///////////////////////// Alarm of intelligent transportation[CLIENT_StartListenEx] /////////////////////////////////////
    
    //type DH_IVS_TRAFFIC_REALFLOWINFO(traffic real flow info)
    typedef struct tagALARM_IVS_TRAFFIC_REALFLOW_INFO
    {
        int                 nChannelID;                       // channel ID
        char                szName[128];                      // name
        char                bReserved1[4];                    // reserved
        double              PTS;                              // PTS(ms)
        NET_TIME_EX         UTC;                              // time of occurrence
        int                 nEventID;                         // event ID
        unsigned int        nSequence;                        // sequence
        BYTE                bEventAction;                     // event action,0 pulse,1 durable events begin, 2 durable events end
        BYTE                byReserved[3];
        int                 nLane;                            // lane number
        int                 nCount;                           // cars count
        int					nSpeed;							  // speed,km/h
        int                 nOverPercent;                     // over percent
        int                 nMetersUints;                     // meter unit 0:km,1:mile
        BYTE                bReserved[1024];                  // reserved
    }ALARM_IVS_TRAFFIC_REALFLOW_INFO;
    
    // Alarm Event Type,DH_ALARM_VEHICLE_TURNOVER's Data Describe Information
    typedef struct tagALARM_VEHICEL_TURNOVER_EVENT_INFO
    {
        NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
        BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
        BYTE                bReserved[1023];                // Hold Byte,For Extension.
    }ALARM_VEHICEL_TURNOVER_EVENT_INFO;
    
    // Alarm Event Type,DH_ALARM_VEHICLE_COLLISION'sData Describe Information
    typedef struct tagALARM_VEHICEL_COLLISION_EVENT_INFO
    {
        NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
        BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
        BYTE                bReserved[1023];                // Hold Byte,For Extension.
    }ALARM_VEHICEL_COLLISION_EVENT_INFO;
    
    // Alarm Event Type,DH_ALARM_VEHICLE_CONFIRM'sData Describe Information
    typedef struct tagALARM_VEHICEL_CONFIRM_INFO
    {
        DWORD               dwStructSize;                   // StructSize
        NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
        BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
        BYTE                byRserved[3];                   // Hold Byte,For Extension.
        char                szInfo[128];                    // Upload Alarm Concrete Information
    }ALARM_VEHICEL_CONFIRM_INFO;
    
    //Alarm Event Type,DH_EVENT_REGISTER_OFF's Data Describe Information
    typedef struct tagEVENT_REGISTER_OFF_INFO
    {
        DWORD               dwStructSize;                   // StructSize
        NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
        BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
        BYTE                byRserved[3];                   // Aline
    }EVENT_REGISTER_OFF_INFO;
    
    // Alarm Event Type,DH_ALARM_VIDEO_TIMING's Data Describe Information
    typedef struct tagALARM_VIDEO_TIMING
    {
        DWORD               dwStructSize;                   // StructSize
        DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
        DWORD               dwChannelID;                    // Video Channel ID
    }ALARM_VIDEO_TIMING;
    
    // Alarm Event Type,DH_ALARM_VEHICLE_LARGE_ANGLE's Data Describe Information
    typedef struct tagALARM_VEHICEL_LARGE_ANGLE
    {
        DWORD               dwStructSize;                   // StructSize
        NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
        BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
        BYTE                byRserved[3];                   // Aline
        unsigned int        nSequence;                      // no.
    }ALARM_VEHICEL_LARGE_ANGLE;
    
    // Alarm Event Type,DH_ALARM_AUDIO_ANOMALY's Data Describe Information
    typedef struct tagALARM_AUDIO_ANOMALY
    {
        DWORD               dwStructSize;                   // StructSize
        DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
        DWORD               dwChannelID;                    // Audio Channel ID
    }ALARM_AUDIO_ANOMALY;
    
    // Alarm Event Type,DH_ALARM_AUDIO_MUTATION's Data Describe Information
    typedef struct tagALARM_AUDIO_MUTATION
    {
        DWORD               dwStructSize;                   // StructSize
        DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
        DWORD               dwChannelID;                    // Audio Channel ID
    }ALARM_AUDIO_MUTATION;
    
#define MAX_SENSORID_NUMBER 20                          // Max sensor number
#define MAX_TYRE_NUM        128                         // Max Tyre Number
    // Tyre Alarm Flag Bit Corresponding Enumeration
    typedef enum tagAlarmTyreFlag
    {
        ALARM_TYRE_FLAG_NONE,                               // None Valid Data
        ALARM_TYRE_FLAG_NORMAL,                             // Normal
        ALARM_TYRE_FLAG_HIGHPRESSURE,                       // High Pressure
        ALARM_TYRE_FLAG_LOWERPRESSURE,                      // Low Pressure
        ALARM_TYRE_FLAG_HIGHTEMP,                           // High Temperature
        ALARM_TYRE_FLAG_HIGHTEMP_HIGHPRESSURE,              // High Pressure??High Temperature
        ALARM_TYRE_FLAG_HIGHTEMP_LOWERPRESSURE,             // High Temperature ??Low Pressure
        
        ALARM_TYRE_FLAG_INVALID,                            // Illegal Flag Data
    }EM_ALARM_TYER_FALG;
    
    // Tyre Information Struct
    typedef struct tagTYRE_INFO_UNIT
    {
        DWORD               dwStructSize;                    // StructSize
        DWORD               dwSensorIDNum;                   // Sensor Number
        DWORD               dwSensorID[MAX_SENSORID_NUMBER]; // Sensor ID Information
        DWORD               dwTyreNum;                       // Tyre Number
        DWORD               dwTyrePlace;                     // Tyre at the First Few Shaft
        
        EM_ALARM_TYER_FALG  emAlarmFlag;                     // Tyre Alarm Flag
        
        int                 nTemp;                           // Temperature,Unit:??
        int                 nTempLimit;                      // Temperature,Unit:??
        
        float               fPressure;                       // Pressure,Unit:Kpa
        float               fUpperLimit;                     // Alarm Threshold Pressure Upper Limit
        float               fLowerLimit;                     // Alarm Threshold Pressure Lower Limit
        float               fVoltage;                        // Sensor Current Voltage,Unit:V
    }TYRE_INFO_UNIT;
    
    // Alarm Event Type,DH_EVENT_TYREINFO's Data Describe Information
    typedef struct tagEVENT_TYRE_INFO
    {
        DWORD               dwStructSize;                   // StructSize
        DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
        DWORD               dwTyreNum;                      // Tyre Number
        TYRE_INFO_UNIT      *pstuTyre;                      // Tyre Information
    }EVENT_TYRE_INFO;
    
    /////////////////////////////Audio Talk Related Definition/////////////////////////////
    
    // Audio format information
    typedef struct
    {
        BYTE				byFormatTag;			// Encode type such as 0:PCM
        WORD				nChannels;				// Track number
        WORD				wBitsPerSample;			// Sampling depth
        DWORD				nSamplesPerSec;			// Sampling rate
    } DH_AUDIO_FORMAT, *LPDH_AUDIO_FORMAT;
    
    /////////////////////////////User Management Corresponding Definition /////////////////////////////
    
    // Support the device with max 8 bits user name. Corresponding to the CLIENT_QueryUserInfo and CLIENT_OperateUserInfo.
    // Right information
    typedef struct _OPR_RIGHT
    {
        DWORD				dwID;
        char				name[DH_RIGHT_NAME_LENGTH];
        char				memo[DH_MEMO_LENGTH];
    } OPR_RIGHT;
    
    // User information
    typedef struct _USER_INFO
    {
        DWORD				dwID;
        DWORD				dwGroupID;
        char				name[DH_USER_NAME_LENGTH];
        char				passWord[DH_USER_PSW_LENGTH];
        DWORD				dwRightNum;
        DWORD				rights[DH_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
        DWORD				dwReusable;				// Reuse or not;1:enable reuse;0:disable reuse
    } USER_INFO;
    
    // User group information
    typedef struct _USER_GROUP_INFO
    {
        DWORD				dwID;
        char				name[DH_USER_NAME_LENGTH];
        DWORD				dwRightNum;
        DWORD				rights[DH_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
    } USER_GROUP_INFO;
    
    // User information list
    typedef struct _USER_MANAGE_INFO
    {
        DWORD				dwRightNum;				// Right information
        OPR_RIGHT			rightList[DH_MAX_RIGHT_NUM];
        DWORD				dwGroupNum;				// User group information
        USER_GROUP_INFO		groupList[DH_MAX_GROUP_NUM];
        DWORD				dwUserNum;				// User information
        USER_INFO			userList[DH_MAX_USER_NUM];
        DWORD				dwSpecial;				// User account reuse; 1:support account to be reused. 0:Does not support account to be reused.
    } USER_MANAGE_INFO;
    
    // Support the device of max 8-bit or 16-bit name. Corresponding interface to CLIENT_QueryUserInfoEx and CLIENT_OperateUserInfoEx
#define DH_USER_NAME_LENGTH_EX		16			// User name length
#define DH_USER_PSW_LENGTH_EX		16			// Password
    
    // Right information
    typedef struct _OPR_RIGHT_EX
    {
        DWORD				dwID;
        char				name[DH_RIGHT_NAME_LENGTH];
        char				memo[DH_MEMO_LENGTH];
    } OPR_RIGHT_EX;
    
    // User information
    typedef struct _USER_INFO_EX
    {
        DWORD				dwID;
        DWORD				dwGroupID;
        char				name[DH_USER_NAME_LENGTH_EX];
        char				passWord[DH_USER_PSW_LENGTH_EX];
        DWORD				dwRightNum;
        DWORD				rights[DH_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
        DWORD				dwFouctionMask;			// Subnet mask,0x00000001 - support reuse
        BYTE				byReserve[32];
    } USER_INFO_EX;
    
    // User group information
    typedef struct _USER_GROUP_INFO_EX
    {
        DWORD				dwID;
        char				name[DH_USER_NAME_LENGTH_EX];
        DWORD				dwRightNum;
        DWORD				rights[DH_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
    } USER_GROUP_INFO_EX;
    
    // User information sheet
    typedef struct _USER_MANAGE_INFO_EX
    {
        DWORD				dwRightNum;				// Right information
        OPR_RIGHT_EX		rightList[DH_MAX_RIGHT_NUM];
        DWORD				dwGroupNum;				// User group information
        USER_GROUP_INFO_EX  groupList[DH_MAX_GROUP_NUM];
        DWORD				dwUserNum;				// User information
        USER_INFO_EX		userList[DH_MAX_USER_NUM];
        DWORD				dwFouctionMask;			// Subnet mask;0x00000001 - support reuse, 0x00000002 - Password has been modified , it needs to be verified.
        BYTE				byNameMaxLength;		// The supported user name max length
        BYTE				byPSWMaxLength;			// The supported password max length
        BYTE				byReserve[254];
    } USER_MANAGE_INFO_EX;
    
    // Max support a device of 64-channel. Corresponding extension interface CLIENT_QueryUserInfoNew and CLIENT_OperateUserInfoNew
#define DH_NEW_MAX_RIGHT_NUM        1024
#define DH_NEW_USER_NAME_LENGTH	 128			// User name length
#define DH_NEW_USER_PSW_LENGTH	 128			// password
    
    // Rights info
    typedef struct _OPR_RIGHT_NEW
    {
        DWORD               dwSize;
        DWORD				dwID;
        char				name[DH_RIGHT_NAME_LENGTH];
        char				memo[DH_MEMO_LENGTH];
    } OPR_RIGHT_NEW;
    
    // User info
    typedef struct _USER_INFO_NEW
    {
        DWORD               dwSize;
        DWORD				dwID;
        DWORD				dwGroupID;
        char				name[DH_NEW_USER_NAME_LENGTH];
        char				passWord[DH_NEW_USER_PSW_LENGTH];
        DWORD				dwRightNum;
        DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
        DWORD				dwFouctionMask;			// Sub mask,0x00000001 - Support account reusable
        NET_TIME            stuTime;                // Last Revise Time
        BYTE                byIsAnonymous;          // Whether Can Be Anonymous Login,0=Can't Be Anonymous Login,1=Can be Anonymous Login
        BYTE                byReserve[7];
    } USER_INFO_NEW;
    
    // User group info
    typedef struct _USER_GROUP_INFO_NEW
    {
        DWORD               dwSize;
        DWORD				dwID;
        char				name[DH_USER_NAME_LENGTH_EX];
        DWORD				dwRightNum;
        DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
        char				memo[DH_MEMO_LENGTH];
    } USER_GROUP_INFO_NEW;
    
    // user group information expand,user group lengthen
    typedef struct _USER_GROUP_INFO_EX2
    {
        DWORD               dwSize;
        DWORD               dwID;
        char                name[DH_NEW_USER_NAME_LENGTH];
        DWORD               dwRightNum;
        DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
        char                memo[DH_MEMO_LENGTH];
    } USER_GROUP_INFO_EX2;
    
    // User info list
    typedef struct _USER_MANAGE_INFO_NEW
    {
        DWORD               dwSize;
        DWORD				dwRightNum;				// Rights info
        OPR_RIGHT_NEW		rightList[DH_NEW_MAX_RIGHT_NUM];
        DWORD				dwGroupNum;				// User group info
        USER_GROUP_INFO_NEW  groupList[DH_MAX_GROUP_NUM];
        DWORD				dwUserNum;				// User info
        USER_INFO_NEW		userList[DH_MAX_USER_NUM];
        DWORD				dwFouctionMask;			// Sub mask; 0x00000001 - Support account reusable,0x00000002 - Verification needed when change password
        BYTE				byNameMaxLength;		// Max user name length supported
        BYTE				byPSWMaxLength;			// Max password length supported
        BYTE				byReserve[254];
        USER_GROUP_INFO_EX2 groupListEx[DH_MAX_GROUP_NUM];      // User Group Information Expand
    } USER_MANAGE_INFO_NEW;
    
    ///////////////////////////////Search Related Definition ///////////////////////////////
    
    // The language types device supported
    typedef struct _DH_LANGUAGE_DEVINFO
    {
        DWORD				dwLanguageNum;			// The language amount supported
        BYTE				byLanguageType[252];	// Enumeration value please refer to DH_LANGUAGE_TYPE
    } DH_DEV_LANGUAGE_INFO, *LPDH_DEV_LANGUAGE_INFO;
    
    // the IPC types device supported
    typedef struct
    {
        int                 nTypeCount;              // The IPC type amount supported
        BYTE                bSupportTypes[128];      // Enumeration value please refer to EM_IPC_TYPE
    }DH_DEV_IPC_INFO;
    
    //3G net flow info
    typedef struct
    {
        int					nStrategy;              // strategy,0: charged by flow every month 1:charged by time every month
        int                 nUplimit;               // up limit flow, by flow: MB, by time: h
        int                 nUsed;                  // have used flow, by flow: MB, by time: h
        BYTE                bReserved[64];          // reserved
    }DH_DEV_3GFLOW_INFO;
    
    // 3G module info
    typedef struct
    {
        BYTE			    byEthNum;				// 3G model number
        BYTE				byReserved[255];        // reserved
    }DH_DEV_3GMODULE_INFO;
    
    typedef struct
    {
        DWORD				dwId;                            // ddns server id
        char				szState[DH_MAX_DDNS_STATE_LEN];	 // ddns status
        BYTE				bReserved[512];                  // reserved
    }DH_DEV_DNS_INFO;
    typedef struct
    {
        DWORD				dwDdnsServerNum;
        DH_DEV_DNS_INFO     stDdns[DH_MAX_DDNS_NUM];
    }DH_DEV_MULTI_DDNS_INFO;
    
    // device URL info
    typedef struct
    {
        char				szURLInfo[512];         // device URL info, by string
        BYTE				bReserved[512];
    }DH_DEV_URL_INFO;
    // HDD informaiton
    typedef struct
    {
        DWORD				dwVolume;				// HDD capacity
        DWORD				dwFreeSpace;			// HDD free space
        BYTE				dwStatus;				// higher 4 byte instruct hdd type, see the enum struct EM_DISK_TYPE; lower four byte instruct HDD status,0-hiberation,1-active,2-malfucntion and etc.;Devide DWORD into four BYTE
        BYTE				bDiskNum;				// HDD number
        BYTE				bSubareaNum;			// Subarea number
        BYTE				bSignal;				// Symbol. 0:local. 1:remote
    } NET_DEV_DISKSTATE,*LPNET_DEV_DISKSTATE;
    
    // Device HDD informaiton
    typedef struct _DH_HARDDISK_STATE
    {
        DWORD				dwDiskNum;				// Amount
        NET_DEV_DISKSTATE	stDisks[DH_MAX_DISKNUM];// HDD or subarea information
    } DH_HARDDISK_STATE, *LPDH_HARDDISK_STATE;
    
    typedef DH_HARDDISK_STATE	DH_SDCARD_STATE;	// SD card. Please refer to HDD information for data structure.
    
    // Audio encode information
    typedef struct
    {
        DH_TALK_CODING_TYPE	encodeType;				// Encode type
        int					nAudioBit;				// Bit:8/16
        DWORD				dwSampleRate;			// Sampling rate such as 8000 or 16000
        int                 nPacketPeriod;          // Pack Period,Unit ms
        char                reserved[60];
    } DHDEV_TALKDECODE_INFO;
    
    // The audio talk type the device supported
    typedef struct
    {
        int					nSupportNum;			// Amount
        DHDEV_TALKDECODE_INFO type[64];				// Encode type
        char				reserved[64];
    } DHDEV_TALKFORMAT_LIST;
    
    // PTZ property information
#define  NAME_MAX_LEN 16
    typedef struct
    {
        DWORD				dwHighMask;				// Operation mask high bit
        DWORD				dwLowMask;				// Operation mask low bit
        char				szName[NAME_MAX_LEN];	// Operation protocol name
        WORD				wCamAddrMin;			// Channel address min value
        WORD				wCamAddrMax;			// Channel address max value
        WORD				wMonAddrMin;			// Monitor address min value
        WORD				wMonAddrMax;			// Monitor address max value
        BYTE				bPresetMin;				// Preset min value
        BYTE				bPresetMax;				// Preset max value
        BYTE				bTourMin;				// Auto tour min value
        BYTE				bTourMax;				// Auto tour max value
        BYTE				bPatternMin;			// Pattern min value
        BYTE				bPatternMax;			// Pattern max value
        BYTE				bTileSpeedMin;			// Tilt speed min value
        BYTE				bTileSpeedMax;			// Tilt speed max value
        BYTE				bPanSpeedMin;			// Pan speed min value
        BYTE				bPanSpeedMax;			// Pan speed max value
        BYTE				bAuxMin;				// Aux function min value
        BYTE				bAuxMax;				// Aux function max value
        int					nInternal;				// Command interval
        char				cType;					// Protocol type
        BYTE				bReserved_1;			// Reserved
        BYTE				bFuncMask;				// function mask :0x01 - support PTZ-inside function
        BYTE				bReserved_2;
        char				Reserved[4];
    } PTZ_OPT_ATTR;
    
    // Burner informaiton
    typedef struct _NET_DEV_BURNING
    {
        DWORD				dwDriverType;			// Burner driver type;0:DHFS,1:DISK,2:CDRW
        DWORD				dwBusType;				// Bus type;0:USB,1:1394,2:IDE
        DWORD				dwTotalSpace;			// Total space(KB)
        DWORD				dwRemainSpace;			// Free space(KB)
        BYTE				dwDriverName[DH_BURNING_DEV_NAMELEN];	// Burner driver name
    } NET_DEV_BURNING, *LPNET_DEV_BURNING;
    
    // Device burner informaiton
    typedef struct _DH_BURNING_DEVINFO
    {
        DWORD				dwDevNum;				// Burner device amount
        NET_DEV_BURNING		stDevs[DH_MAX_BURNING_DEV_NUM];	// Each burner device information
    } DH_BURNING_DEVINFO, *LPDH_BURNING_DEVINFO;
    
    // Burner progress
    typedef struct _DH_BURNING_PROGRESS
    {
        BYTE				bBurning;				// Burner status;0:ready to burn,1:burner types is not correct. It does not match.
        // 2:there is no burner available,3:There is burning in process,4:Burner is not free(It is backup or buring or playback.)
        BYTE				bRomType;				// CD type;0:private file system,1:Portable HDD or flash disk,2:CD
        BYTE				bOperateType;			// Operation type;0:free,1:backup,2:burning,3:playback from the cd
        BYTE				bType;					// Backup pr burning status:0:stop or end,1:start,2:error,3:full,4:initializing
        NET_TIME			stTimeStart;			// Begin time
        DWORD				dwTimeElapse;			// Burning time(second)
        DWORD				dwTotalSpace;			// Total space
        DWORD				dwRemainSpace;			// Free space
        DWORD				dwBurned;				// Burned capacity
        WORD				dwStatus;				// Reserved
        WORD				wChannelMask;			// The burning channel mask
    } DH_BURNING_PROGRESS, *LPDH_BURNING_PROGRESS;
    
    // Log information. Corresponding to CLIENT_QueryLog
    typedef struct _DH_LOG_ITEM
    {
        DHDEVTIME			time;					// Date
        unsigned short		type;					// Type
        unsigned char		reserved;				// Reserved
        unsigned char		data;					// Data
        unsigned char		context[8];				// Content
    } DH_LOG_ITEM, *LPDH_LOG_ITEM;
    
    // Log information. Corresponding to CLIENT_QueryLogEx, parameter reserved(int nType=1;reserved=&nType;)
    typedef struct _DH_NEWLOG_ITEM
    {
        DHDEVTIME			time;					// Date
        WORD				type;					// Type
        WORD				data;					// data
        char				szOperator[8]; 			// User name
        BYTE				context[16];		    // Content
    } DH_NEWLOG_ITEM, *LPDH_NEWLOG_ITEM;
    
    // Log information. Corresponding to CLIENT_QueryDeviceLog
    typedef struct _DH_DEVICE_LOG_ITEM
    {
        int					nLogType;				// Log type
        DHDEVTIME			stuOperateTime;			// Date
        char				szOperator[16]; 		// Operator
        BYTE				bReserved[3];
        BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
        union
        {
            char			szLogContext[64];		// Log content
            struct
            {
                DH_LOG_ITEM		stuLog;				// Old log structure
                BYTE			bReserved[48];		// Reserved
            }stuOldLog;
        };
        char				reserved[16];
    } DH_DEVICE_LOG_ITEM, *LPDH_DEVICE_LOG_ITEM;
    
    // new Log information. Corresponding to CLIENT_QueryDeviceLog
    typedef struct _DH_DEVICE_LOG_ITEM_EX
    {
        int					nLogType;				// Log type
        DHDEVTIME			stuOperateTime;			// Date
        char				szOperator[16]; 		// Operator
        BYTE				bReserved[3];
        BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
        union
        {
            char			szLogContext[64];		// Log content
            struct
            {
                DH_LOG_ITEM		stuLog;				// Old log structure
                BYTE			bReserved[48];		// Reserved
            }stuOldLog;
        };
        char                szOperation[32];        // Detail operation
        char				szDetailContext[4 * 1024];  // DetailContext
    } DH_DEVICE_LOG_ITEM_EX, *LPDH_DEVICE_LOG_ITEM_EX;
    
    // Record log informaiton. Corresponding to the context of log structure
    typedef struct _LOG_ITEM_RECORD
    {
        DHDEVTIME			time;					// Time
        BYTE				channel;				// Channel
        BYTE				type;					// Record type
        BYTE				reserved[2];
    } LOG_ITEM_RECORD, *LPLOG_ITEM_RECORD;
    
    typedef struct _QUERY_DEVICE_LOG_PARAM
    {
        DH_LOG_QUERY_TYPE	emLogType;				// Searched log type
        NET_TIME			stuStartTime;			// The searched log start time
        NET_TIME			stuEndTime;				// The searched log end time.
        int				nStartNum;				// The search begins from which log in one period. It shall begin with 0 if it is the first time search.
        int				nEndNum;				// The ended log serial number in one search,the max returning number is 1024
        BYTE                nLogStuType;           // log struct type,0:DH_DEVICE_LOG_ITEM;1:DH_DEVICE_LOG_ITEM_EX
        BYTE                reserved[3];            // Reserved
        unsigned int        nChannelID;             // Channel no. 0:Compatible with previous all channel numbers. The channel No. begins with 1.1: The first channel.
        BYTE				bReserved[40];
    } QUERY_DEVICE_LOG_PARAM;
    
    // record information in the hard disk
    typedef struct __DEV_DISK_RECORD_INFO
    {
        NET_TIME			stuBeginTime;			// The first time video
        NET_TIME			stuEndTime;				// Recently video
        char				reserved[128];
    } DEV_DISK_RECORD_INFO;
    
    // disk record time
    typedef struct __DEV_DISK_RECORD_TIME
    {
        NET_TIME             stuStartTime1;		    // start time 1
        NET_TIME	         stuEndTime1;			// end time 1
        BOOL	             bTwoPart;			    // have two part or not
        NET_TIME	         stuStartTime2;		    // start time 2
        NET_TIME	         stuEndTime2;			// end time 2
        BYTE			  	 bDiskNum;				// disk number
        BYTE				 bSubareaNum;			// subarea num
        BYTE                 byReserved[62];        // reserved
        
    }DEV_DISK_RECORD_TIME;
    
    ///////////////////////////////Control Related Definition///////////////////////////////
    //new network keyboard control
    typedef struct _NKB_PARAM
    {
        BYTE                bAddressCode;           // for DVR and etc. device physical address no.,0xFF as broadcast address
        BYTE                bKeyStatus;             // status code 0/1 0 means press by key 1 means release key
        BYTE                bExtern1;               // expansion field 1
        BYTE                bExtern2;               // expansion field 2
        BYTE                bReserved[60];
    }NKB_PARAM;
    
    // HDD operation
    typedef struct _DISKCTRL_PARAM
    {
        DWORD				dwSize;					// Structure size. For version control.
        int					nIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0.
        int					ctrlType;				// Operation type
        // 0 -  clear data, 1 - set as read-write HDD , 2 -  set as read-only HDD
        // 3 - set as redundant , 4 - restore error , 5 -set as snapshot disk
        NET_DEV_DISKSTATE	stuDisk;				// diskInfo, replace nIndex
    } DISKCTRL_PARAM;
    
    typedef struct
    {
        BYTE				bSubareaNum;			// The number of pre-partition
        BYTE				bIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0.
        BYTE				bSubareaSize[32];		// partition Size(Percentage)
        BYTE				bReserved[30];			// Reservations
    } DISKCTRL_SUBAREA;
    
    // Alarm status
    typedef struct _ALARMCTRL_PARAM
    {
        DWORD				dwSize;
        int					nAlarmNo;				// Alarm channel. It begins from 0.
        int					nAction;				// 1:activate alarm,0:stop alarm
    } ALARMCTRL_PARAM;
    
    // Matrix control
    typedef struct _MATRIXCTRL_PARAM
    {
        DWORD				dwSize;
        int					nChannelNo;				// Video input number. It begins from  0.
        int					nMatrixNo;				// Matrix output number. It begins from 0
    } MATRIXCTRL_PARAM;
    
    // Burner control
    typedef struct _BURNING_PARM
    {
        int					channelMask;			// channel subnet mask. Bit means the channel to be burned.
        BYTE				devMask;				// Burner subnet mask.  Use bit to represent according to the searched burner list
        BYTE                bySpicalChannel;        // PIP channel(Channel No.+32)
        BYTE                byReserved[2];          // Reserved
    } BURNNG_PARM;
    
    // Annex burn
    typedef struct _BURNING_PARM_ATTACH
    {
        BOOL				bAttachBurn;			// Whether,0:Not; 1:Yes
        BYTE				bReserved[12];			// Reservations
    } BURNING_PARM_ATTACH;
    
    // Manual snap parameter
    typedef struct  _MANUAL_SNAP_PARAMETER{
        int                 nChannel;               // snap channel,start with 0
        BYTE                bySequence[64];	        // snap sequence string
        BYTE                byReserved[60];         // reserved
    }MANUAL_SNAP_PARAMETER;
    
    // local preview split parameter
    typedef struct _DEVICE_LOCALPREVIEW_SLIPT_PARAMETER
    {
        int                 nSliptMode;            // split mode
        int                 nSubSliptNum;          // split num, start with 1
        BYTE                byReserved[64];        // reserved
    }DEVICE_LOCALPREVIEW_SLIPT_PARAMETER;
    
    // local preview split capability
    typedef struct _DEVICE_LOCALPREVIEW_SLIPT_CAP
    {
        int                 nModeNumber;
        int                 nSliptMode[36];        // split array
        BYTE                byReserved[64];        // reserved
    }DEVICE_LOCALPREVIEW_SLIPT_CAP;
    
    // Crossing information
    typedef struct  _CROSSING_INFO
    {
        char              szCrossingID[DH_MAX_CROSSING_ID];  // Crossing ID
        DWORD             dwLatitude;				// Latitude(0-180 Degree, 30.183382 degree==120183382)
        DWORD             dwLongitude;				// Longitude(0-360 Degree, 120.178274 degree==300178274)
        WORD              wSpeedLimit;				// limit speed(KM/H)
        BYTE 	          byReserved[22];
    }CROSSING_INFO;
    
    // Route crossing information
    typedef struct  _ROUTE_CROSSING_INFO
    {
        BYTE 			   byCrossingNum;             // valid number is 1~DH_MAX_CROSSING_NUM
        BYTE			   byReserved1;
        WORD               wCrossingRange;            // Crossing range(m)
        CROSSING_INFO 	   stCrossingInfo[DH_MAX_CROSSING_NUM]; // Crossing information struct array
        BYTE			   byReserved2[2044];
    }ROUTE_CROSSING_INFO;
    
    // raid control
    typedef struct _CTRL_RAID_INFO
    {
        char				szAction[16];						// Add,Delete
        char				szName[16];							// Raid name
        int					nType;								// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
        int					nStatus;							// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
        int					nCntMem;							// nMember count
        int					nMember[32];						// 1,2,3,...
        int					nCapacity;							// capacity(G)
        int					nRemainSpace;						// remain space(M)
        int					nTank;								// tank 0:main,1:tank1,2:tank2.....
        char				reserved[128];
    }CTRL_RAID_INFO;
    
    // spake disk info
    typedef struct _CTRL_SPARE_DISK_INFO
    {
        char				szAction[16];						// Enable
        char				szScope[16];						// Global,Local
        char				szName[16];							// name
        unsigned int        nIndex;								// disk index
        const char*         pszDevName;                         // device name
        char                reserved[124];
    }CTRL_SPARE_DISK_INFO;
    
    typedef struct _CTRL_SPARE_DISK_INFO_A
    {
        int						nCnt;							// count
        CTRL_SPARE_DISK_INFO	stSpaceDiskInfo[32];			// spare disk info array
    }CTRL_SPARE_DISK_INFO_A;
    
    // Alarm arm and disarm control
    typedef struct __CTRL_ARM_DISARM_PARAM
    {
        BYTE                bState;                             // Arm/disarm state, 0 means disarm, 1 means arm, 2 means forced arm
        char                reserve[3];
        const char*         szDevPwd;                           // User's Password
        NET_SCENE_MODE      emSceneMode;                        // Contextual Mode
        const char*         szDevID;                            // Forwarding the Target Device ID,Null=Non Forward
        char                reserve1[16];
    } CTRL_ARM_DISARM_PARAM;
    
    // alarm arm/disarm control expansion input parameter
    typedef struct tagCTRL_ARM_DISARM_PARAM_EX_IN
    {
        DWORD               dwSize;
        NET_ALARM_MODE      emState;                // arm/disarm status
        const char*         szDevPwd;               // user password
        NET_SCENE_MODE      emSceneMode;            // scene mode
        const char*         szDevID;                // transfer target device ID, as NULL means not transfer
    } CTRL_ARM_DISARM_PARAM_EX_IN;
    
#define ARM_DISARM_ZONE_MAX (256)               // zone max number
    
    // alarm arm/disarm control expansion output parameter
    typedef struct tagCTRL_ARM_DISARM_PARAM_EX_OUT
    {
        DWORD               dwSize;
        DWORD               dwSourceNum;                    //  alarm source input arming failed zone number
        int                 nSource[ARM_DISARM_ZONE_MAX];   //  alarm source input failed zone no.,zone no. start from 0
        DWORD               dwLinkNum;                      // link alarm arming failed zone number
        int                 nLink[ARM_DISARM_ZONE_MAX];     // link alarm failed zone no., zone no. start from 0
    } CTRL_ARM_DISARM_PARAM_EX_OUT;
    
    // alarm arm/diarm control expansion(corresponding to DH_CTRL_ARMED_EX)
    typedef struct tagCTRL_ARM_DISARM_PARAM_EX
    {
        DWORD               dwSize;
        CTRL_ARM_DISARM_PARAM_EX_IN stuIn;                  // alarm arm/disarm control input
        CTRL_ARM_DISARM_PARAM_EX_OUT stuOut;                // alarm arm/disarm control output
    } CTRL_ARM_DISARM_PARAM_EX;
    
    typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_IN
    {
        DWORD				dwSize;
        int                 nType;                         // WPS connect type,0:virtual buttons; 1:(device)pin; 2:(wifi hot point)pin
        char                szSSID[DH_MAX_SSID_LEN];       // when SSID,nType is 1 or 2,availability,biggest support 32-bit
        char                szApPin[DH_MAX_APPIN_LEN];     // APPIN, when nType = 2,availability,PIN is 8 digits,from the wife(hot point)
        char                szWLanPin[DH_MAX_APPIN_LEN];   // device pin,when nType = 1,availability.produced by the device when empty,not empty soecified by the user,need to increase in wifi
    }DHCTRL_CONNECT_WIFI_BYWPS_IN;
    
    typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_OUT
    {
        DWORD				dwSize;
        char                szRetWLanPin[DH_MAX_APPIN_LEN];// return pin,when WPS's connect type is device end,this parameter is valid.
    }DHCTRL_CONNECT_WIFI_BYWPS_OUT;
    
    // CLIENT_ControlDevice interface DH_CTRL_WIFI_BY_WPS command parameter(WPS rapid configuration WIFI)
    typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS
    {
        DWORD				dwSize;
        DHCTRL_CONNECT_WIFI_BYWPS_IN     stuWpsInfo;         // connect parameter(user to fill in)
        DHCTRL_CONNECT_WIFI_BYWPS_OUT    stuWpsResult;       // return data(device to return to)
    } DHCTRL_CONNECT_WIFI_BYWPS;
    
    // CLIENT_ControlDevice interface DH_CTRL_CLOSE_BURNER
    typedef struct tagNET_CTRL_BURNERDOOR
    {
        DWORD		        dwSize;
        const char*         szBurnerName;                  // cd name,like "/dev/sda"
        BOOL                bResult;                       // operate result
        BOOL                bSafeEject;                    // Whether The Security Pop-up Drive, Data Save TRUE- pop Up Before, FALSE- Display)
    }NET_CTRL_BURNERDOOR;
    
    // CLIENT_ControlDevice interface DH_CTRL_START_PLAYAUDIO Order Parameter
    typedef struct tagNET_CTRL_START_PLAYAUDIO
    {
        DWORD               dwSize;
        char                szAudioPath[DH_MAX_AUDIO_PATH];
    }NET_CTRL_START_PLAYAUDIO;
    
    // report unit type
    typedef enum tagNET_PLAYAUDIO_TYPE
    {
        NET_PLAYAUDIO_TYPE_UNKNOWN = 0,
        NET_PLAYAUDIO_TYPE_PHRASE,                          // message type??no analysis??read in order??supported by audio file
        NET_PLAYAUDIO_TYPE_FILE,                            // play soecific path??s audiofile(device complete path)
        NET_PLAYAUDIO_TYPE_PLATERNUM,                       // report plate no.??read by plate format
        NET_PLAYAUDIO_TYPE_MONEY,                           // report amount??read byamount format
        NET_PLAYAUDIO_TYPE_DATE,                            // report date??read by date format
        NET_PLAYAUDIO_TYPE_TIME,                            // report time??read by time format
        NET_PLAYAUDIO_TYPE_EMPTY,                           // null type??stop one character time
    }NET_PLAYAUDIO_TYPE;
    
    // audio report content
    typedef struct tagNET_CTRL_PLAYAUDIO_INFO
    {
        DWORD               dwSize;
        NET_PLAYAUDIO_TYPE  emPlayAudioType;                // report unit type,see NET_PLAYAUDIO_TYPE
        char                szDetail[DH_COMMON_STRING_128]; // detailed content type detail??
        // Phrase type:"Welcome"
        // File type: "/home/parking.pcm"
        // PlateNumbe type: "??A12345"
        // Money type: "80.12 yuan"
        // Date type: "2014/4/10"
        // Time type : "1 day 10 hours 20 min 5 seconds
    }NET_CTRL_PLAYAUDIO_INFO;
    
#define DH_MAX_PLAYAUDIO_COUNT    16  // max report content items
    // CLIENT_ControlDevice port DH_CTRL_START_PLAYAUDIOEX command parameter
    typedef struct tagNET_CTRL_START_PLAYAUDIOEX
    {
        DWORD                       dwSize;
        unsigned int                nAudioCount;                            // report content quantity
        NET_CTRL_PLAYAUDIO_INFO     stuAudioInfos[DH_MAX_PLAYAUDIO_COUNT];  // audioplay content
    }NET_CTRL_START_PLAYAUDIOEX;
    
    // CLIENT_ControlDevice port DH_CTRL_START_ALARMBELL??DH_CTRL_STOP_ALARMBELL command parameter
    typedef struct tagNET_CTRL_ALARMBELL
    {
        DWORD               dwSize;
        int                 nChannelID;             // Channel ID (start from 0)
    }NET_CTRL_ALARMBELL;
    
    // CLIENT_ControlDevice's param: DH_CTRL_ACCESS_OPEN
    typedef struct tagNET_CTRL_ACCESS_OPEN
    {
        DWORD               dwSize;
        int                 nChannelID;             // Channel ID (start from 0)
        const char*         szTargetID;             // Target ID, NULL equals to not transmit
    }NET_CTRL_ACCESS_OPEN;
    
    // CLIENT_ControlDevice's param: DH_CTRL_ACCESS_CLOSE
    typedef struct tagNET_CTRL_ACCESS_CLOSE
    {
        DWORD               dwSize;
        int                 nChannelID;             // Channel ID (start from 0)
    }NET_CTRL_ACCESS_CLOSE;
    
    typedef enum tagNET_ALARM_TYPE
    {
        NET_ALARM_LOCAL = 0,                        // SwitchingValue Defence Area's Alarm Information
        NET_ALARM_ALARMEXTENDED,                    // Expand Module Alarm Event)
        NET_ALARM_TEMP,                             // Temperature Alarm Event)
        NET_ALARM_URGENCY,                          // Emergency Alarm Event)
        NET_ALARM_RCEMERGENCYCALL,                  //Emergency call alarm event (corresponding to DH_ALARM_RCEMERGENCY_CALL event )
    }NET_ALARM_TYPE;
    
    // CLIENT_ControlDevice's param: DH_CTRL_CLEAR_ALARM
    typedef struct tagNET_CTRL_CLEAR_ALARM
    {
        DWORD               dwSize;
        int                 nChannelID;             // Defence Area's ID
        NET_ALARM_TYPE      emAlarmType;            // Event Type
        const char*         szDevPwd;               // Landing Equipment Such As Password, Do not Use Encryption Disappear the Police, Direct Assignment of NULL
        BOOL                bEventType;             // Means if enable nEventType field, TRUE:nEventType replaces emAlarmType field, FALSE: use emAlarmType field , ignore nEventType field
        int                 nEventType;             // Event type, corresponding fMessCallBack called lCommand field , as CLIENT_StartListenEx port got event type
        // Such as DH_ALARM_ALARM_EX2 means local alarm event
    }NET_CTRL_CLEAR_ALARM;
    
    // TV Wall Display Information Control Parameters
    typedef struct tagNET_CTRL_MONITORWALL_TVINFO
    {
        DWORD               dwSize;
        int                 nMonitorWallID;         // TV Wall ID
        BOOL                bDecodeChannel;         // Display Decoding Channel Information
    } NET_CTRL_MONITORWALL_TVINFO;
    
    // CLIENT_ControlDevice's param: DH_CTRL_START_VIDEO_ANALYSE
    typedef struct tagNET_CTRL_START_VIDEO_ANALYSE
    {
        DWORD               dwSize;
        int                 nChannelId;             // Channel ID
    }NET_CTRL_START_VIDEO_ANALYSE;
    
    // CLIENT_ControlDevice's param: DH_CTRL_STOP_VIDEO_ANALYSE
    typedef struct tagNET_CTRL_STOP_VIDEO_ANALYSE
    {
        DWORD               dwSize;
        int                 nChannelId;             // Channel ID
    }NET_CTRL_STOP_VIDEO_ANALYSE;
    
    // CLIENT_ControlDevice's param DH_CTRL_MULTIPLAYBACK_CHANNALES
    typedef struct tagNET_CTRL_MULTIPLAYBACK_CHANNALES
    {
        DWORD               dwSize;
        LLONG               lPlayBackHandle;        // Playback Handle??CLIENT_MultiPlayBack Returns the Value
        int                 nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM];// Preview Channel ID
        int                 nChannelNum;            // Preview Channel Number
    }NET_CTRL_MULTIPLAYBACK_CHANNALES;
    
    // CLIENT_ControlDevice's param: DH_CTRL_SET_BYPASS
    typedef struct tagNET_CTRL_SET_BYPASS
    {
        DWORD               dwSize;
        const char*         szDevPwd;               // Login Device Password
        NET_BYPASS_MODE     emMode;                 // Channel Statue
        int                 nLocalCount;            // Local Alarm Input Channel Number
        int*                pnLocal;                // Local Alarm Input Channel ID
        int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
        int*                pnExtended;             // Expand Module Alarm Input Channel ID
    }NET_CTRL_SET_BYPASS;
    
    // CLIENT_QueryDevState's param: DH_DEVSTATE_GET_BYPASS
    typedef struct tagNET_DEVSTATE_GET_BYPASS
    {
        DWORD               dwSize;
        int                 nLocalCount;            // Local Alarm Input Channel Number
        int*                pnLocal;                // Local Alarm Input Channel ID
        int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
        int*                pnExtended;             // Expand Module Alarm Input Channel ID
        NET_BYPASS_MODE*    pemLocal;               // Local Alarm Input Channel Statue
        NET_BYPASS_MODE*    pemExtended;            // Expand Module Alarm Input Channel Statue
    }NET_DEVSTATE_GET_BYPASS;
    
    // CLIENT_QueryDevState's param: DH_DEVSTATE_BURNERDOOR
    typedef struct tagNET_DEVSTATE_BURNERDOOR
    {
        DWORD		        dwSize;
        const char*         szBurnerName;                  // cd name,like "/dev/sda"
        bool                bEjected;                      // ejected or not
        BYTE				Reserved[3];			       // reserved
    }NET_DEVSTATE_BURNERDOOR;
    
    // CLIENT_QueryDevState iterface DH_DEVSTATE_GET_DATA_CHECK
    typedef struct tagNET_DEVSTATE_DATA_CHECK
    {
        DWORD		        dwSize;                     // struct size
        const char*         szBurnerName;               // cd name,like"/dev/s",if it is multiple track, including one of path is ok
        char                szState[DH_MAX_STRING_LEN]; // "NotStart" "Verifying" "Failed" "Succeed"
        int                 nPercent;                   // check percent:0-100,when state  = Verifying,availability.
    }NET_DEVSTATE_DATA_CHECK;
    
    // CLIENT_ListenServer backcall interface, fServiceCallBack support command mode
    enum {
        DH_DVR_DISCONNECT=-1,	                        // Device disconnection callback during the verification period
        DH_DVR_SERIAL_RETURN=1,                         // Device send out SN callback char* szDevSerial
        NET_DEV_AUTOREGISTER_RETURN,                    // when device registering,serial number and token to carry, corresponding NET_CB_AUTOREGISTER
    };
    typedef struct tagNET_CB_AUTOREGISTER
    {
        DWORD			dwSize;                          // struct size
        char            szDevSerial[DH_DEV_SERIALNO_LEN];// device serial
        char            szToken[MAX_PATH];               // token
    }NET_CB_AUTOREGISTER;
    
    // public agency registration
    typedef struct tagCLOUDSERVICE_CONNECT_PARAM
    {
        DWORD               dwSize;
        char                szDstIp[DH_MAX_IPADDR_EX_LEN];    // server IP
        int                 nDstPort;                         // server port
        DWORD               dwConnectType;                    // connect type,0:main connect, 1:the tunnel connection,2:data connect,3:dynamic registration link(use 0xb4)
        char                szToken[MAX_PATH];                // the only id token
    }NET_CLOUDSERVICE_CONNECT_PARAM;
    
    typedef struct tagCLOUDSERVICE_CONNECT_RESULT
    {
        DWORD               dwSize;
        DWORD               dwConnectState;                   // connect state ,1 succeed, 2 failed
        char                szMessage[DH_MAX_CLOUDCONNECT_STATE_LEN]; // connect status info,"Success","Password Error","Network Error","Timeout"
    }NET_CLOUDSERVICE_CONNECT_RESULT;
    ///////////////////////////////definition of configuration///////////////////////////////
    
    //-------------------------------Device Property ---------------------------------
    // Device information
    typedef struct
    {
        BYTE				sSerialNumber[DH_SERIALNO_LEN];	// SN
        BYTE				byAlarmInPortNum;		// DVR alarm input amount
        BYTE				byAlarmOutPortNum;		// DVR alarm output amount
        BYTE				byDiskNum;				// DVR HDD amount
        BYTE				byDVRType;				// DVR type.Please refer to DHDEV_DEVICE_TYPE
        union
        {
            BYTE				byChanNum;				// DVR channel amount
            BYTE            byLeftLogTimes;         // When login failed due to password error, notice user via this parameter, remaining login times??is 0 means this parameter is invalid
        };
    } NET_DEVICEINFO, *LPNET_DEVICEINFO;
    
    // Device extension info
    typedef struct
    {
        BYTE                sSerialNumber[DH_SERIALNO_LEN];	    // serial number
        int	                nAlarmInPortNum;                    // count of DVR alarm input
        int	                nAlarmOutPortNum;                   // count of DVR alarm output
        int	                nDiskNum;                           // number of DVR disk
        int	                nDVRType;                           // DVR type, refer to DHDEV_DEVICE_TYPE
        int                 nChanNum;                           // number of DVR channel
        BYTE                byLimitLoginTime;                   // Online Timeout, Not Limited Access to 0, not 0 Minutes Limit Said
        BYTE                byLeftLogTimes;                     // When login failed due to password error, notice user via this parameter, remaining login times??is 0 means this parameter is invalid	char				Reserved[30];			// reserved
        BYTE                bReserved[2];                       // keep bytes??bytes aligned
        int                 nLockLeftTime;                      // when log in failed??the left time for users to unlock (seconds), -1 indicate the device haven??t set the parameter
        char                Reserved[24];                       // reserved
    } NET_DEVICEINFO_Ex, *LPNET_DEVICEINFO_Ex;
    
    //Device software version information. The higher 16-bit means the main version number and low 16-bit means second version number.
    typedef struct
    {
        DWORD				dwSoftwareVersion;
        DWORD				dwSoftwareBuildDate;
        DWORD				dwDspSoftwareVersion;
        DWORD				dwDspSoftwareBuildDate;
        DWORD				dwPanelVersion;
        DWORD				dwPanelSoftwareBuildDate;
        DWORD				dwHardwareVersion;
        DWORD				dwHardwareDate;
        DWORD				dwWebVersion;
        DWORD				dwWebBuildDate;
    } DH_VERSION_INFO, *LPDH_VERSION_INFO;
    
    // Device software version information. Corresponding to CLIENT_QueryDevState
    typedef struct
    {
        char				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// Serial number
        char				byDevType;							// Device type, please refer to DHDEV_DEVICE_TYPE
        char				szDevType[DH_DEV_TYPE_LEN];			// Device detailed type. String format. It may be null.
        int					nProtocalVer;						// Protocol version number
        char				szSoftWareVersion[DH_MAX_URL_LEN];
        DWORD				dwSoftwareBuildDate;
        char                szPeripheralSoftwareVersion[DH_MAX_URL_LEN];// From the Slice Version Information, The String Format, May Be Empty
        DWORD               dwPeripheralSoftwareBuildDate;
        char                szGeographySoftwareVersion[DH_MAX_URL_LEN]; // Geographical Iinformation Positioning Chip Version Information, The String Format, May Be empty
        DWORD               dwGeographySoftwareBuildDate;
        char				szHardwareVersion[DH_MAX_URL_LEN];
        DWORD				dwHardwareDate;
        char				szWebVersion[DH_MAX_URL_LEN];
        DWORD				dwWebBuildDate;
        char				reserved[256];
    } DHDEV_VERSION_INFO;
    
    // DSP capacity description. Correspondign to CLIENT_GetDevConfig
    typedef struct
    {
        DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
        DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
        DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
        DWORD				dwStreamCap;			// The multiple-media function the devices supported
        // The first bit:main stream
        // The second bit:extra stream 1
        // The third bit:extra stream 2
        // The fifth bit: snapshot in .jpg format
        DWORD				dwImageSizeMask_Assi[8];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
        DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
        WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
        WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not ;0:does not synchronized,1:synchronized
    } DH_DSP_ENCODECAP, *LPDH_DSP_ENCODECAP;
    
    // DSP capacity description. Extensive type. Corresponding to CLIENT_QueryDevState
    typedef struct
    {
        DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
        DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
        DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
        DWORD				dwStreamCap;			// The multiple-media function the devices supported
        // The first bit:main stream
        // The second bit:extra stream 1
        // The third bit:extra stream 2
        // The fifth bit: snapshot in .jpg format
        DWORD				dwImageSizeMask_Assi[32];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
        DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
        WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
        WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
        BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
        BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
        // 0:main stream encode capacity+extra stream encode capacity<= device encode capacity
        // 1:main stream encode capacity +extra stream encode capacity<= device encode capacity
        // Extra stream encode capacity <=main stream encode capacity
        // Extra stream resolution<=main stream resolution
        // Main stream resolution and extra stream resolution <=front-end video collection frame rate
        // 2:N5 Device
        // Extra stream encode capacity <=main stream encode capacity
        // Query  the supported resolution and the corresponding maximum frame rate
        char				reserved[95];
    } DHDEV_DSP_ENCODECAP, *LPDHDEV_DSP_ENCODECAP;
    
    // DSP extend capacity description. Corresponding to CLIENT_QueryDevState
    typedef struct
    {
        DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
        DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
        DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
        DWORD				dwStreamCap;			// The multiple-media function the devices supported.
        // The first bit:main stream
        // The second bit:extra stream 1
        // The third bit:extra stream 2
        // The forth bit:extra stream 3
        // The fifth bit: snapshot in .jpg format
        DWORD				dwImageSizeMask_Assi[3][64];// When the main stream is the corresponding resolution, the supported extra stream resolution mask, the 0,1,2 member in the group correspond extra stream1,2,3
        DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
        WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
        WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
        BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
        BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
        // 0:main stream encode capacity+extra stream encode capacity<= device encode capacity
        // 1:main stream encode capacity +extra stream encode capacity<= device encode capacity
        // Extra stream encode capacity <=main stream encode capacity
        // Extra stream resolution<=main stream resolution
        // Main stream resolution and extra stream resolution <=front-end video collection frame rate
        // 2:N5 Device
        // Extra stream encode capacity <=main stream encode capacity
        // Query  the supported resolution and the corresponding maximum frame rate
        BYTE				btReserve1[3];			// reserved
        DWORD				dwExtraStream;			// bit0-main stream, bit1-extra stream1, bit2-extra stream2
        DWORD				dwCompression[3];		// extra stream compression
        
        char				reserved[108];
    } DHDEV_DSP_ENCODECAP_EX, *LPDHDEV_DSP_ENCODECAP_EX;
    
    // System information
    typedef struct
    {
        DWORD				dwSize;
        /* The following are read only for device. */
        DH_VERSION_INFO		stVersion;
        DH_DSP_ENCODECAP	stDspEncodeCap;			// DSP  capacity description
        BYTE				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// SN
        BYTE				byDevType;				// device type. Please refer to enumeration DHDEV_DEVICE_TYPE
        BYTE				szDevType[DH_DEV_TYPE_LEN];	// Device detailed type. String format. It may be empty.
        BYTE				byVideoCaptureNum;		// Video port amount
        BYTE				byAudioCaptureNum;		// Audio port amount
        BYTE				byTalkInChanNum;		// NSP
        BYTE				byTalkOutChanNum;		// NSP
        BYTE				byDecodeChanNum;		// NSP
        BYTE				byAlarmInNum;			// Alarm input port amount
        BYTE				byAlarmOutNum;			// Alarm output amount port
        BYTE				byNetIONum;				// network port amount
        BYTE				byUsbIONum;				// USB USB port amount
        BYTE				byIdeIONum;				// IDE amount
        BYTE				byComIONum;				// COM amount
        BYTE				byLPTIONum;				// LPT amount
        BYTE				byVgaIONum;				// NSP
        BYTE				byIdeControlNum;		// NSP
        BYTE				byIdeControlType;		// NSP
        BYTE				byCapability;			// NSP, expansible description
        BYTE				byMatrixOutNum;			// video matrix output amount
        /* The following are read-write part for device */
        BYTE				byOverWrite;			// Operate when HDD is full(overwrite/stop)
        BYTE				byRecordLen;			// Video file Package length
        BYTE				byDSTEnable;			// Enable  DTS or not  1--enable. 0--disable
        WORD				wDevNo;					// Device serial number. Remote control can use this SN to control.
        BYTE				byVideoStandard;		// Video format
        BYTE				byDateFormat;			// Date format
        BYTE				byDateSprtr;			// Date separator(0:".",1:"-",2:"/")
        BYTE				byTimeFmt;				// Time separator  (0-24H,1-12H)
        BYTE				byLanguage;				// Please refer to DH_LANGUAGE_TYPE for enumeration value
    } DHDEV_SYSTEM_ATTR_CFG, *LPDHDEV_SYSTEM_ATTR_CFG;
    
    // The returned information after modify device
    typedef struct
    {
        DWORD				dwType;					// Type (type of GetDevConfig and SetDevConfig)
        WORD				wResultCode;			// Returned bit;0:succeeded,1:failed,2:illegal data,3:can not set right now,4:have no right
        WORD   				wRebootSign;			// Reboot symbol;0:do not need to reboot,1:need to reboot to get activated
        DWORD				dwReserved[2];			// Reserved
    } DEV_SET_RESULT;
    
    // play result
    typedef struct
    {
        DWORD              dwResultCode;            // result code,
        // 1:no authority,2:device not support,3:insufficient resources,4:get data error,
        // 11:resouces are taked by advance users, 12:forbidden, 13:limited from reading disk data
        // 14:multi window preview already open, out of resource, compressed playback failed, 15: compressed playback already open
        LLONG               lPlayHandle;            // play handle
        BYTE               byReserved[32];          // reserved
        
    }DEV_PLAY_RESULT;
    
    // request audio tal error return info
    typedef struct
    {
        DWORD               dwResultCode;               // error return code CLIENT_GetLastError port return value
        // NET_ERROR_TALK_REJECT _EC(375) // refuse talk
        // NET_ERROR_TALK_RESOURCE_CONFLICIT _EC(377) // resource conflict
        // NET_ERROR_TALK_UNSUPPORTED_ENCODE _EC(378) // not support talk encode format
        // NET_ERROR_TALK_RIGHTLESS _EC(379) // no right
        LLONG               lTalkHandle;                // correspoinding handle
        BYTE                byReserved[32];             // reserved text
    }DEV_TALK_RESULT;
    
    //DST(Daylight Save Time) setup
    typedef struct
    {
        int					nYear;					// Year[200 - 2037]
        int					nMonth;					// Month[1 - 12]
        int					nHour;					// Hour[0 - 23]
        int					nMinute;				// Minute [0 - 59]
        int					nWeekOrDay;				// [-1 - 4]0:It means it adopts the date calculation method.
        // 1:in week: the first week ,2:the second week,3:the third week,4: The fourth week ,-1: the last week
        union
        {
            int				iWeekDay;				// week[0 - 6](nWeekOrDay:calculated in week )0: Sunday, 1:Monday , 2:Tuesday ,3: Wednesday,4:Thirsday ,5: Friday,6:Saturday
            int				iDay;					// date[1 - 31] (nWeekOrDay: in date)
        };
        
        DWORD				dwReserved[8];			// Reserved
    }DH_DST_POINT;
    
    typedef struct
    {
        DWORD				dwSize;
        int					nDSTType;				// DST position way. 0: position in date  , 1:position in week
        DH_DST_POINT        stDSTStart;             // Enable DTS
        DH_DST_POINT        stDSTEnd;				// End DTS
        DWORD				dwReserved[16];			// Reserved
    }DHDEV_DST_CFG;
    
    
    // Auto maintenance setup
    typedef struct
    {
        DWORD				dwSize;
        BYTE				byAutoRebootDay;		// Auto reboot;0:never, 1:each day,2:each Sunday,3:Each Monday ,......
        BYTE				byAutoRebootTime;		// 0:0:00,1:1:00,......23:23:00
        BYTE				byAutoDeleteFilesTime;	// Auto delete file;0:never,1:24H,2:48H,3:72H,4:96H,5:ONE WEEK,6:ONE MONTH
        BYTE				reserved[13];			// Reserved bit
    } DHDEV_AUTOMT_CFG;
    
    // car's disk info
    typedef struct
    {
        DWORD				dwSize;										// struct size,must initialize
        DWORD				dwVolume;									// disk volume
        DWORD				dwFreeSpace;								// free space MB
        BYTE				byModle[DH_MAX_HARDDISK_TYPE_LEN];			// disk mode
        BYTE				bySerialNumber[DH_MAX_HARDDISK_SERIAL_LEN];	// serial number
    }DHDEV_VEHICLE_DISK;
    
    // car's 3G mode info,the largest support DH_MAX_SIM_NUM
    typedef struct
    {
        DWORD				dwSize;						// struct size,must initialize
        BYTE				szIMSI[DH_MAX_SIM_LEN];		// SIM's value = 460012002778636,top three for the country code MCC,4-6for the network code MNC,the last is MSIN,a total of not more than 15 characters
        BYTE				szMDN[DH_MAX_MDN_LEN];		// MDN
    }DHDEV_VEHICLE_3GMODULE;
    
    // car basic info
    typedef struct
    {
        DWORD					dwSize;								// struct size,must initialize
        DWORD					dwSoftwareBuildDate;				// soft ware build date
        char					szVersion[DH_MAX_VERSION_LEN];		// version
        char					szDevSerialNo[DH_DEV_SERIALNO_LEN];	// device serial no.
        char					szDevType[DH_DEV_TYPE_LEN];			// device type,string format,can empty
        DWORD					dwDiskNum;							// disk number
        DHDEV_VEHICLE_DISK		stuHarddiskInfo[DH_MAX_DISKNUM];	// disk info
        DWORD					dw3GModuleNum;						// count of 3G module
        DHDEV_VEHICLE_3GMODULE	stu3GModuleInfo[DH_MAX_SIM_NUM];	// 3G module info
    }DHDEV_VEHICLE_INFO;
    
    // net interface,the largest support DH_MAX_NETINTERFACE_NUM
    typedef struct tagDHDEV_NETINTERFACE_INFO
    {
        int             dwSize;
        BOOL			bValid;								// valid or not
        BOOL			bVirtual;							// support virtual or not
        int             nSpeed;								// theory of speed (Mbps)
        int             nDHCPState;							// 0-disable, 1-getting, 2-get succeed
        char			szName[DH_NETINTERFACE_NAME_LEN];	// net port mane
        char			szType[DH_NETINTERFACE_TYPE_LEN];	// net type
        char			szMAC[DH_MACADDR_LEN];			    // MAC addr
        char			szSSID[DH_MAX_SSID_LEN];			// SSID, if only szType == "Wireless",availability
        char            szConnStatus[DH_MAX_CONNECT_STATUS_LEN]; // Wifi,3G connect status,"Inexistence" : not exist, "Down": close "Disconn": disconnect "Connecting" "Connected"
        int             nSupportedModeNum;                  // support mode number
        char            szSupportedModes[DH_MAX_MODE_NUM][DH_MAX_MODE_LEN];// support 3G net mode	"TD-SCDMA", "WCDMA", "CDMA1x", "EDGE", "EVDO"
    } DHDEV_NETINTERFACE_INFO;
    //-----------------------------Video Channel Property -------------------------------
    
    // Time period structure
    typedef struct
    {
        int				bEnable;				// Current record period . Bit means the four Enable functions. From the low bit to the high bit:Motion detection record, alarm record and general record, when Motion detection and alarm happened at the same time can record.
        int					iBeginHour;
        int					iBeginMin;
        int					iBeginSec;
        int					iEndHour;
        int					iEndMin;
        int					iEndSec;
    } DH_TSECT, *LPDH_TSECT;
    
    // Zone;Each margin is total lenght :8192
    typedef struct
    {
        long					left;
        long					top;
        long					right;
        long					bottom;
    } DH_RECT, *LPDH_RECT;
    
    typedef struct tagNET_RECT
    {
        int             nLeft;
        int             nTop;
        int             nRight;
        int             nBottom;
    } NET_RECT;
    
    // 2 dimension point
    typedef struct
    {
        short					nx;
        short					ny;
    } DH_POINT, *LPDH_POINT;
    
    //
    typedef struct
    {
        int        nPointNum;                           // point number
        DH_POINT   stuPoints[DH_MAX_DETECT_REGION_NUM]; // point info
    }DH_POLY_POINTS;
    
    // struct of OSD attribute
    typedef struct  tagENCODE_WIDGET
    {
        DWORD				rgbaFrontground;		// Object front view. Use bit to represent:red, green, blue and transparency.
        DWORD				rgbaBackground;			// Object back ground. Use bit to represent:red, green, blue and transparency.
        DH_RECT				rcRect;					// Position
        BYTE				bShow;					// Enable display
        BYTE                bExtFuncMask;           // Extended function,mask
        // bit0 indicate week showing,0-not show 1-show
        BYTE				byReserved[2];
    } DH_ENCODE_WIDGET, *LPDH_ENCODE_WIDGET;
    
    // Channel audio property
    typedef struct
    {
        // Video property
        BYTE				byVideoEnable;			// Enable video;1:open,0:close
        BYTE				byBitRateControl;		// Bit stream control;Please refer to constant Bit Stream Control definition
        BYTE				byFramesPerSec;			// Frame rate
        BYTE				byEncodeMode;			// Encode mode:please refer to constant Encode Mode definition
        BYTE				byImageSize;			// Resolution:please refer to constant Resolution definition.
        BYTE				byImageQlty:7;			// Level 1-6
        BYTE                byImageQltyType:1;
        WORD				wLimitStream;			// Limit stream parameter
        // Audio property
        BYTE				byAudioEnable;			// Enable audio;1:open,0:close
        BYTE				wFormatTag;				// Audio encode mode:0:G711A,1:PCM,2:G711U,3:AMR,4:AAC
        WORD				nChannels;				// Track amount
        WORD				wBitsPerSample;			// Sampling depth
        BYTE				bAudioOverlay;			// Enabling audio
        BYTE				bH264ProfileRank;       // H.264 Profile rank(when byEncodeMode is h264, this value works ), see enmu struct EM_H264_PROFILE_RANK,when this value is 0, it means nothing
        DWORD				nSamplesPerSec;			// Sampling rate
        BYTE				bIFrameInterval;		// 0-149. I frame interval amount. Describe the P frame amount between two I frames.
        BYTE				bScanMode;				// NSP
        BYTE				bReserved_3;
        BYTE				bReserved_4;
    } DH_VIDEOENC_OPT, *LPDH_VIDEOENC_OPT;
    
    // Image color property
    typedef struct
    {
        DH_TSECT			stSect;
        BYTE				byBrightness;			// Brightness:0-100
        BYTE				byContrast;				// Contrast:0-100
        BYTE				bySaturation;			// Saturation:0-100
        BYTE				byHue;					// Hue:0-100
        BYTE				byGainEn;				// Enable gain
        BYTE				byGain;					// Gain:0-100
        BYTE				byGamma;                // gamma 0-100
        BYTE				byReserved[1];
    } DH_COLOR_CFG, *LPDH_COLOR_CFG;
    
    // Image channel property structure
    typedef struct
    {
        WORD				dwSize;
        BYTE				bNoise;
        BYTE				bMode;   // (vehicle's special need)model 1 (quality first): 4-way video resolution D1, frame rate 2fps, bit rate 128kbps(225MB per hour)
        // Mode 2 (fluency preferred): 4-way video resolution CIF, frame rate of 12fps, bit rate 256kbps (550MB per hour)
        // Mode 3 (Custom) video resolution can be defined by the user, limited the maximum capacity of 4CIF/25fps
        char				szChannelName[DH_CHAN_NAME_LEN];
        DH_VIDEOENC_OPT		stMainVideoEncOpt[DH_REC_TYPE_NUM];
        DH_VIDEOENC_OPT		stAssiVideoEncOpt[DH_N_ENCODE_AUX];
        DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
        DH_ENCODE_WIDGET	stTimeOSD;
        DH_ENCODE_WIDGET	stChannelOSD;
        DH_ENCODE_WIDGET	stBlindCover[DH_N_COVERS];	// Single privacy mask zone
        BYTE				byBlindEnable;				// Privacy mask zone enable button;0x00:disable privacy mask ,0x01:privacy mask local preview ,0x10:privacy mask record and network preview,0x11: Privacy mask all
        BYTE				byBlindMask;				// Privacy mask zone subnet mask. The first bit; device local preview ;The second bit :record (and network preview ) */
        BYTE				bVolume;					// volume(0~100)
        BYTE				bVolumeEnable;				// volume enable
    } DHDEV_CHANNEL_CFG, *LPDHDEV_CHANNEL_CFG;
    
    // Preview image property
    typedef struct
    {
        DWORD				dwSize;
        DH_VIDEOENC_OPT		stPreView;
        DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
    }DHDEV_PREVIEW_CFG;
    
    // snap control configuration
    typedef struct _config_snap_control
    {
        BYTE               bySnapState[32];           // every channel's snap on-off: 0 Autumn(other configuration and event will control whether snap picture ); 1: turn on snap; 2: turn off snap
        BYTE               byReserved[480];
    }DHDEV_SNAP_CONTROL_CFG;
    
    enum _gps_mode
    {
        GPS_OR_GLONASS_MODE,	// GPS,GLONASS
        GLONASS_MODE,			// GLONASS
        GPS_MODE,				// GPS
    };
    // DH_DEV_GPS_MODE_CFG configuration
    typedef struct tagDHDEV_GPS_MODE_CFG
    {
        BYTE				byGPSMode; // GPS mode
        BYTE				byRev[255];
    }DHDEV_GPS_MODE_CFG;
    
    // snap upload DH_DEV_SNAP_UPLOAD_CFG configuration
    typedef struct tagDHDEV_SNAP_UPLOAD_CFG
    {
        int					nUploadInterval;		// the interval time of upload picture(s)
        BYTE				byReserved[252];
    }DHDEV_SNAP_UPLOAD_CFG;
    
    // DH_DEV_SPEED_LIMIT_CFG configuration
    typedef struct tagDHDEV_SPEED_LIMIT_CFG
    {
        BYTE       byEnable;						// Enable speed limit;1:enable,0:disable
        BYTE       byReserved1;
        WORD       wMaxSpeed;						// upper speed(KM/H) 0: none limit speed, >0:limit speed
        WORD       wMinSpeed;						// low speed(KM/H) 0: none limit speed, >0:limit speed
        BYTE       byReserved2[122];
    }DHDEV_SPEED_LIMIT_CFG;
    
    // wireless routing config
    typedef struct
    {
        BOOL		bEnable;						// enable
        char		szSSID[36];						// SSID
        BOOL		bHideSSID;						// hide SSID
        char		szIP[DH_MAX_IPADDR_LEN];		// IP
        char		szSubMark[DH_MAX_IPADDR_LEN];	// sub mark
        char		szGateWay[DH_MAX_IPADDR_LEN];	// gateway
        char		szCountry[32];					// country
        int			nSafeType;						// safe type: 1-no encryption; 2-WEP; 2-WPA-PSK; 3-WPA2-PSK
        int			nEncryption;					// encryption: WEP(1-auto 2-open 3-shareable); WPA-PSK/WPA2-PSK(4-TKIP 5-AES)
        char		szKey[32];						// key
        int			nChannel;						// channel
        BOOL		bAutoChannelSelect;				// auto channel select
    }DHDEV_WIRELESS_ROUTING_CFG;
    
    //-------------------------------COM property ---------------------------------
    
    // COM basic property
    typedef struct
    {
        BYTE				byDataBit;				// Data bit;0:5,1:6,2:7,3:8
        BYTE				byStopBit;				// Stop bit;0:1 bit,1:1.5 bit,2:2 bits
        BYTE				byParity;				// Parity;0: None,1: Odd;2: even;3:sign;4:empty
        BYTE				byBaudRate;				// Baud rate;0:300,1:600,2:1200,3:2400,4:4800,
        // 5:9600,6:19200,7:38400,8:57600,9:115200
    } DH_COMM_PROP;
    
    // 485 decoder setup
    typedef struct
    {
        DH_COMM_PROP		struComm;
        BYTE				wProtocol;				// Protocol type. Corresponding to the subscript of Protocol Name List
        BYTE				bPTZType;				// 0-Compatible,local ptz 1-remote network ptz, the capability refer to DEV_ENCODER_CFG.
        BYTE				wDecoderAddress;		// Decoder address;0 - 255
        BYTE 				byMartixID;				// Matrix number
    } DH_485_CFG;
    
    // 232 COM setup
    typedef struct
    {
        DH_COMM_PROP		struComm;
        BYTE				byFunction;				// COM function,Corresponding to the subscript of Function Name list.
        BYTE				byReserved[3];
    } DH_RS232_CFG;
    
    // COM configuration structure
    typedef struct
    {
        DWORD				dwSize;
        
        DWORD				dwDecProListNum;										// Decoder protocol amount
        char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];	// Protocol name list
        DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];							// Each decoder current property
        
        DWORD				dw232FuncNameNum;										// 232 function amount
        char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];			// Function name list
        DH_RS232_CFG		st232[DH_MAX_232_NUM];									// Current 232 COM property
    } DHDEV_COMM_CFG;
    
    // Extended COM configuration structure
    typedef struct
    {
        DWORD				dwSize;
        
        DWORD				dwDecProListNum;			                           // Decoder protocol amount
        char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];  // Protocol name list
        DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];						   // Each decoder current property
        
        DWORD				dw232FuncNameNum;									   // 232 function amount
        char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];	       // Function name list
        DWORD               dw232ComNum;										   // 232 com amount
        DH_RS232_CFG		st232[DH_MAX_232_NUM_EX];	                           // Current 232 COM property
    } DHDEV_COMM_CFG_EX;
    
    // Serial port status
    typedef struct
    {
        unsigned int		uBeOpened;
        unsigned int		uBaudRate;
        unsigned int		uDataBites;
        unsigned int		uStopBits;
        unsigned int		uParity;
        BYTE				bReserved[32];
    } DH_COMM_STATE;
    
    //-------------------------------Record configuration---------------------------------
    
    // Scheduled record
    typedef struct
    {
        DWORD				dwSize;
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        BYTE				byPreRecordLen;			// Pre-record button. Unit is second. 0 means disable pre-record
        BYTE				byRedundancyEn;			// Record redundant enable button
        BYTE                byRecordType;           // Video bit-stream type:0:Main Stream 1:Assist Stream1 2:Assist Stream2 3:Assist Stream3
        BYTE				byReserved;
    } DHDEV_RECORD_CFG, *LPDH_RECORD_CFG;
    
    // NTP setup
    typedef struct
    {
        BOOL				bEnable;				// Enable or not
        int					nHostPort;				// NTP  server default port is 123
        char				szHostIp[32];			// Host IP
        char				szDomainName[128];		// Domain name
        int					nType;					// Read only ,0:IP,1:domain name ,2:IP and domain name
        int					nUpdateInterval;		// Update time(minute)
        int					nTimeZone;				// Please refer to DH_TIME_ZONE_TYPE
        char				reserved[128];
    } DHDEV_NTP_CFG;
    
    // FTP upload setup
    typedef struct
    {
        struct
        {
            DH_TSECT		struSect;				// Enable function is disabled during the period. Can ignore
            BOOL			bMdEn;					// Upload motion detection record
            BOOL			bAlarmEn;				// Upload external alarm record
            BOOL			bTimerEn;				// Upload scheduled record
            DWORD			dwRev[4];
        } struPeriod[DH_TIME_SECTION];
    } DH_FTP_UPLOAD_CFG;
    
    typedef struct
    {
        DWORD				dwSize;
        BOOL				bEnable;							// Enable or not
        char				szHostIp[DH_MAX_IPADDR_LEN];		// Host IP
        WORD				wHostPort;							// Host port
        char				szDirName[DH_FTP_MAX_PATH];			// FTP path
        char				szUserName[DH_FTP_USERNAME_LEN];	// User name
        char				szPassword[DH_FTP_PASSWORD_LEN];	// Password
        int					iFileLen;							// File length
        int					iInterval;							// Time interval between two near files.
        DH_FTP_UPLOAD_CFG	struUploadCfg[DH_MAX_CHANNUM][DH_N_WEEKS];
        char 				protocol;							// 0-FTP 1-SMB 2-NFS,3-ISCSI
        char				NASVer;								// Network storage server version 0=Old FTP(There is time period in the user interface),1=NAS storage(There is no time period in the user interface. )
        DWORD				dwFunctionMask;						// Function capacity mask. Use bit to represent. Lower 16-bit:FTP,SMB,NFS, ISCSI and higher 16-bit:(Local storage)DISK,U
        BYTE                bDataType;                          // data type, 0-all, 1-video, 2-image
        BYTE 				reserved[123];
    } DHDEV_FTP_PROTO_CFG;
    
    // extend FTP upload setup (support setting the FTP's path, maximal picture number)
    typedef struct
    {
        int            nMaxPictures;                             // the maximal number of the FTP can save,can set limit of the picture number in the every chennel's direct;
        // if the saved picture number extended the limit the old picture will be covered by new one; the value 0 indecate that it will save picture untill the disck was full.
        char           szPreChannelName[DH_FTP_MAX_SUB_PATH];    // the picture named mod
        char           szFTPChannelPath[DH_FTP_MAX_SUB_PATH];    // the FTP's sub direction
        char           szRev[128];                               // reserved
    }DHDEV_FTP_CHANNEL_CFG;
    
    
    typedef struct
    {
        DHDEV_FTP_PROTO_CFG      stuFtpNormalSet;                // the normal function of the FTP
        DHDEV_FTP_CHANNEL_CFG     stuFtpChannelSet[DH_MAX_CHANNUM]; // the extended function of the FTP
        char                      szRev[128];                    // reserved
    }DHDEV_FTP_PROTO_CFG_EX;
    
    //-------------------------------Network Configuration---------------------------------
    
    // Ethernet Configuration
    typedef struct
    {
        char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
        char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask
        char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address
        
        /*
         * 1:10Mbps full-duplex
         * 2:10Mbps auto-duplex
         * 3:10Mbps half-duplex
         * 4:100Mbps full-duplex
         * 5:100Mbps auto-duplex
         * 6:100Mbps half-duplex
         * 7:auto
         */
        // Divide DWORD into four to future development
        BYTE				dwNetInterface;			// NSP
        BYTE				bTranMedia;				// 0:cable,1:wireless
        BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
        BYTE				bDefaultEth;			// To be the default network card or not.  1: default 0:non-default
        char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only.,
    } DH_ETHERNET;
    
    // Remote host setup
    typedef struct
    {
        BYTE				byEnable;				// Enable connection
        BYTE				byAssistant;            // Only for PPPoE server,0:on the cabled network; 1:on the wireless network
        WORD				wHostPort;				// Remote host Port
        char				sHostIPAddr[DH_MAX_IPADDR_LEN];		// Remote host IP address
        char				sHostUser[DH_MAX_HOST_NAMELEN];		// Remote host User name
        char				sHostPassword[DH_MAX_HOST_PSWLEN];	// Remote host Password
    } DH_REMOTE_HOST;
    
    // Mail setup
    typedef struct
    {
        char				sMailIPAddr[DH_MAX_IPADDR_LEN];		// Email server IP
        WORD				wMailPort;							// Email server port
        WORD				wReserved;							// Reserved
        char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];	// Send out address
        char				sUserName[DH_MAX_NAME_LEN];			// User name
        char				sUserPsw[DH_MAX_NAME_LEN];			// User password
        char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];	// Destination address
        char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];		// CC address
        char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];		// BCC address
        char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];	// Subject
    } DH_MAIL_CFG;
    
    // Network configuration structure
    typedef struct
    {
        DWORD				dwSize;
        char				sDevName[DH_MAX_NAME_LEN];	// Device host name
        WORD				wTcpMaxConnectNum;		// TCP max connection amount
        WORD				wTcpPort;				// TCP listening port
        WORD				wUdpPort;				// UDP listening port
        WORD				wHttpPort;				// HTTP port number
        WORD				wHttpsPort;				// HTTPS port number
        WORD				wSslPort;				// SSL port number
        DH_ETHERNET			stEtherNet[DH_MAX_ETHERNET_NUM];	// Ethernet port
        
        DH_REMOTE_HOST		struAlarmHost;			// Alarm server
        DH_REMOTE_HOST		struLogHost;			// Log server
        DH_REMOTE_HOST		struSmtpHost;			// SMTP server
        DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group
        DH_REMOTE_HOST		struNfs;				// NFS server
        DH_REMOTE_HOST		struPppoe;				// PPPoE server
        char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration
        DH_REMOTE_HOST		struDdns;				// DDNS server
        char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
        DH_REMOTE_HOST		struDns;				// DNS server
        DH_MAIL_CFG			struMail;				// Email setup
    } DHDEV_NET_CFG;
    
    // Ethernet extended Configuration
    typedef struct
    {
        char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
        char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask
        char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address
        
        /*
         * 1:10Mbps full-duplex
         * 2:10Mbps auto-duplex
         * 3:10Mbps half-duplex
         * 4:100Mbps full-duplex
         * 5:100Mbps auto-duplex
         * 6:100Mbps half-duplex
         * 7:auto
         */
        // Divide DWORD into four to future development
        BYTE				dwNetInterface;			// NSP
        BYTE				bTranMedia;				// 0:cable,1:wireless
        BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
        BYTE				bDefaultEth;			//To be the default network card or not.  1: default 0:non-default
        char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only.
        BYTE                bMode;                  // mode, 1:balance, 2:multi, 3:fault-toerant
        BYTE                bReserved1[3];          // reserved
        char                szEthernetName[DH_MAX_NAME_LEN];    // Card name, read only
        BYTE                bReserved[12];                      // reserved
    } DH_ETHERNET_EX;
    
    // Network extended configuration structure
    typedef struct
    {
        DWORD				dwSize;
        char				sDevName[DH_MAX_NAME_LEN];	// Device host name
        WORD				wTcpMaxConnectNum;		// TCP max connection amount
        WORD				wTcpPort;				// TCP listening port
        WORD				wUdpPort;				// UDP listening port
        WORD				wHttpPort;				// HTTP port number
        WORD				wHttpsPort;				// HTTPS port number
        WORD				wSslPort;				// SSL port number
        int                 nEtherNetNum;           // Ethernet port number
        DH_ETHERNET_EX		stEtherNet[DH_MAX_ETHERNET_NUM_EX];	// Ethernet info
        
        DH_REMOTE_HOST		struAlarmHost;			// Alarm server
        DH_REMOTE_HOST		struLogHost;			// Log server
        DH_REMOTE_HOST		struSmtpHost;			// SMTP server
        DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group
        DH_REMOTE_HOST		struNfs;				// NFS server
        DH_REMOTE_HOST		struPppoe;				// PPPoE server
        char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration
        DH_REMOTE_HOST		struDdns;				// DDNS server
        char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
        DH_REMOTE_HOST		struDns;				// DNS server
        DH_MAIL_CFG			struMail;				// Email setup
        BYTE                bReserved[128];         // reserved
    } DHDEV_NET_CFG_EX;
    
    // ddns configuraiton structure
    typedef struct
    {
        DWORD				dwId;					// ddns server id
        BOOL				bEnable;				// Enable. There is only one valid ddns server at one time.
        char				szServerType[DH_MAX_SERVER_TYPE_LEN];	// Server type. www.3322.org.
        char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// Server IP or domain name
        DWORD				dwServerPort;			// Server port
        char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// DVR domain name such as jeckean.3322.org
        char				szUserName[DH_MAX_HOST_NAMELEN];		// User name
        char				szUserPsw[DH_MAX_HOST_PSWLEN];			// Password
        char				szAlias[DH_MAX_DDNS_ALIAS_LEN];			// Server alias
        DWORD				dwAlivePeriod;							// DDNS alive period
        BYTE				ByMode;									// domain mode:0-manual,szDomainName enable; 1-default szDefaultDomainName enable
        char				szDefaultDomainName[DH_MAX_DEFAULT_DOMAIN_LEN];// default domain, real only
        BYTE                bReserved[3];                           // Text align
        char                szEmailUserName[DH_MAX_MAIL_NAME_LEN];	// Mail username
        char                reserved[128];
    } DH_DDNS_SERVER_CFG;
    
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwDdnsServerNum;
        DH_DDNS_SERVER_CFG	struDdnsServer[DH_MAX_DDNS_NUM];
    } DHDEV_MULTI_DDNS_CFG;
    
    // Mail configuration structure
    typedef struct
    {
        char				sMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];	// Mail server address(IP and domain name )
        char				sSubMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];
        WORD				wMailPort;								// Mail server port
        WORD				wSubMailPort;
        WORD				wReserved;								// Reserved
        char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];		// From
        char				sUserName[DH_MAX_MAIL_NAME_LEN];		// User name
        char				sUserPsw[DH_MAX_MAIL_NAME_LEN];			// password
        char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];		// To
        char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];			// CC
        char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];			// BCC
        char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];		// Subject
        BYTE				bEnable;								// Enable 0:false,	1:true
        BYTE				bSSLEnable;								// SSL enable
        WORD				wSendInterval;							// Send interval,[0,3600]s
        BYTE				bAnonymous;								// Anonymous Options[0,1], 0:FALSE,1:TRUE.
        BYTE				bAttachEnable;							// Attach enable[0,1], 0:FALSE,1:TRUE.
        char				reserved[154];
    } DHDEV_MAIL_CFG;
    
    // DNS server setup
    typedef struct
    {
        char				szPrimaryIp[DH_MAX_IPADDR_LEN];
        char				szSecondaryIp[DH_MAX_IPADDR_LEN];
        char				reserved[256];
    } DHDEV_DNS_CFG;
    
    // Record download strategy setup
    typedef struct
    {
        DWORD				dwSize;
        BOOL				bEnable;				// TRUE: high-speed download,FALSE:general download
    }DHDEV_DOWNLOAD_STRATEGY_CFG;
    
    // Network transmission strategy setup
    typedef struct
    {
        DWORD				dwSize;
        BOOL				bEnable;
        int					iStrategy;				// 0: video quality,1:fluency ,2: auto
    }DHDEV_TRANSFER_STRATEGY_CFG;
    
    // The corresponding parameter when setting log in
    typedef struct
    {
        int					nWaittime;				// Waiting time(unit is ms), 0:default 5000ms.
        int					nConnectTime;			// Connection timeout value(Unit is ms), 0:default 1500ms.
        int					nConnectTryNum;			// Connection trial times(Unit is ms), 0:default 1.
        int					nSubConnectSpaceTime;	// Sub-connection waiting time(Unit is ms), 0:default 10ms.
        int					nGetDevInfoTime;		// Access to device information timeout, 0:default 1000ms.
        int					nConnectBufSize;		// Each connected to receive data buffer size(Bytes), 0:default 250*1024
        int					nGetConnInfoTime;		// Access to sub-connect information timeout(Unit is ms), 0:default 1000ms.
        int                 nSearchRecordTime;      // Timeout value of search video (unit ms), default 3000ms
        int                 nsubDisconnetTime;      // dislink disconnect time,0:default 60000ms
        BYTE				byNetType;				// net type, 0-LAN, 1-WAN
        BYTE                byPlaybackBufSize;      // playback data from the receive buffer size(m),when value = 0,default 4M
        BYTE                byReserved1[2];         // reserve
        int                 nPicBufSize;            // actual pictures of the receive buffer size(byte)when value = 0,default 2*1024*1024
        BYTE				bReserved[4];			// reserved
    } NET_PARAM;
    
    // Corresponding to CLIENT_SearchDevices
    typedef struct
    {
        char				szIP[DH_MAX_IPADDR_LEN];				// IP
        int					nPort;													// Port
        char				szSubmask[DH_MAX_IPADDR_LEN];		// Subnet mask
        char				szGateway[DH_MAX_IPADDR_LEN];		// Gateway
        char				szMac[DH_MACADDR_LEN];					// MAC address
        char				szDeviceType[DH_DEV_TYPE_LEN];	// Device type
        BYTE        byManuFactory;				    			// manufactory
        BYTE        byIPVersion;                    // 4: IPv4, szXXX is in format with dot; 6:IPv6, szXXX is 128-bit *16 bytes) numerical format
        BYTE				bReserved[30];									// reserved
    } DEVICE_NET_INFO;
    
    // Corresponding to CLIENT_StartSearchDevices
    typedef struct
    {
        int                 iIPVersion;                      // 4 for IPV4, 6 for IPV6
        char				szIP[64];		                 // IP IPV4 like"192.168.0.1" IPV6 like "2008::1/64"
        int				    nPort;		                     // port
        char				szSubmask[64];	                 // Subnet mask(IPV6 do not have subnet mask)
        char				szGateway[64];	                 // Gateway
        char				szMac[DH_MACADDR_LEN];           // MAC address
        char				szDeviceType[DH_DEV_TYPE_LEN];	 // Device type
        BYTE                byManuFactory;				     // device manufactory, see EM_IPC_TYPE
        BYTE                byDefinition;                    // 1-Standard definition 2-High definition
        bool                bDhcpEn;                         // Dhcp, true-open, false-close
        BYTE                byReserved1;                     // reserved
        char                verifyData[88];                  // ECC data
        char                szSerialNo[DH_DEV_SERIALNO_LEN]; // serial no
        char                szDevSoftVersion[DH_MAX_URL_LEN];// soft version
        char                szDetailType[DH_DEV_TYPE_LEN];   // device detail type
        char                szVendor[DH_MAX_STRING_LEN];     // OEM type
        char                szDevName[DH_MACHINE_NAME_NUM];  // device name
        char                szUserName[DH_USER_NAME_LENGTH_EX];  // user name for log in device(it need be filled when modify device ip)
        char                szPassWord[DH_USER_NAME_LENGTH_EX];  // pass word for log in device(it need be filled when modify device ip)
        unsigned short		nHttpPort;							 // HTTP server port
        WORD                wVideoInputCh;                       // count of video input channel
        WORD                wRemoteVideoInputCh;                 // count of remote video input
        WORD                wVideoOutputCh;                      // count of video output channel
        WORD                wAlarmInputCh;                       // count of alarm input
        WORD                wAlarmOutputCh;                      // count of alarm output
        char                cReserved[244];
    }DEVICE_NET_INFO_EX;
    
    // Corresponding to CLIENT_SearchDevicesByIPs
    typedef struct
    {
        DWORD               dwSize;                          // struct size
        int                 nIpNum;                          // the IPs number for search
        char                szIP[DH_MAX_SAERCH_IP_NUM][64];  // the IPs for search
    }DEVICE_IP_SEARCH_INFO;
    
    // struct SNMP config struct
    typedef struct
    {
        BOOL                bEnable;                                // SNMP enable
        int                 iSNMPPort;                              // SNMP port
        char                szReadCommon[DH_MAX_SNMP_COMMON_LEN];   // read common
        char                szWriteCommon[DH_MAX_SNMP_COMMON_LEN];  // write common
        char                szTrapServer[64];                       // trap address
        int                 iTrapPort;                              // trap port
        BYTE				bSNMPV1;								// SNMP V1 enable
        BYTE				bSNMPV2;								// SNMP V2 enable
        BYTE				bSNMPV3;								// SNMP V3 enable
        char                szReserve[125];
    }DHDEV_NET_SNMP_CFG;
    
    // ISCSI server
    typedef struct
    {
        char				szServerName[32];				// name
        union
        {
            BYTE	c[4];
            WORD	s[2];
            DWORD	l;
        }					stuIP;							// IP
        int					nPort;							// port
        char				szUserName[32];					// username
        char				szPassword[32];					// password
        BOOL				bAnonymous;						// anonymous
    }DHDEV_ISCSI_SERVER;
    
    // ISCSI config
    typedef struct
    {
        BOOL				bEnable;						// enable
        DHDEV_ISCSI_SERVER	stuServer;						// server
        char				szRemotePath[240];				// remote path
        BYTE				reserved[256];
    }DHDEV_ISCSI_CFG;
    
    //-------------------------------Alarm Property ---------------------------------
    
    // PTZ Activation
    typedef struct
    {
        int					iType;
        int					iValue;
    } DH_PTZ_LINK, *LPDH_PTZ_LINK;
    
    //Alarm activation structure
    typedef struct
    {
        /* Message process way. There can be several process ways.
         * 0x00000001 -  Alarm upload
         * 0x00000002 -  Activation alarm
         * 0x00000004 -  PTZ activation
         * 0x00000008 -  Send out mail
         * 0x00000010 -  Local tour
         * 0x00000020 -  Local prompt
         * 0x00000040 -  Alarm output
         * 0x00000080 - Ftp upload
         * 0x00000100 -  Buzzer
         * 0x00000200 -  Video prompt
         * 0x00000400 -  Snapshot
         */
        
        /* The process way current alarm supported. Use bit mask to represent */
        DWORD				dwActionMask;
        
        /* Use bit mask to represent. The parameters of detailed operation are in its correspond configuration */
        DWORD				dwActionFlag;
        
        /* The output channel the alarm activated. The output alarm activated. 1 means activate current output. */
        BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM];
        DWORD				dwDuration;				/*  Alarm duration time*/
        
        /* Activation record */
        BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM]; /*  The record channel alarm activated. 1 means activate current channel. */
        DWORD				dwRecLatch;				/*  Record duration time */
        
        /* Snapshot channel  */
        BYTE				bySnap[DH_MAX_VIDEO_IN_NUM];
        /* Tour channel */
        BYTE				byTour[DH_MAX_VIDEO_IN_NUM];
        
        /* PTZ activation  */
        DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM];
        DWORD				dwEventLatch;			/* The latch time after activation begins. Unit is second. The value ranges from 0 to 15. Default value is 0. */
        /* The wireless output channel alarm activated.The output alarm activated. 1 means activate current output.*/
        BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM];
        BYTE				bMessageToNet;
        BYTE                bMMSEn;					/* SMS Alarm enabled */
        BYTE                bySnapshotTimes;		/* the number of sheets of drawings */
        BYTE				bMatrixEn;				/*enable matrix */
        DWORD				dwMatrix;				/*matrix mask */
        BYTE				bLog;					/*enable log */
        BYTE				bSnapshotPeriod;		/*<Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously.*/
        BYTE                byEmailType;            /*<0,picture,1,record>*/
        BYTE                byEmailMaxLength;       /*<max record length,unit:MB>*/
        BYTE                byEmailMaxTime;         /*<max time length, unit:second>*/
        BYTE				byReserved[99];
    } DH_MSG_HANDLE;
    
    // External alarm
    typedef struct
    {
        BYTE				byAlarmType;			// Annunciator type,0: normal close,1:normal open
        BYTE				byAlarmEn;				// Enable alarm
        BYTE				byReserved[2];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_ALARMIN_CFG, *LPDHDEV_ALARMIN_CFG;
    
    //Motion detection alarm
    typedef struct
    {
        BYTE				byMotionEn;				// Enable motion detection alarm
        BYTE				byReserved;
        WORD				wSenseLevel;			// Sensitivity
        WORD				wMotionRow;				// Row amount in motion detection zones
        WORD				wMotionCol;				// Column amount in motion detection zones
        BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Detection zones .Max 32*32 zones.
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_MOTION_DETECT_CFG;
    
    // Video loss alarm
    typedef struct
    {
        BYTE				byAlarmEn;				// Enable video loss alarm
        BYTE				byReserved[3];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_VIDEO_LOST_CFG;
    
    // Camera masking alarm
    typedef struct
    {
        BYTE				byBlindEnable;						// Enable
        BYTE				byBlindLevel;						// Sensitivity 1-6
        BYTE				byReserved[2];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struHandle;							// Process way
    } DH_BLIND_CFG;
    
    // HDD information(External alarm )
    typedef struct
    {
        BYTE				byNoDiskEn;								// Alarm when there is no HDD
        BYTE				byReserved_1[3];
        DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struNDHandle;							// Process way
        
        BYTE				byLowCapEn;								// Alarm when HDD capacity is low
        BYTE				byLowerLimit;							// Capacity threshold 0-99
        BYTE				byReserved_2[2];
        DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struLCHandle;							// Process way
        
        BYTE				byDiskErrEn;							// HDD malfunction alarm
        BYTE				bDiskNum;
        BYTE				byReserved_3[2];
        DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
        DH_MSG_HANDLE		struEDHandle;							// Process way
    } DH_DISK_ALARM_CFG;
    
    typedef struct
    {
        BYTE				byEnable;
        BYTE				byReserved[3];
        DH_MSG_HANDLE		struHandle;
    } DH_NETBROKEN_ALARM_CFG;
    
    // Alarm deployment
    typedef struct
    {
        DWORD dwSize;
        DH_ALARMIN_CFG 		struLocalAlmIn[DH_MAX_ALARM_IN_NUM];
        DH_ALARMIN_CFG		struNetAlmIn[DH_MAX_ALARM_IN_NUM];
        DH_MOTION_DETECT_CFG struMotion[DH_MAX_VIDEO_IN_NUM];
        DH_VIDEO_LOST_CFG	struVideoLost[DH_MAX_VIDEO_IN_NUM];
        DH_BLIND_CFG		struBlind[DH_MAX_VIDEO_IN_NUM];
        DH_DISK_ALARM_CFG	struDiskAlarm;
        DH_NETBROKEN_ALARM_CFG	struNetBrokenAlarm;
    } DHDEV_ALARM_SCHEDULE;
    
#define DECODER_OUT_SLOTS_MAX_NUM 		16
#define DECODER_IN_SLOTS_MAX_NUM 		16
    
    // Alarm decoder configuration
    typedef struct
    {
        DWORD				dwAddr;									// Alarm decoder address
        BOOL				bEnable;								// Alarm decoder enable
        DWORD				dwOutSlots[DECODER_OUT_SLOTS_MAX_NUM];	// Now only support 8
        int					nOutSlotNum;							// Effective number of array elements.
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        DH_MSG_HANDLE		struHandle[DECODER_IN_SLOTS_MAX_NUM];	// Now only support 8
        int					nMsgHandleNum;							// Effective number of array elements.
        BYTE				bReserved[120];
    } DH_ALARMDEC_CFG;
    
    // The setup of alarm upload
    typedef struct
    {
        BYTE				byEnable;						// Enable upload
        BYTE				bReserverd;						// Reserved
        WORD				wHostPort;						// Alarm center listening port
        char				sHostIPAddr[DH_MAX_IPADDR_LEN];	// Alarm center IP
        int					nByTimeEn;						// Enable scheduled upload.Use it to upload IP or domain name to the centre.
        int					nUploadDay;						/*  Set upload date
                                                             "Never = 0", "Everyday = 1", "Sunday = 2",
                                                             "Monday = 3", Tuesday = 4", "Wednesday = 5",
                                                             "Thursday = 6", "Friday = 7", "Saturday = 8"*/
        int					nUploadHour;					// Set upload time ,[0~23]o'clock
        DWORD				dwReserved[300]; 				// Reserved for future development
    } ALARMCENTER_UP_CFG;
    
    // Panorama switch alarm configuration
    typedef struct __DH_PANORAMA_SWITCH_CFG
    {
        BOOL				bEnable;				// Enabled
        int					nReserved[5];			// Reserved
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_PANORAMA_SWITCH_CFG;
    
    typedef struct __ALARM_PANORAMA_SWITCH_CFG
    {
        int					nAlarmChnNum;			// Number of alarm channels
        DH_PANORAMA_SWITCH_CFG stuPanoramaSwitch[DH_MAX_VIDEO_IN_NUM];
    } ALARM_PANORAMA_SWITCH_CFG;
    
    // Lose focus alarm configuration
    typedef struct __DH_LOST_FOCUS_CFG
    {
        BOOL				bEnable;				// Enabled
        int					nReserved[5];			// Reserved
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_LOST_FOCUS_CFG;
    
    typedef struct __ALARM_LOST_FOCUS_CFG
    {
        int					nAlarmChnNum;			// Number of alarm channels
        DH_LOST_FOCUS_CFG stuLostFocus[DH_MAX_VIDEO_IN_NUM];
    } ALARM_LOST_FOCUS_CFG;
    
    // IP collision detection alarm configuration
    typedef struct __ALARM_IP_COLLISION_CFG
    {
        BOOL				bEnable;				// Enable
        DH_MSG_HANDLE		struHandle;				// Alarm activation
        int                 nReserved[300];			// Reserved
    } ALARM_IP_COLLISION_CFG;
    
    // MACcollision detection configuration
    typedef struct __ALARM_MAC_COLLISION_CFG
    {
        BOOL				bEnable;				// Enable
        DH_MSG_HANDLE		struHandle;				// Alarm activation
        int                 nReserved[300];			// Reserved
    } ALARM_MAC_COLLISION_CFG;
    
    // 232/485 com card signal info configuration
    typedef struct __COM_CARD_SIGNAL_INFO
    {
        WORD                wCardStartPose;          // card number start location
        WORD                wCardLenth;              // card number length
        char                cStartCharacter[32];     // start string
        char                cEndCharacter[32];       // end string
        BYTE                byReserved[28];          // reserved
    }COM_CARD_SIGNAL_INFO;
    
    // 232/485 com card  linked configuration(when the info from the com fit the configuration, it will trigger the device snap picture)
    typedef struct __COM_CARD_SIGNAL_LINK_CFG
    {
        COM_CARD_SIGNAL_INFO  struCardInfo;          // card info
        DH_MSG_HANDLE         struHandle;            // event link
        BYTE                  byReserved[24];        // reserved
        
    }COM_CARD_SIGNAL_LINK_CFG;
    
    //------------------------------Multiple privacy mask zones--------------------------------
    
    // Privacy mask information
    typedef struct __VIDEO_COVER_ATTR
    {
        DH_RECT				rcBlock;				// Privacy mask zone coordinates
        int					nColor;					// Privacy mask color
        BYTE				bBlockType;				// Mask type;0:Black block,1: mosaic
        BYTE				bEncode;				// Encode level cover mask;1:valid,0:invalid
        BYTE				bPriview;				// Preview mask; 1:valid,0:invalid
        char				reserved[29];			// Reserved
    } VIDEO_COVER_ATTR;
    
    // Multiple privacy mask zones
    typedef struct __DHDEV_VIDEOCOVER_CFG
    {
        DWORD				dwSize;
        char				szChannelName[DH_CHAN_NAME_LEN]; // Read-only
        BYTE				bTotalBlocks;			// The mask zones supported
        BYTE				bCoverCount;			// The mask zones have been set
        VIDEO_COVER_ATTR	CoverBlock[DH_MAX_VIDEO_COVER_NUM]; // The mask zones
        char				reserved[30];			// Reserved
    }DHDEV_VIDEOCOVER_CFG;
    
    // decode policy configuration
    typedef struct __DHDEV_DECODEPOLICY_CFG
    {
        int					nMinTime;				// (read only):minimal delay time(ms)
        int					nMaxTime;				// (read only):maximal delay time(ms)
        int					nDeocdeBufTime;			// device decode delay time(ms)
        
        char				reserved[128];			// reserved
    }DHDEV_DECODEPOLICY_CFG;
    
    // Device relative configuration
    typedef struct __DHDEV_MACHINE_CFG
    {
        char				szMachineName[DH_MACHINE_NAME_NUM];		// Device name or SN
        char				szMachineAddress[DH_MACHINE_NAME_NUM];	// Device location
        char				reserved[128];							// reserved
    }DHDEV_MACHINE_CFG;
    
    
    ////////////////////////////////IPC series ////////////////////////////////
    
    // Set wireless network information
    typedef struct
    {
        int					nEnable;				// Enable wireless
        char				szSSID[36];				// SSID
        int					nLinkMode;				// connection mode;0:auto,1:adhoc,2:Infrastructure
        int					nEncryption;			// encrypt;0:off,2:WEP64bit,3:WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP
        int					nKeyType;				// 0:Hex,1:ASCII
        int					nKeyID;					// Serial number
        union
        {
            char			szKeys[4][32];			// Four group passwords
            char			szWPAKeys[128];			// when nEncryption is 4 or 5, use szWPAKeys
        };
        int					nKeyFlag;
        BYTE                byConnectedFlag;        // 0: not connect, 1: connect
        char				reserved[11];
    } DHDEV_WLAN_INFO;
    
    // Select to use one wireless device
    typedef struct
    {
        char				szSSID[36];
        int					nLinkMode;				// Connection mode;0:adhoc,1:Infrastructure
        int 				nEncryption;			// Encrypt;0:off,2:WEP64bit,3:WEP128bit
        char				reserved[48];
    } DHDEV_WLAN_DEVICE;
    
    // The searched wireless device list
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bWlanDevCount;			// The wireless devices searched
        DHDEV_WLAN_DEVICE	lstWlanDev[DH_MAX_WLANDEVICE_NUM];
        char				reserved[255];
    } DHDEV_WLAN_DEVICE_LIST;
    
    // wireless device expended configuration
    typedef struct
    {
        char                szSSID[36];                         // server id
        char                szMacAddr[18];                      // mac address
        BYTE                byApConnected;                      // connect state 0: not connect,1: connected
        BYTE                byLinkMode;                         // connect mod 0:adhoc 1:Infrastructure;
        int                 nRSSIQuality;                       // rssi quality(dbm)
        unsigned int        unApMaxBitRate;                     // max transmit speed
        BYTE                byAuthMode;                         // attestation mod:0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
        // 6:WPA-NONE(only use in Adhoc mode),
        // 7-11 are mix mode,choose one of them can to be connected
        // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
        // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
        BYTE                byEncrAlgr;                         // encrypt mod 0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
        // 7: TKIP+AES( mix Mode) 8: UnKnown
        BYTE                byLinkQuality;                      // link quality 0~100(%)
        BYTE                byReserved[129];                     // Reserved
    }DHDEV_WLAN_DEVICE_EX;
    
    // The searched wireless device expended configuration list
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bWlanDevCount;			// The wireless device number searched
        DHDEV_WLAN_DEVICE_EX  lstWlanDev[DH_MAX_WLANDEVICE_NUM_EX];
        char				reserved[255];
    } DHDEV_WLAN_DEVICE_LIST_EX;
    
    // Function Test
    typedef struct
    {
        int                 nResult;                  // 0:success,1:failure
        BYTE                reserved[32];
    } DHDEV_FUNC_TEST;
    
    // FTP server info
    typedef struct
    {
        char                szServerName[32];          // server name
        char                szIp[16];                  // IP address
        int                 nPort;                     // port number
        char                szUserName[32];            // user name
        char                szPassword[32];	           // pass word
        BOOL                bAnonymity;                // whether anonymity log in
        BYTE                byReserved[256];           // reserved
    }FTP_SERVER_CFG;
    
    // ftp server connect test
    typedef struct
    {
        FTP_SERVER_CFG     stuFtpServerInfo;           // ftp server info(filled by user)
        DHDEV_FUNC_TEST    stuTestResult;              // ftp server connect state
        BYTE               byReserved[64];
    }DHDEV_FTP_SERVER_TEST;
    
    // DDNS domain info
    typedef struct
    {
        
        char				szServerType[DH_MAX_SERVER_TYPE_LEN];	//server type
        char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// server ip or domain
        DWORD				dwServerPort;			// server port
        char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// dvr domain,such as jeckean.3322.org
        char				szUserName[DH_MAX_HOST_NAMELEN];		// username
        char				szUserPsw[DH_MAX_HOST_PSWLEN];			// password
        BYTE                byReserved[256];           // reserved
    }DDNS_DOMAIN_INFO;
    
    
    // DDNS domain test
    typedef struct
    {
        DDNS_DOMAIN_INFO   stuDomainInfo;				// DDNS domain
        DHDEV_FUNC_TEST    stuTestResult;				// test result
        char			   szMemo[128];					// test result memo
        BYTE               byReserved[64];
    }DHDEV_DDNS_DOMAIN_TEST;
    
    
    // hard disk's basic information
    typedef struct
    {
        BYTE                byModle[32];				// model
        BYTE                bySerialNumber[32];			// serial number
        BYTE                byFirmWare[32];				// firmware no
        int                 nAtaVersion;				// ATA protocol version no
        int                 nSmartNum ;					// smart information no
        INT64				Sectors;
        int                 nStatus;					// disk state 0-normal 1-abnormal
        int                 nReserved[33];
    } DHDEV_DEVICE_INFO;
    
    //smart information of harddisk,there may be many items up to more than 30????
    typedef struct
    {
        BYTE				byId;						// ID
        BYTE				byCurrent;					// attribute values
        BYTE				byWorst;					// maximum error value
        BYTE				byThreshold;				// threshold value
        char				szName[64];					// property name
        char				szRaw[8];					// actual value
        int					nPredict;					// state
        char				reserved[128];
    } DHDEV_SMART_VALUE;
    
    //search hard disk smart information
    typedef struct
    {
        BYTE               nDiskNum;       // disk number
        BYTE               byRaidNO;       // Raid sub disk, 0:single disk
        BYTE               byReserved[2];
        DHDEV_DEVICE_INFO  deviceInfo;
        DHDEV_SMART_VALUE  smartValue[MAX_SMART_VALUE_NUM];
    } DHDEV_SMART_HARDDISK;
    
    // submodule information
    typedef struct
    {
        char               szModuleName[64];			//  submodule name
        char               szHardWareVersion[32];		//  submodule HardWareVersion
        char               szSoftwareVersion[32];		//  submodule SoftWareVersion
        BYTE               reserved[128];
    } DHDEV_SUBMODELE_VALUE;
    
    // search submodule information
    typedef struct
    {
        int                    nSubModuleNum;							//  nSubModuleNum
        DHDEV_SUBMODELE_VALUE  stuSubmoduleValue[MAX_SUBMODULE_NUM];	// Submodule information
        BYTE				   bReserved[256];
    } DHDEV_SUBMODULE_INFO;
    
    // Query harddisk damage ability
    typedef struct
    {
        BYTE                bDiskDamageLevel[DH_MAX_DISK_NUM];  // every disk's damage level
        BYTE                bReserved[128];
    } DHDEV_DISKDAMAGE_INFO;
    
    // SYSLOG remote server ability
    typedef struct
    {
        char				szServerIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];	//Server IP address
        int					nServerPort;								//Server port
        BYTE				bEnable;									//Server Enable
        BYTE				bReserved[255];								//Reserved bytes
    }DHDEV_SYSLOG_REMOTE_SERVER;
    
    // Video backup config parameter
    typedef struct
    {
        BYTE				backupVideoFormat;							//file type to backup, 0:dav, 1:asf
        BYTE				password[6];								//password
        BYTE				reversed[505];								//reserved
    }DHDEV_BACKUP_VIDEO_FORMAT;
    
    
    // Auto register config parameter
    typedef struct
    {
        char				szServerIp[32];			// Registration server IP ; no use it,use szServerIpEx
        int					nServerPort;			// Port number
        BYTE                byReserved[3];          //
        BYTE                bServerIpExEn;          // Extend Registration server IP enable, 0-not enable, 1-enable
        char				szServerIpEx[60];       // Extend Registration server IP
    } DHDEV_SERVER_INFO;
    
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bServerNum;				// The max IP amount supported
        DHDEV_SERVER_INFO	lstServer[DH_MAX_REGISTER_SERVER_NUM];
        BYTE				bEnable;				// Enable
        char				szDeviceID[32];			// Device ID
        char				reserved[94];
    } DHDEV_REGISTER_SERVER;
    
    // Camera property
    typedef struct __DHDEV_CAMERA_INFO
    {
        BYTE				bBrightnessEn;			// Brightness adjustable;1:adjustable,0:can not be adjusted
        BYTE				bContrastEn;			// Contrast adjustable
        BYTE				bColorEn;				// Hue adjustable
        BYTE				bGainEn;				// Gain adjustable
        BYTE				bSaturationEn;			// Saturation adjustable
        BYTE				bBacklightEn;			// Backlight compensation adjustable
        BYTE				bExposureEn;			// Exposure option adjustable
        BYTE				bColorConvEn;			// Day/night switch
        BYTE				bAttrEn;				// Property option; 1:Enable, 0:Disable
        BYTE				bMirrorEn;				// Mirror;1:support,0:do not support
        BYTE				bFlipEn;				// Flip;1:support,0:do not support
        BYTE				iWhiteBalance;			// White Balance 1 Support,0 :Do not support
        BYTE				iSignalFormatMask;		// Signal format mask,Bitwise:0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
        BYTE				bRotate90;				// 90-degree rotation 1:support,0:do not support
        BYTE				bLimitedAutoExposure;   // Support the time limit with automatic exposure 1:support,0:do not support
        BYTE				bCustomManualExposure;  // support user-defined manual exposure time 1:support,0:do not support
        BYTE				bFlashAdjustEn;			// Support the flash lamp adjust
        BYTE				bNightOptions;			// Support day and night change
        BYTE                iReferenceLevel;    	// Support electric reference setting
        BYTE                bExternalSyncInput;     // Support external sync Input
        unsigned short      usMaxExposureTime;      // Max exposure time, unit:ms
        unsigned short      usMinExposureTime;      // Min exposure time, unit:ms
        BYTE                bWideDynamicRange;      // Wide dynamic range,0-present not support,2~n max supported range value
        BYTE                bDoubleShutter;         // Double Shutter
        BYTE				byExposureCompensation; // 1 support, 0 not support
        BYTE				bRev[109];				// reserved
    } DHDEV_CAMERA_INFO;
    
    // Special configuration for night,will automatically switch to night configuration when low light
    typedef struct __DHDEV_NIGHTOPTIONS
    {
        BYTE  bEnable;								// 0-Do not switch,1-Switch
        // Roughly sunrise and sunset time, before sunrise or after sunset, will use a special configuration for night.
        // 00:00:00 ~23:59:59
        BYTE  bSunriseHour;
        BYTE  bSunriseMinute;
        BYTE  bSunriseSecond;
        BYTE  bSunsetHour;
        BYTE  bSunsetMinute;
        BYTE  bSunsetSecond;
        BYTE  bWhiteBalance ;						// White balance  0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
        BYTE  bGainRed;								// Red gain adjustment, white balance to "Custom" mode will effect 0~100
        BYTE  bGainBlue;							// Green gain adjustment, white balance to "Custom" mode will effect 0~100
        BYTE  bGainGreen;							// Blue gain adjustment, white balance to "Custom" mode will effect 0~100
        BYTE  bGain;								// 0~100
        BYTE  bGainAuto;							// 0-Without auto gain 1-Auto gain
        BYTE  bBrightnessThreshold ;				// Brightness value 0~100
        BYTE  ReferenceLevel;                       // electric value 0~100
        BYTE  bExposureSpeed;						// Range depends on the device capability: 0-Auto Exposure  1~n-1-manual exposure level;  n-Auto Exposure with time limit;  n+1-manual exposure customized time (n means exposure level)
        float ExposureValue1;						// Lower limit of automatic exposure time or customized manual exposure time, in milliseconds, value 0.1ms ~ 80ms
        float ExposureValue2;						// Automatic exposure time limit, in milliseconds, value 0.1ms ~ 80ms
        BYTE  bAutoApertureEnable;                  // Auto Aperture Enable,1:open,0:close
        BYTE  bWideDynamicRange;                    // wide dynamic value, it depends on max support value
        WORD  wNightSyncValue;						// night sync 0~360
        WORD  wNightSyncValueMillValue;             // night sync mill value 0~999
        BYTE res[10];								// Reserve
    } DHDEV_NIGHTOPTIONS;
    
    // camera attribute configration
    typedef struct __DHDEV_CAMERA_CFG
    {
        DWORD				dwSize;
        BYTE				bExposure;				// Exposure mode;1-9:Manual exposure level  ,0: Auto exposure
        BYTE				bBacklight;				// Backlight compensation:3:High,2:Medium,1:Low,0:close
        BYTE				bAutoColor2BW;			// Day/night mode;2:Open,1:Auto,0:Close
        BYTE				bMirror;				// Mirror;1:Open,0:Close
        BYTE				bFlip;					// Flip;1:Open,0:Close  support;0 :do not support
        BYTE				bLensEn;				// the capacity of Auto Iris function 1:support;0 :do not support
        BYTE				bLensFunction;			// Auto aperture function: 1:Enable aperture  ;0: Disable aperture
        BYTE				bWhiteBalance;			// White Balance 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night
        BYTE				bSignalFormat;			// Signal format 0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
        BYTE				bRotate90;				// 0-Not rotating,1-90 degrees clockwise,2-90 degrees counterclockwise
        BYTE                bReferenceLevel;        // electric value 0~100
        BYTE                byReserve;              // Reserved
        float				ExposureValue1;			// Auto exposure or manual exposure limit custom time,Milliseconds(0.1ms~80ms)
        float				ExposureValue2;			// Auto exposure limit,Milliseconds(0.1ms~80ms)
        DHDEV_NIGHTOPTIONS	stuNightOptions;		// Configuration parameter options for night
        BYTE				bGainRed;				// Red gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
        BYTE				bGainBlue;				// Green gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
        BYTE				bGainGreen;				// Blue gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
        BYTE				bFlashMode;				// Flash mode,0-close,1-always,2-auto
        BYTE				bFlashValue;			// Flash work values,  0-0us, 1-64us, 2-128us,...15-960us
        BYTE				bFlashPole;				// Flash trigger mode 0 - low level 1 - high level
        BYTE                bExternalSyncPhase;     // External single input
        BYTE                bFlashInitValue;        // Flash brightness prevlue, 0~100
        WORD                wExternalSyncValue ;    // External value 0~360
        WORD                wExternalSyncValueMillValue; //  External SyncValue Mill Value0~999
        BYTE                bWideDynamicRange;           // wide dynamic range, it depends on max support value
        BYTE				byExposureCompensation;		// default compensation value,default is 7,range[0~14]
        char				bRev[54];				// Reserved
    } DHDEV_CAMERA_CFG;
    
#define ALARM_MAX_NAME 64
    // (wireless)IR alarm setup
    typedef struct
    {
        BOOL				bEnable;				// Enable alarm input
        char				szAlarmName[DH_MAX_ALARM_NAME];	// Alarm input name
        int					nAlarmInPattern;		// Annunciator input wave
        int					nAlarmOutPattern;		// Annunciator output wave
        char				szAlarmInAddress[DH_MAX_ALARM_NAME];// Alarm input address
        int					nSensorType;			// External device sensor type normal open or normal close
        int					nDefendEfectTime;		// Deploy and cancel latch time. The alarm input becomes activated after the specified time.
        int					nDefendAreaType;		// Defend area
        int					nAlarmSmoothTime;		// Alarm smooth time:system ignores the second alarm if one alarm inputs in two times.
        char				reserved[128];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_INFRARED_INFO;
    
    // Wireless remote control setup
    typedef struct
    {
        BYTE				address[ALARM_MAX_NAME];// Remote control address
        BYTE				name[ALARM_MAX_NAME];	// Remote control name
        BYTE				reserved[32];			// Reserved string
    } DH_WI_CONFIG_ROBOT;
    
    // Wireless alarm output setup
    typedef struct
    {
        BYTE				address[ALARM_MAX_NAME];// Alarm output address
        BYTE				name[ALARM_MAX_NAME];	// Alarm output name
        BYTE				reserved[32];			// Reserved string
    } DH_WI_CONFIG_ALARM_OUT;
    
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bAlarmInNum;			// Wireless alarm input amount
        BYTE				bAlarmOutNum;			// Wireless alarm output amount
        DH_WI_CONFIG_ALARM_OUT AlarmOutAddr[16];	// Alarm output address
        BYTE				bRobotNum;				// Remote control amount
        DH_WI_CONFIG_ROBOT RobotAddr[16];			// Remote control address
        DH_INFRARED_INFO	InfraredAlarm[16];
        char				reserved[256];
    } DH_INFRARED_CFG;
    
    // New audio detection alarm information
    typedef struct
    {
        int					channel;				// Alarm channel number
        int					alarmType;				// Alarm type;0:Volume value is too low ,1:Volume value is too high.
        unsigned int		volume;					// Volume
        BYTE                byState;                // volume alarm state, 0: alarm appear, 1: alarm disappear
        char				reserved[255];
    } NET_NEW_SOUND_ALARM_STATE;
    
    typedef struct
    {
        int					channelcount;			// Alarm channel amount
        NET_NEW_SOUND_ALARM_STATE SoundAlarmInfo[DH_MAX_ALARM_IN_NUM];
    } DH_NEW_SOUND_ALARM_STATE;
    
    // Snapshot function property structure
    typedef struct
    {
        int					nChannelNum;			// Channel amount
        DWORD				dwVideoStandardMask;	// Resolution(Bit). Please refer to enumeration CAPTURE_SIZE
        int					nFramesCount;			// Valid length of Frequency[128] array
        char				Frames[128];			// Frame rate(value)
        // -25:1f/25s;-24:1f/24s;-23:1f/23s;-22:1f/23s
        // ?-?-
        // 0: invalid;1:1f/s;2:2f/s;3:13f/s
        // 4:4f/s;5:5f/s;17:17f/s;18:18f/s
        // 19:19f/s;20:20f/s
        // ?-?-
        // 25: 25f/s
        int					nSnapModeCount;			// valid length of SnapMode[16] array
        char				SnapMode[16];			// (value)0:activate scheduled snapshot,1:Manually activate snapshot
        int					nPicFormatCount;		// Valid length of Format[16] array
        char 				PictureFormat[16];		// (Value)0:BMP format,1:JPG format
        int					nPicQualityCount;		// valid length of Quality[32] array
        char 				PictureQuality[32];		// value
        // 100:Image quality 100%;80:Image quality 80%;60:Image quality60%
        // 50:Image quality50%;30:Image quality30%;10:Image quality10%
        char 				nReserved[128];			// Reserved
    } DH_QUERY_SNAP_INFO;
    
    typedef struct
    {
        int					nChannelCount;			// Channel amount
        DH_QUERY_SNAP_INFO  stuSnap[DH_MAX_CHANNUM];
    } DH_SNAP_ATTR_EN;
    
    
    /* IP Filtering configuration */
#define DH_IPIFILTER_NUM			200			// IP
#define DH_IPIFILTER_NUM_EX			512			// IP
    
    // IP Information
    typedef struct
    {
        DWORD				dwIPNum;				// IP count
        char				SZIP[DH_IPIFILTER_NUM][DH_MAX_IPADDR_LEN]; // IP
        char				byReserve[32];			// Reserved
    } IPIFILTER_INFO;
    
    // IP Filtering configuration
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwEnable;				// Enable
        DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list)
        IPIFILTER_INFO		BannedIP;				// Black list
        IPIFILTER_INFO		TrustIP;				// Trusted sites
        char				byReserve[256];			// Reserved
    } DHDEV_IPIFILTER_CFG;
    
    // IP Information extended
    typedef struct
    {
        DWORD				dwIPNum;				// IP count
        char				SZIP[DH_IPIFILTER_NUM_EX][DH_MAX_IPADDR_LEN]; // IP
        char				byReserve[32];			// Reserved
    } IPIFILTER_INFO_EX;
    
    // IP Filtering extended configuration
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwEnable;				// Enable
        DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
        IPIFILTER_INFO_EX		BannedIP;			// Black list
        IPIFILTER_INFO_EX		TrustIP;			// Trusted sites
        char				byReserve[256];			// Reserved
    } DHDEV_IPIFILTER_CFG_EX;
    
    /* MAC filter configuration */
#define DH_MACFILTER_NUM			512			// MAC
    
    // MAC info
    typedef struct
    {
        DWORD				dwSize;					// struct size
        DWORD				dwMacNum;				// MAC count
        char				szMac[DH_MACFILTER_NUM][DH_MACADDR_LEN]; // MAC
    } MACFILTER_INFO;
    // MAC filter configuration
    typedef struct
    {
        DWORD					dwSize;				// struct size
        DWORD					dwEnable;			// enable
        DWORD					dwType;				// current list type,0:white list, 1:blacklist (The device can enable only one type of list) can only user one kind of device
        MACFILTER_INFO			stuBannedMac;		// black list Mac
        MACFILTER_INFO			stuTrustMac;		// white list Mac
    } DHDEV_MACFILTER_CFG;
    
    /* MAC,IP filter configuration */
#define DH_MACIPFILTER_NUM			512			// MAC,IP
    // MAC, IP filter configuration info
    typedef struct
    {
        DWORD	dwSize;					// struct size
        char	szMac[DH_MACADDR_LEN];	// mac
        char	szIp[DH_MAX_IPADDR_LEN];// ip
    }MACIP_INFO;
    
    // MAC,IP filter configuration
    typedef struct
    {
        DWORD					dwSize;								// struct size
        DWORD					dwEnable;							// enable
        DWORD					dwType;								// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
        DWORD					dwBannedMacIpNum;					// black list MAC,IP count (MAC,IP one to one)
        MACIP_INFO				stuBannedMacIp[DH_MACIPFILTER_NUM];	// black list Mac,IP
        DWORD					dwTrustMacIpNum;			// white list MAC,IP count(MAC,IP one to one)
        MACIP_INFO				stuTrustMacIp[DH_MACIPFILTER_NUM];	// white list Mac,IP
    } DHDEV_MACIPFILTER_CFG;
    typedef struct
    {
        int                nCardNum;                // card number
        char 	           cardInfo [DH_MAX_CARD_NUM][DH_MAX_CARDINFO_LEN]; // card info string
        BYTE               byReserve[32];           // reserved
    }DHDEV_NETCARD_CFG;
    
    // RTSP configuration
    typedef struct
    {
        WORD               wPort;                  // port number(can't be the same as tcp or udp's port number)
        BYTE               byReserved[62];         // reserved
    }DHDEV_RTSP_CFG;
    
    // stream encrypt configuration
    // encrypt key info
    typedef struct _ENCRYPT_KEY_INFO
    {
        BYTE        byEncryptEnable;       //  encrypt enable, 0: not encrypt, 1:encrypt
        BYTE        byReserved[3];
        union
        {
            BYTE    byDesKey[8];           // des key
            BYTE    by3DesKey[3][8];       // 3des key
            BYTE    byAesKey[32];          // aes key
            
        };
    }ENCRYPT_KEY_INFO;
    
    // encrypt algorithm
    typedef struct _ALGO_PARAM_INFO
    {
        WORD       wEncryptLenth;       // encrypt length, for example: wEncryptLenth = 128,the effictive encprypt key value only include byAesKey[0]~[15] in the  ENCRYPT_KEY_INFO struct
        // when the encrypt algorithm is AES,it only support 3 kind length such as 128,192,256
        // when the encrypt algorithm is DES,it has a fixed value 64
        // when the encrypt algorithm is DES,it means the encrypt key's number(2 or 3 encrypt key)
        BYTE       byAlgoWorkMode ;     // work mode, see EM_ENCRYPT_ALOG_WORKMODE
        BYTE       reserved[13];        // reserved
    }ALGO_PARAM_INFO;
    
    // stream encrypt configuration
    typedef struct _DHEDV_STREAM_ENCRYPT
    {
        BYTE                    byEncrptAlgoType;        // encrypt algorithm type:00: AES,01:DES,02: 3DES
        BYTE                    byReserved1[3];
        ALGO_PARAM_INFO         stuEncrptAlgoparam;      // encrypt algorithm param
        ENCRYPT_KEY_INFO        stuEncryptKeys[32];      // each channel's encrypt key's info
        BYTE					byEncrptPlanEnable;		 // encrpt plan enable
        BYTE					byReserved3[3];
        NET_TIME				stuPreTime;				 // encrpt plan beginning time
        BYTE					reserved2[1360];
    }DHEDV_STREAM_ENCRYPT;
    
    // limit stream configuration
    typedef struct _DHDEV_BIT_RATE
    {
        DWORD                   nExpectCodeRate;          // limit stream (kps)
        BYTE                    byReserved[64];           // reserved
    }DHDEV_LIMIT_BIT_RATE;
    // custom configuration
    typedef struct _DHDEV_CUSTOM_CFG
    {
        char                   szData[1024];            // custom configuration information
        char                   reserved[3072];          // reserved
    }DHDEV_CUSTOM_CFG;
    
    /*audio talk configuration*/
    typedef struct
    {
        DWORD				dwSize;
        int					nCompression;			// Compression type,value,refer to DH_TALK_CODING_TYPE,please set the compression type according to the mode the device supports
        int					nMode;					// Encode mode, value, 0 means not support the compression type
        // Set the responding type according to compression type
        // like AMR, please refer to EM_ARM_ENCODE_MODE
        char				byReserve[256];			// Reserved
    } DHDEV_TALK_ENCODE_CFG;
    
    // According to the mobile function
    // (Event triggers message)MMS Configuration Structure
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwEnable;				// Enable
        DWORD				dwReceiverNum;			// Receiver amount
        char				SZReceiver[DH_MMS_RECEIVER_NUM][32];	// Receiver,normally cellphone
        BYTE                byType;					// Message type 0:MMS;1:SMS
        char                SZTitle[32];			// Message title
        char				byReserve[223];			// Reserved
    } DHDEV_MMS_CFG;
    
    // (Message triggers wireless connection configuration)
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwEnable;				// Enable
        DWORD				dwSenderNum;			// Sender amount
        char				SZSender[DH_MMS_SMSACTIVATION_NUM][32];	// Sender, normally the cellphone number
        char				byReserve[256];			// Reserved
    }DHDEV_SMSACTIVATION_CFG;
    
    // (Dailing triggers the wireless connection)
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwEnable;				// Enable
        DWORD				dwCallerNum;			// Sender amount
        char				SZCaller[DH_MMS_DIALINACTIVATION_NUM][32];	// Sender, normally the cellphone
        char				byReserve[256];			// Reserved
    }DHDEV_DIALINACTIVATION_CFG;
    // Above is with the mobile phone functions
    
    
    // Wireless network signal strength structure
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwTDSCDMA;				// TD-SCDMA strength,range:0-100
        DWORD				dwWCDMA;				// WCDMA strength,range:0-100
        DWORD				dwCDMA1x;				// CDMA1x strength,range:0-100
        DWORD				dwEDGE;					// EDGE strength,range:0-100
        DWORD				dwEVDO;					// EVDO strength,range:0-100
        int					nCurrentType;			// Current type
        // 0	The device can't support this
        // 1    TD_SCDMA
        // 2	WCDMA
        // 3	CDMA_1x
        // 4	EDGE
        // 5	EVDO
        // 6 TD-LTE
        DWORD               dwTDLTE;                    // TD-LTE Strength??Range:0:100
        char				byReserve[248];			// Reserved
    } DHDEV_WIRELESS_RSS_INFO;
    
    typedef struct _DHDEV_SIP_CFG
    {
        BOOL				bUnregOnBoot;			//Unregister on Reboot
        char				szAccoutName[64];		//Account Name
        char				szSIPServer[128];		//SIP Server
        char				szOutBoundProxy[128];	//Outbound Proxy
        DWORD				dwSIPUsrID;				//SIP User ID
        DWORD				dwAuthID;				//Authenticate ID
        char				szAuthPsw[64];			//Authenticate Password
        char				szSTUNServer[128];		//STUN Server
        DWORD				dwRegExp;				//Registration Expiration
        DWORD				dwLocalSIPPort;			//Local SIP Port
        DWORD				dwLocalRTPPort;			//Local RTP Port
        BOOL				bEnable;				// Enable
        char				szNotifyID[128];        // Notify ID
        NET_TIME			stuRegTime;             // register time, read only
        BYTE				bReserved[868];		    //reserved
    } DHDEV_SIP_CFG;
    
    typedef struct _DHDEV_SIP_STATE
    {
        int					nStatusNum;				//SIP state number
        BYTE				byStatus[64];           //0:on line,1:off line,2:invalid sip,3:registering,4:talking
        BYTE				bReserved[64];		    //reserved
    }DHDEV_SIP_STATE;
    
    typedef struct _DHDEV_HARDKEY_STATE
    {
        BOOL				bState;                 // 0:Hard Key disconnect, 1:Hard Key connect
        BYTE				bReserved[64];          // reserved
    }DHDEV_HARDKEY_STATE;
    
    typedef struct _DHDEV_ISCSI_PATHLIST
    {
        int					nCount;
        char				szPaths[DH_MAX_ISCSI_PATH_NUM][MAX_PATH_STOR];	// remote path
    } DHDEV_ISCSI_PATHLIST;
    
    // wifi capability country
    typedef struct _DHDEV_WIFI_ROUTE_CAP_COUNTRY
    {
        char				szCountry[32];			// country
        int					nValidChnNum;			// valid channel number
        int					nValideChannels[32];	// valid channel array
        char				reserved[64];			// reserved
    } DHDEV_WIFI_ROUTE_CAP_COUNTRY;
    
    typedef struct _DHDEV_WIFI_ROUTE_CAP
    {
        int					nCountryNum;				// country number
        DHDEV_WIFI_ROUTE_CAP_COUNTRY stuCountry[256];	// country config
        char				reserved[256];				// reserved
    } DHDEV_WIFI_ROUTE_CAP;
    
    //  monitor info
    typedef struct _MONITOR_INFO
    {
        int					nPresetObjectNum;        // preset object number
        int					nActualObjectNum;        // actual object number
        char				reserved[64];
    }MONITOR_INFO;
    
    typedef struct _DHDEV_MONITOR_INFO
    {
        int					nChannelNumber;
        MONITOR_INFO		stMonitorInfo[64];			//  monitor info
        char				reserved[128];
    }DHDEV_MONITOR_INFO;
    
    //Multi Channel Preview Playback Segmentation Ability
    typedef struct tagNET_MULTIPLAYBACK_SPLIT_CAP
    {
        DWORD            dwSize;
        int              nSliptMode[DH_MAX_MULTIPLAYBACK_SPLIT_NUM]; // Support segmentation Mode
        int              nModeNumber;
    }NET_MULTIPLAYBACK_SPLIT_CAP;
    
    /***************************** PTZ preset configuration ***********************************/
    typedef struct _POINTEANBLE
    {
        BYTE				bPoint;					// Preset range[1,80], invalid setting is 0.
        BYTE				bEnable;				// Valid or not,0 invalid,1 valid
        BYTE				bReserved[2];
    } POINTEANBLE;
    
    typedef struct _POINTCFG
    {
        char				szIP[DH_MAX_IPADDR_LEN];// ip
        int					nPort;					// Port
        POINTEANBLE			stuPointEnable[80];		// Preset enable
        BYTE				bReserved[256];
    }POINTCFG;
    
    typedef struct _DHDEV_POINT_CFG
    {
        int					nSupportNum;			//Read-only parameter, shall return to sdk when set, it means supported pre-set number
        POINTCFG			stuPointCfg[16];		// 2D config means point info.
        BYTE				bReserved[256];			// Reserved
    }DHDEV_POINT_CFG;
    ////////////////////////////////Mobile DVR supported////////////////////////////////
    
    // GPS information(Mobile device)
    typedef struct _GPS_Info
    {
        NET_TIME			revTime;				// position time
        char				DvrSerial[50];			// Device serial number
        double				longitude;				// Longitude
        double				latidude;				// Latitude
        double				height;					// Height(meter)
        double				angle;					// Angle(The north pole is the original point and clockwise is +)
        double				speed;					// Speed(Kilometer/hour)
        WORD				starCount;				// Starcount
        BOOL				antennaState;			// Antenna status(true=good,false =bad)
        BOOL				orientationState;		// Orientation status (true=position,false = no position )
    } GPS_Info,*LPGPS_Info;
    
    // alarm state info
    typedef struct
    {
        int                nAlarmCount;             // alarm count
        int                nAlarmState[128];        // alarm state
        BYTE               byRserved[128];          // reserved
    }ALARM_STATE_INFO;
    
    // Snapshot parameter structure
    typedef struct _snap_param
    {
        unsigned int		Channel;				// Snapshot channel
        unsigned int		Quality;				// Image quality:level 1 to level 6
        unsigned int		ImageSize;				// Video size;0:QCIF,1:CIF,2:D1
        unsigned int		mode;					// Snapshot mode;0:request one frame,1:send out requestion regularly,2: Request consecutively
        unsigned int		InterSnap;				// Time unit is second.If mode=1, it means send out requestion regularly. The time is valid.
        unsigned int		CmdSerial;				// Request serial number
        unsigned int		Reserved[4];
    } SNAP_PARAMS, *LPSNAP_PARAMS;
    
    // Snapshot function setup
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bTimingEnable;				// Schedule snapshot button(The alarm snapshot button is in alarm activation configuration)
        BYTE                bPicIntervalHour;           // timing snapshot interval hour
        short	            PicTimeInterval;			// The time intervals of timing capture (s). At present, the capture device supports the largest time interval is 30 minutes
        DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM]; // Snapshot encode setup. The resolution, video quality, frame rate setup and fram rate are all negative. It means the snapshot times in each second.
    } DHDEV_SNAP_CFG;
    
    // snap function extern configuration
    typedef struct
    {
        DWORD				dwSize;
        BYTE				bTimingEnable;				// timing diagram switch(in tach of the alarm configuration)
        BYTE                bPicIntervalHour;           // the number of hours interval
        short	            PicTimeInterval;			// time interval(s),the biggest capture device support interval 30min now
        DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM];  // snap encode configuration,support resolution ,image quality and frame rate setting,frame rate is negative,say for a second to grasp figure number
        DWORD               dwTrigPicIntervalSecond;    //
        BYTE                byRserved[256];             // reserved
    } DHDEV_SNAP_CFG_EX;
    //wifi state of car device
    typedef struct
    {
        char	szSSID[128];							//SSID
        BOOL	bEnable;								//If enable wifi function, 0:Disable 1:Enable
        int		nSafeType;								//Verify type
        //0:OPEN
        //1:RESTRICTE
        //2:WEP
        //3:WPA
        //4:WPA2
        //5:WPA-PSK
        //6:WPA2-PSK
        int		nEncryprion;							//Encryption method
        //0:OPEN
        //1:TKIP
        //2:WEP
        //3:AES
        //4:NONE(without verify)
        //5:AUTO
        //6:SHARED
        int		nStrength;								//AP site signal
        char	szHostIP[128];							//host address
        char	szHostNetmask[128];						//host mask
        char	szHostGateway[128];						//host gate  way
        int		nPriority;								//Priority,(1-32)
        int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
        BYTE	bReserved[1016];
    } DHDEV_VEHICLE_WIFI_STATE;
    
    typedef struct
    {
        char	szSSID[128];							//SSID
        int		nPriority;								//Priority,(1-32)
        int		nSafeType;								//Verify type
        //0:OPEN
        //1:RESTRICTE
        //2:WEP
        //3:WPA
        //4:WPA2
        //5:WPA-PSK
        //6:WPA2-PSK
        int		nEncryprion;							//Encryption method
        //0:OPEN
        //1:TKIP
        //2:WEP
        //3:AES
        //4:NONE(No verify)
        //5:AUTO
        //6:SHARED
        char	szKey[128];								//Connection key
        char	szHostIP[128];							//Host address
        char	szHostNetmask[128];						//Host mask
        char	szHostGateway[128];						//Host gateway
        int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
        BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
        BYTE	bReserved[1019];
    } DHDEV_VEHICLE_WIFI_CONFIG;
    typedef struct
    {
        char    szSSID[128];                            // SSID
        BYTE    bReserved[256];                         // reserved
    }WIFI_CONNECT;
    // IP modify configuration
    typedef struct __DHCTRL_IPMODIFY_PARAM
    {
        int                 nStructSize;
        char				szRemoteIP[DH_MAX_IPADDR_OR_DOMAIN_LEN];		// device IP
        char				szSubmask[DH_MAX_IPADDR_LEN];	                // submask
        char				szGateway[DH_MAX_IPADDR_OR_DOMAIN_LEN];	        // gatway
        char				szMac[DH_MACADDR_LEN];			                // MAC addr
        char				szDeviceType[DH_DEV_TYPE_LEN];	                // device type
    }DHCTRL_IPMODIFY_PARAM;
    
    typedef struct
    {
        BOOL	bIsScan;								//0:Not scan wifi (Manually added), 1: scanned wifi
        char	szSSID[128];							//SSID
        int		nSafeType;								//Verify type
        //0:OPEN
        //1:RESTRICTE
        //2:WEP
        //3:WPA
        //4:WPA2
        //5:WPA-PSK
        //6:WPA2-PSK
        int		nEncryprion;							//Encryption method
        //0:OPEN
        //1:TKIP
        //2:WEP
        //3:AES
        //4:NONE(No verify)
        //5:AUTO
        //6:SHARED
        char	szKey[128];								//Connection key
        int		nStrength;								//AP site signal
        int		nMaxBitRate;							//AP site maximum transmission rate, with units, read-only
        int		nIsCnnted;								//If success connect read-only
        int		nIsSaved;								//If save read-only
        int		nPriority;								//Priority,(1-32)
        char	szHostIP[128];							//Host address
        char	szHostNetmask[128];						//Host network mask
        char	szHostGateway[128];						//Host gateway
        int		nWifiFreq;								//Radio frequency, using channel logo
        int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
        BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
        BYTE	bReserved[1019];
    }DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG;
    
    typedef struct
    {
        BOOL	bEnable;								//if enable wifi, 0:disable, 1:enable
        int		nWifiApNum;								// Effective number of structure:DHDEV_VEHICLE_WIFI_AP_CFG
        DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG struWifiAp[64];//Single WIFI AP configration
        int	nReserved[512];								//reserved
    }DHDEV_VEHICLE_WIFI_AP_CFG;
    
    typedef struct
    {
        BOOL   bEnable;									//to enable wift, 0:disable 1:enable
        int    nRetWifiApNum;							//get number of DHDEV_VEHICLE_WIFI_AP_CFG
        int    nMaxWifiApNum;							//apply number of DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG
        DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG* pWifiAp;		//a WIFI AP configuration
        int nReserved[512];								//reserved
    }DHDEV_VEHICLE_WIFI_AP_CFG_EX;
    // GPS log structure
    typedef struct _DH_DEVICE_GPS_LOG_ITEM
    {
        DHDEVTIME       stuDevTime;             // device time
        DWORD		    dwLatidude;				// Longitude(0-180 degree)north Longitude 30.183382 = (30.183382 + 90) * 100000 = 120183382
        DWORD		    dwLongitude;			// Latitude(0-360 degree)east Latitude 120.178274 =(120.178274 + 180) * 100000 = 300178274
        DWORD           dwSpeed;                // speed,dwSpeed/1000*1.852km/h
        DWORD           dwHight;                // hight,m
        DWORD           dwAngle;                // direction,0~360,the north is it's origin, clockwise
        DHDEVTIME       stuGpsTime;             // GPS time
        BYTE            bAntStatus; 		    // GPS antenna state,0 means good;!=0 meams there has some exception
        BYTE            bOriStatus; 			// orientation state, != 0 means orientation sucess;
        BYTE            bSatCount; 				// satellite count
        BYTE            bGPSStatus; 			// GPS state,0:not orientation, 1:non differential position information 2:differential position information
        DWORD           dwTemp;                 // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
        DWORD           dwHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
        BYTE            bReserved[24];          // reserved
        
    }DH_DEVICE_GPS_LOG_ITEM;
    
    // query GPS param
    typedef struct _QUERY_GPS_LOG_PARAM
    {
        NET_TIME			stuStartTime;			// start time
        NET_TIME			stuEndTime;				// end time
        int					nStartNum;				// start index,the first time to query an be valued with 0
        BYTE				bReserved[20];
    } QUERY_GPS_LOG_PARAM;
    
    typedef struct _GPS_TEMP_HUMIDITY_INFO
    {
        double              dTemperature;          // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
        double              dHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
        BYTE                bReserved[128];        // reserved
    }GPS_TEMP_HUMIDITY_INFO;
    
    // enclosure type
    typedef enum
    {
        ENCLOSURE_LIMITSPEED = 0x01,				// speed limit
        ENCLOSURE_DRIVEALLOW = 0x02,				// drive allow
        ENCLOSURE_FORBIDDRIVE = 0x04,				// forbind drive
        ENCLOSURE_LOADGOODS = 0x08,					// load goods
        ENCLOSURE_UPLOADGOODS = 0x10,				// upload goods
    }ENCLOSURE_TYPE;
    
    typedef enum
    {
        ENCLOSURE_ALARM_DRIVEIN ,	                 // drive in
        ENCLOSURE_ALARM_DRIVEOUT,	                 // drive out
        ENCLOSURE_ALARM_OVERSPEED,				     // over speed
        ENCLOSURE_ALARM_SPEEDCLEAR,				 // speed clear
    }ENCLOSURE_ALARM_TYPE;
    
    typedef struct
    {
        DWORD				dwLongitude;			// longitude
        DWORD				dwLatidude;				// latidude
    }GPS_POINT;
    
    // enclosure config
    typedef struct _DHDEV_ENCLOSURE_CFG
    {
        UINT				unType;                 // mask
        BYTE				bRegion[8];             // front 4 bit means country, province, city, town
        UINT				unId;                   // rect id
        UINT				unSpeedLimit;           // speed limit(km/h)
        UINT				unPointNum;             // rect point number
        GPS_POINT			stPoints[128];			// rect point info
        char          		szStationName[DH_STATION_NAME_LEN];  //station name
        BYTE				reserved[32];           // reserved
    }DHDEV_ENCLOSURE_CFG;
    
    // enclosure version config
    typedef struct _DHDEV_ENCLOSURE_VERSION_CFG
    {
        UINT				unType;                 // type mask,such as LIMITSPEED | DRIVEALLOW
        UINT				unVersion[32];          // version
        int					nReserved;              // reserved
    }DHDEV_ENCLOSURE_VERSION_CFG;
    
    // enclosure alarm info
    typedef struct __ALARM_ENCLOSURE_INFO
    {
        int					nTypeNumber;                    // type number
        BYTE				bType[16];						// type
        int					nAlarmTypeNumber;               // alarm type number
        BYTE				bAlarmType[16];                 // alarm type
        char				szDriverId[DH_VEHICLE_DRIVERNO_LEN];  // drive id
        UINT				unEnclosureId;      	        // enclosure id
        UINT				unLimitSpeed;	                // speed limit(km/h)
        UINT				unCurrentSpeed;                 // current speed
        NET_TIME			stAlarmTime;                    // alarm time
        DWORD				dwLongitude;					// longitude
        DWORD				dwLatidude;						// latidude
        BYTE          		bOffline;                       // 0-real time 1-tofill
        BYTE				byReserved[119];                // reserved
    }ALARM_ENCLOSURE_INFO;
    
    // RAID state
#define DH_MAX_RAID_NUM  16
    typedef struct __RAID_STATE_INFO
    {
        char				szName[16];					// Raid name
        BYTE				byType;						// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
        BYTE				byStatus;					// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
        BYTE                byReserved[2];
        int					nCntMem;					// nMember number
        int					nMember[32];				// 1,2,3,.
        int					nCapacity;					// capacity(G)
        int					nRemainSpace;				// remain space(M)
        int					nTank;						// Tank 0:main,1:tank1,2:tank2 ...
        char				reserved[32];
    }RAID_STATE_INFO;
    
    typedef struct __ALARM_RAID_INFO
    {
        int              nRaidNumber;                   // RAID number
        RAID_STATE_INFO  stuRaidInfo[DH_MAX_RAID_NUM];  // RAID info
        char             reserved[128];
    }ALARM_RAID_INFO;
    //////////////////////////////////ATM support//////////////////////////////////
    
    typedef struct
    {
        int					Offset;					// Symbol position bit Offset
        int					Length;					// Symbol position length
        char				Key[16];				// Symbol position value
    } DH_SNIFFER_FRAMEID;
    
    typedef struct
    {
        int					Offset;					// Symbol position bit offset
        int					Offset2;				// It is invalid now
        int					Length;					// The symbol position length
        int					Length2;				// It is invalid now
        char				Title[12];  			// Title value
        char                Key[12];                // Key value
    } DH_SNIFFER_CONTENT;
    
    // Network sniffer setup
    typedef struct
    {
        DH_SNIFFER_FRAMEID	snifferFrameId;			// Each FRAME ID option
        DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM];	// The corresponding four sniffers in each FRAME
    } DH_SNIFFER_FRAME;
    
    // Configuration structure of each sniffer
    typedef struct
    {
        char				SnifferSrcIP[DH_MAX_IPADDR_LEN];	// Sniffer source address
        int					SnifferSrcPort;						// Sniffer source port
        char				SnifferDestIP[DH_MAX_IPADDR_LEN];	// Sniffer destination address
        int					SnifferDestPort;					// Sniffer destination port
        char				reserved[28];						// Reserved string
        DH_SNIFFER_FRAME	snifferFrame[DH_SNIFFER_FRAMEID_NUM];// 6 FRAME options
        int					displayPosition;					// Display position
        int					recdChannelMask;					// Channel mask
    } DH_ATM_SNIFFER_CFG;
    
    typedef struct
    {
        DWORD				dwSize;
        DH_ATM_SNIFFER_CFG	SnifferConfig[4];
        char				reserved[256];						// Reserved string
    } DHDEV_SNIFFER_CFG;
    
    typedef DH_SNIFFER_FRAMEID DH_SNIFFER_FRAMEID_EX;
    typedef DH_SNIFFER_CONTENT DH_SNIFFER_CONTENT_EX;
    
    // Capture network configuration
    typedef struct
    {
        DH_SNIFFER_FRAMEID	snifferFrameId;								// Each FRAME ID Options
        DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM_EX];	// Each FRAME Corresponding to the contents of capture
    } DH_SNIFFER_FRAME_EX;
    
    // Capture each of the corresponding structure
    typedef struct
    {
        char				SnifferSrcIP[DH_MAX_IPADDR_LEN];					// Source address capture
        int					SnifferSrcPort;										// Capture source port
        char				SnifferDestIP[DH_MAX_IPADDR_LEN];					// Destination address capture
        int					SnifferDestPort;									// Capture the target port
        DH_SNIFFER_FRAME_EX	snifferFrame[DH_SNIFFER_FRAMEID_NUM];				// 6 FRAME Options
        int					displayPosition;									// Display Position
        int					recdChannelMask;									// Channel mask
        BOOL				bDateScopeEnable;									// Data sources enable
        BOOL				bProtocolEnable;									// Protocol enable
        char				szProtocolName[DH_SNIFFER_PROTOCOL_SIZE];			// Protocol name
        int					nSnifferMode;										// Capture mode; 0:net,1:232.
        int					recdChannelMask1;									// Channel submask  32 ~ 63 channel
        char				reserved[252];
    } DH_ATM_SNIFFER_CFG_EX;
    
    // Atm trade type
#define ATM_MAX_TRADE_TYPE_NAME	64
#define ATM_MAX_TRADE_NUM		1024
    
    typedef struct __DH_ATM_QUERY_TRADE
    {
        int					nTradeTypeNum;										// number of trade types
        int					nExceptionTypeNum;									// number of exception events
        char				szSupportTradeType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];    // trade events
        char				szSupportExceptionType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];// exception events
    } DH_ATM_QUERY_TRADE, *LPDH_ATM_QUERY_TRADE;
    
    /////////////////////////////////NVD support/////////////////////////////////
#define nEncoderID nDecoderID
#define byEncoderID byDecoderID
    
    // Decoder information
    typedef struct __DEV_DECODER_INFO
    {
        char			szDecType[64];			// type
        int				nMonitorNum;			// TV number
        int				nEncoderNum;			// Decoder channel number
        BYTE			szSplitMode[16];		// Supported by a number of TV screen partition
        BYTE            bMonitorEnable[16];		// TV enable
        BYTE            bTVTipDisplay;          // TV tip display enable 0:not support 1:support.
        BYTE            reserved1[3];
        BYTE            byLayoutEnable[48];     // every channel's tip display enable
        DWORD           dwLayoutEnMask[2];      // Each decoding channel displays overlay info enable mask, from low to high support 64 channels, while dwLayoutEnMask[0] is low 32 bit
        char			reserved[4];
    } DEV_DECODER_INFO, *LPDEV_DECODER_INFO;
    
    // Encoder information
#ifndef NANJINGDITIE_NVD
    typedef struct __DEV_ENCODER_INFO
    {
        char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
        WORD			wDevPort;							// Port of Front-end DVR
        BYTE			bDevChnEnable;                      // Decoder channel enable
        BYTE			byDecoderID;						// The corresponding channel number decoder
        char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
        char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
        int				nDevChannel;						// Channel Number
        int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
        BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
        BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
        WORD			wListenPort;						// Listening port services, for transmit
        DWORD			dwProtoType;						// Protocol type
        // 0:compatible with each other.
        // 1:private 2nd protocol
        // 2:private system integration protocol
        // 3:private DSS protocol
        // 4:private rtsp protocol
        char			szDevName[64];						// Front device name
        BYTE            byVideoInType;                      // video source type:0-SD,1-HD
        char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
        BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
        BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
        BYTE            byDeviceType;                       // The target device's device type,0:IPC
        BYTE            byDecodePolicy;                     // The target device's decode policy
        // 0:LatencyLevel3 1:LatencyLevel2
        // 2:LatencyLevel1 3:MiddleLevel
        // 4:FluencyLevel3 5:FluencyLevel2
        // 6:FluencyLevel1
        BYTE            bReserved[3];                          // reserved
        DWORD           dwHttpPort;                         // http port 0-65535
        DWORD           dwRtspPort;                         // RTSP port 0-65535
        char			szChnName[32];						// remote channel name
        char			reserved[4];
    } DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;
    
#else
    
    // encoder info
    typedef struct __DEV_ENCODER_INFO
    {
        char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
        WORD			wDevPort;							// Port of Front-end DVR
        BYTE			bDevChnEnable;                      // Decoder channel enable
        BYTE			byDecoderID;						// The corresponding channel number decoder
        char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
        char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
        int				nDevChannel;						// Channel Number
        int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
        BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
        BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
        WORD			wListenPort;						// Listening port services, for transmit
        DWORD			dwProtoType;						// Protocol type
        // 0:compatible with each other.
        // 1:private 2nd protocol
        // 2:private system integration protocol
        // 3:private DSS protocol
        // 4:private rtsp protocol
        char			szDevName[32];						// Front device name
        BYTE            byVideoInType;                      // video source type:0-SD,1-HD
        char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
        BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
        BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
        BYTE            byDeviceType;                       // The target device's device type,0:IPC
        BYTE            byDecodePolicy;                     // The target device's decode policy
        // 0:LatencyLevel3 1:LatencyLevel2
        // 2:LatencyLevel1 3:MiddleLevel
        // 4:FluencyLevel3 5:FluencyLevel2
        // 6:FluencyLevel1
        BYTE            bReserved[3];                          // reserved
        DWORD           dwHttpPort;                         // http port 0-65535
        DWORD           dwRtspPort;                         // RTSP port 0-65535
        char			szChnName[32];						// remote channel name
        char			szMcastIP[DH_MAX_IPADDR_LEN];       // multicast address
        char            reserved[128];
    } DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;
    
#endif
    
    // decoder protocol rtsp url configuration
    typedef struct __DHDEV_DECODER_URL_CFG
    {
        DWORD			dwSize;
        char			szMainStreamUrl[MAX_PATH];			// main stream url
        char			szExtraStreamUrl[MAX_PATH];			// extra stream url
    } DHDEV_DECODER_URL_CFG;
    
    typedef enum tagDH_SPLIT_DISPLAY_TYPE
    {
        DH_SPLIT_DISPLAY_TYPE_GENERAL=1,          // Common display types
        DH_SPLIT_DISPLAY_TYPE_PIP=2,              // PIP Display Type
    } DH_SPLIT_DISPLAY_TYPE;
    
    // CLIENT_CtrlDecTVScreen Interface parameters
    typedef struct tagDH_CTRL_DECTV_SCREEN
    {
        DWORD           dwSize;                             // The size of the structure
        int             nSplitType;                         // Split mode
        BYTE *          pEncoderChannel;                    // Display Channel, dwDisplayType = DH_SPLIT_DISPLAY_TYPE_GENERAL when Effect, the caller can not be less than the length of the allocated memory size nSplitType
        BYTE            byGroupNo;                          // Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
        char            reserved[3];                        // Reserved
        DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category Type, i.e., "General"
    }DH_CTRL_DECTV_SCREEN;
    
    // TV parameters
    typedef struct __DEV_DECODER_TV
    {
        int				nID;								// TV ID
        BOOL			bEnable;							// Enable, open or close
        int				nSplitType;							// Partition number
        DEV_ENCODER_INFO stuDevInfo[16];					// All encoder information
        BYTE			bySupportSplit[10];					// Split mode supported
        BYTE            byGroupNo;     						// Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
        char			reserved[1];                        // Reserved bytes
        DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode
        // Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category
        // Type, i.e., "General")
        
    } DEV_DECODER_TV, *LPDEV_DECODER_TV;
    
    // Screen combination of information
    typedef struct __DEC_COMBIN_INFO
    {
        int				nCombinID;							// Combin ID
        int             nSplitType;							// Partition number
        BYTE            bDisChn[16];						// Display channel
        char			reserved[16];
    } DEC_COMBIN_INFO, *LPDEC_COMBIN_INFO;
    
    // Tour Information
#define DEC_COMBIN_NUM 			32						// the number of tour combination
    typedef struct __DEC_TOUR_COMBIN
    {
        int				nTourTime;							// Tour Interval(s)
        int				nCombinNum;							// the number of combination
        BYTE			bCombinID[DEC_COMBIN_NUM];			// Combination Table
        char			reserved1[32];
        BYTE			bCombinState[DEC_COMBIN_NUM];		// Combination option state,0:close;1:open
        char			reserved2[32];
    } DEC_TOUR_COMBIN, *LPDEC_TOUR_COMBIN;
    
    // Decoder Playback type
    typedef enum __DEC_PLAYBACK_MODE
    {
        Dec_By_Device_File = 0,								// Front-end DVR--By File
        Dec_By_Device_Time,									// Front-end DVR--By Time
    } DEC_PLAYBACK_MODE;
    
    // Decoder Playback control type
    typedef enum __DEC_CTRL_PLAYBACK_TYPE
    {
        Dec_Playback_Seek = 0,								// Drag
        Dec_Playback_Play,									// Play
        Dec_Playback_Pause,									// Pause
        Dec_Playback_Stop,									// Stop
    } DEC_CTRL_PLAYBACK_TYPE;
    
    // tour ctrol type
    typedef enum __DEC_CTRL_TOUR_TYPE
    {
        Dec_Tour_Stop = 0,									// stop
        Dec_Tour_Start,										// start
        Dec_Tour_Pause,										// pause
        Dec_Tour_Resume,									// resume
    } DEC_CTRL_TOUR_TYPE;
    
    // Playback by file Conditions
    typedef struct __DEC_PLAYBACK_FILE_PARAM
    {
        char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
        WORD			wDevPort;							// Port of Front-end DVR
        BYTE			bDevChnEnable;                      // Decoder channel enable
        BYTE			byDecoderID;						// The corresponding channel number
        char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
        char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
        NET_RECORDFILE_INFO stuRecordInfo;					// Record file information
        char			reserved[12];
    } DEC_PLAYBACK_FILE_PARAM, *LPDEC_PLAYBACK_FILE_PARAM;
    
    // Playback by time Conditions
    typedef struct __DEC_PLAYBACK_TIME_PARAM
    {
        char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
        WORD			wDevPort;							// Port of Front-end DVR
        BYTE			bDevChnEnable;                      // Decoder channel enable
        BYTE			byDecoderID;						// The corresponding channel number
        char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
        char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
        int				nChannelID;
        NET_TIME		startTime;
        NET_TIME		endTime;
        char			reserved[12];
    } DEC_PLAYBACK_TIME_PARAM, *LPDEC_PLAYBACK_TIME_PARAM;
    
    // Current decoding channel status(including channel status, decoding stream info and etc.)
    typedef struct __DEV_DECCHANNEL_STATE
    {
        BYTE			byDecoderID;						// Responding decoding channel number
        BYTE            byChnState;                         // Current decoding channel in opertion status:0 -free,1 -realtime monitoring,2 - playback 3 - Decode Tour
        BYTE			byFrame;                            // Current data frame rate
        BYTE            byReserved;                         // Reserved
        int				nChannelFLux;						// Decoding channel data amount
        int             nDecodeFlux;						// Decoding data amount
        char            szResolution[16];                   // Current data resolution
        char			reserved[256];
    } DEV_DECCHANNEL_STATE, *LPDEV_DECCHANNEL_STATE;
    
    // Device TV display info
    typedef struct __DEV_VIDEOOUT_INFO
    {
        DWORD				dwVideoStandardMask;			// NSP,video standard mask,according to the bit which shows video format(not support now)
        int					nVideoStandard;                 // NSP,current format(not support now,please use DHDEV_SYSTEM_ATTR_CFG by VideoStandard to read and config the video format)
        DWORD				dwImageSizeMask;				// Resolution mask,according the bit which shows video resolution
        int                 nImageSize;                     // Current resolution
        char				reserved[256];
    }DEV_VIDEOOUT_INFO, *LPDEV_VIDEOOUT_INFO;
    
    // TV adjust
    typedef struct __DEV_TVADJUST_CFG
    {
        int					nTop;							// top(0 - 100)
        int					nBotton;						// botton(0 - 100)
        int					nLeft;							// left(0 - 100)
        int                 nRight;							// right(0 - 100)
        int					reserved[32];
    }DHDEV_TVADJUST_CFG, *LPDHDEV_TVADJUST_CFG;
    
    // decoder tour configuration
    typedef struct __DEV_DECODER_TOUR_SINGLE_CFG
    {
        char		szIP[128];								// Front-end device's ip.Such as"10.7.5.21". Support retention of the domain name, end by '\0'.
        int			nPort;									// Front-end device's port.(0, 65535).
        int			nPlayChn;								// front-end device's Request channel [1, 16].
        int			nPlayType;								// front-end device's Stream type, 0:main; 1:sub.
        char		szUserName[32];							// front-end device's user name,end by '\0'.
        char		szPassword[32];							// front-end device's Password,end by '\0'.
        int			nInterval;								// Round tour interval [10, 120],s.
        DWORD		nManuFactory;							// device's factory(enum see IPC_TYPE)
        UINT		nHttpPport;								// device's http port
        UINT		nRtspPort;								// device's rtsp port
        BYTE		byServiceType;							// service type -1:auto,0:TCP;1:UDP;2:Multicast
        BYTE		bReserved[51];							// reserved.
    }DHDEV_DECODER_TOUR_SINGLE_CFG;
    
    typedef struct __DEV_DECODER_TOUR_CFG
    {
        int								nCfgNum;			// the number of Configure structures. The biggest support 32. Specific number of support inquiries through capacity.
        DHDEV_DECODER_TOUR_SINGLE_CFG	tourCfg[64];		// Polling configuration array, the effective number of structures by the members of the "nCfgNum" designation. Keep left to expand 32.
        BYTE							bReserved[256];		// reserved.
    }DHDEV_DECODER_TOUR_CFG;
    
    /////////////////////////////////intelligent support/////////////////////////////////
    // picture info
    typedef struct
    {
        DWORD                dwOffSet;                       // current picture file's offset in the binary file, byte
        DWORD                dwFileLenth;                    // current picture file's size, byte
        WORD                 wWidth;                         // picture width, pixel
        WORD                 wHeight;                        // picture high, pixel
        char*                pszFilePath;                    // File path
        // User use this field need to apply for space for copy and storage
        BYTE                 bReserved[12];
    }DH_PIC_INFO;
    
    // Object corresponding to picture file information (including images path)
    typedef struct tagDH_PIC_INFO_EXX
    {
        DWORD           dwSize;
        char            szFilePath[DH_COMMON_STRING_256];   //In view of historical reasons, the member is valid when be set or to get
        // File path
        DH_PIC_INFO     stuPicInfo;                         // picture information
    }DH_PIC_INFO_EX2;
    
    
    // Extension fields added int64, forced 4 byte alignment
#pragma pack(push)
#pragma pack(4)
    
    // Struct of object info for video analysis
    typedef struct
    {
        int					nObjectID;						// Object ID,each ID represent a unique object
        char				szObjectType[128];				// Object type
        int					nConfidence;					// Confidence(0~255),a high value indicate a high confidence
        int					nAction;						// Object action:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
        DH_RECT				BoundingBox;					// BoundingBox
        DH_POINT			Center;							// The shape center of the object
        int					nPolygonNum;					// the number of culminations for the polygon
        DH_POINT			Contour[DH_MAX_POLYGON_NUM];	// a polygon that have a exactitude figure
        DWORD				rgbaMainColor;					// The main color of the object;the first byte indicate red value, as byte order as green, blue, transparence, for example:RGB(0,255,0),transparence = 0, rgbaMainColor = 0x00ff0000.
        char				szText[128];					// the interrelated text of object,such as number plate,container number
        // "ObjectType"??"Vehicle" or "Logo"?¡§try to use Logo.Vehicle is used to be compatible with old product??means logo??support??
        // "Unknown" Unknown
        // "Audi" Audi
        // "Honda" Honda
        // "Buick" Buick
        // "Volkswagen" Volkswagen
        // "Toyota" Toyota
        // "BMW" BMW
        // "Peugeot" Peugeot
        // "Ford" Ford
        // "Mazda" Mazda
        // "Nissan" Nissan
        // "Hyundai" Hyundai
        // "Suzuki" Suzuki
        // "Citroen" Citroen
        // "Benz" Benz
        // "BYD" BYD
        // "Geely" Geely
        // "Lexus" Lexus
        // "Chevrolet" Chevrolet
        // "Chery" Chery
        // "Kia" Kia
        // "Charade" Charade
        // "DF" DF
        // "Naveco" Naveco
        // "SGMW" SGMW
        // "Jinbei" Jinbei
        
        // "JAC" JAC
        // "Emgrand" Emgrand
        // "ChangAn" ChangAn
        // "Great Wall" Great Wall
        // "Skoda" Skoda
        // "BaoJun" BaoJun
        // "Subaru" Subaru
        // "LandWind" LandWind
        // "Luxgen" Luxgen
        // "Renault" Renault
        // "Mitsubishi" Mitsubishi
        // "Roewe" Roewe
        // "Cadillac" Cadillac
        // "MG" MG
        // "Zotye" Zotye
        // "ZhongHua" ZhongHua
        // "Foton" Foton
        // "SongHuaJiang" SongHuaJiang
        // "Opel" Opel
        // "HongQi" HongQi
        // "Fiat" Fiat
        // "Jaguar" Jaguar
        // "Volvo" Volvo
        // "Acura" Acura
        // "Porsche" Porsche
        
        // "Jeep" Jeep
        // "Bentley" Bentley
        // "Bugatti" Bugatti
        // "ChuanQi" ChuanQi
        // "Daewoo" Daewoo
        // "DongNan" DongNan
        // "Ferrari" Ferrari
        // "Fudi" Fudi
        // "Huapu" Huapu
        // "HawTai" HawTai
        // "JMC" JMC
        // "JingLong" JingLong
        // "JoyLong" JoyLong
        // "Karry" Karry"
        // "Chrysler" Chrysler
        // "Lamborghini" Lamborghini
        // "RollsRoyce" RollsRoyce
        // "Linian" Linian
        // "LiFan" LiFan
        // "LieBao" LieBao
        // "Lincoln" Lincoln
        // "LandRover" LandRover
        // "Lotus" Lotus
        // "Maserati" Maserati
        // "Maybach" Maybach
        
        // "Mclaren" Mclaren
        // "Youngman" Youngman
        // "Tesla" Tesla
        // "Rely" Rely
        // "Lsuzu" Lsuzu
        // "Yiqi" Yiqi
        // "Infiniti" Infiniti
        // "YuTong" YuTong
        // "AnKai" AnKai
        // "Canghe" Canghe
        // "HaiMa" HaiMa
        // "Crown" Crown
        // "HuangHai" HuangHai
        // "JinLv" JinLv
        // "JinNing" JinNing
        // "KuBo" KuBo
        // "Europestar" Europestar
        // "MINI" MINI
        // "Gleagle" Gleagle
        // "ShiDai" ShiDai
        // "ShuangHuan" ShuangHuan
        // "TianYe" TianYe
        // "WeiZi" WeiZi
        // "Englon" Englon
        // "ZhongTong" ZhongTong
        
        // "Changan" Changan
        // "Yuejin" Yuejin
        // "Taurus" Taurus
        // "Alto" Alto
        // "Weiwang" Weiwang
        // "Chenglong" Chenglong
        // "Haige" Haige
        // "Shaolin" Shaolin
        // "Beifang" Beifang
        // "Beijing" Beijing
        // "Hafu" Hafu
        
        char                szObjectSubType[64];            // object sub type,different object type has different sub type:
        // Vehicle Category:"Unknown","Motor","Non-Motor","Bus","Bicycle","Motorcycle"
        // Plate Category:"Unknown","mal","Yellow","DoubleYellow","Police","Armed",
        // "Military","DoubleMilitary","SAR","Trainning"
        // "Personal" ,"Agri","Embassy","Moto","Tractor","Other"
        // HumanFace Category:"Normal","HideEye","HideNose","HideMouth"
        BYTE                byReserved1[3];
        bool                bPicEnble;                     // picture info enable
        DH_PIC_INFO         stPicInfo;                     // picture info
        bool				bShotFrame;						// is shot frame
        bool				bColor;							// rgbaMainColor is enable
        BYTE				byReserved2;
        BYTE                byTimeType;                     // ?¡§Time indicates the type of detailed instructions??EM_TIME_TYP
        NET_TIME_EX			stuCurrentTime;					// in view of the video compression,current time(when object snap or reconfnition, the frame will be attached to the frame in a video or pictures,means the frame in the original video of the time)
        NET_TIME_EX			stuStartTime;					// strart time(object appearing for the first time)
        NET_TIME_EX			stuEndTime;						// end time(object appearing for the last time)
        DH_RECT				stuOriginalBoundingBox;			// original bounding box(absolute coordinates)
        DH_RECT             stuSignBoundingBox;             // sign bounding box coordinate
        DWORD				dwCurrentSequence;				// The current frame number (frames when grabbing the object)
        DWORD				dwBeginSequence;				// Start frame number (object appeared When the frame number??
        DWORD				dwEndSequence;					// The end of the frame number (when the object disappearing Frame number)
        INT64				nBeginFileOffset;				// At the beginning of the file offset, Unit: Word Section (when objects began to appear, the video frames in the original video file offset relative to the beginning of the file??
        INT64				nEndFileOffset;					// At the end of the file offset, Unit: Word Section (when the object disappeared, video frames in the original video file offset relative to the beginning of the file)
        BYTE                byColorSimilar[NET_COLOR_TYPE_MAX];// Object color similarity, the range :0-100, represents an array subscript Colors, see EM_COLOR_TYPE??
        BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // When upper body color similarity (valid object type man ??
        BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // Lower body color similarity when objects (object type human valid ??
        int                 nRelativeID;                        // ID of relative object
        char				szSubText[20];						// "ObjectType"is "Vehicle" or "Logo"?? means a certain brand under LOGO??such as Audi A6L??since there are so many brands??SDK sends this field in real-time ,device filled as real.
        BYTE                byReserved[2];
    } DH_MSG_OBJECT;
    
    // intrusion direction
    typedef enum tagEM_MSG_OBJ_PERSON_DIRECTION
    {
        EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN,         // unknown direction
        EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT,  // from left to right
        EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT   // from right ro left
    }EM_MSG_OBJ_PERSON_DIRECTION;
    
    // Video analysis object info expansion structure
    typedef struct tagDH_MSG_OBJECT_EX
    {
        DWORD               dwSize;
        int                 nObjectID;                  // object ID, each ID means a exclusive object
        char                szObjectType[128];          // object  type
        int                 nConfidence;                //  confidence coefficient (0~255)?? value the bigger means  confidence coefficient the higher
        int                 nAction;                    // object  motion :1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
        DH_RECT             BoundingBox;                // box
        DH_POINT            Center;                     // object model center
        int                 nPolygonNum;                // polygon vertex number
        DH_POINT            Contour[DH_MAX_POLYGON_NUM];// relatively accurate outline the polygon
        DWORD               rgbaMainColor;              // means plate, vehicle body and etc. object major color??by byte means ??are red, green, blue and transparency , such as:RGB value is (0,255,0), transparency is 0, its value is 0x00ff0000.
        char                szText[128];                // same as DH_MSG_OBJECT corresponding field
        char                szObjectSubType[64];        // object sub type ??according to different object  types ??may use the following sub type ??
        // same as DH_MSG_OBJECT field
        BYTE                byReserved1[3];
        bool                bPicEnble;                  // object corresponding to picture file info or not
        DH_PIC_INFO         stPicInfo;                  // object corresponding to picture info
        bool                bShotFrame;                 // snapshot recognition result or not
        bool                bColor;                     // object  color (rgbaMainColor) usable or not
        BYTE                bLowerBodyColor;            // lower color (rgbaLowerBodyColor) usable or not
        BYTE                byTimeType;                 // time means type ?? see EM_TIME_TYPE note
        NET_TIME_EX         stuCurrentTime;             // for video compression?? current time stamp?¡§object snapshot or recognition?? attach this recognition frame in one vire frame or jpegpicture??this frame??s appearance time in original video??
        NET_TIME_EX         stuStartTime;               // start time stamp?¡§object start appearance??
        NET_TIME_EX         stuEndTime;                 // end time stamp?¡§object last aapearance??
        DH_RECT             stuOriginalBoundingBox;     // box(absolute coordinate)
        DH_RECT             stuSignBoundingBox;         // LGO coordinate box
        DWORD               dwCurrentSequence;          //  current frame no.?¡§snapshot this object frame??
        DWORD               dwBeginSequence;            // start frame no.?¡§object start appearance frame no.??
        DWORD               dwEndSequence;              // end frame no.?¡§object disappearance frame no.??
        INT64               nBeginFileOffset;           // start file shift, unit: byte?¡§object start appearance??video in original video file moves toward file origin??
        INT64               nEndFileOffset;             // End file shift, unit: byte?¡§object disappearance??video in original video file moves toward file origin??
        BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // object  color similarity??take  value range ??0-100??group subscript value represents certain color ?? see EM_COLOR_TYPE
        BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // upper object  color  similarity (object  type as human is valid )
        BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // lower object  color  similarity (object  type as human is valid )
        int                 nRelativeID;                // related object ID
        char				szSubText[20];              // "ObjectType"is "Vehicle"or "Logo"?? means LOGO lower brand??such as Audi A6L??since there are many brands??SDK shows this field in real-time,device filled as real.
        
        int					nPersonStature;	            // Intrusion staff height??unit cm
        EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;  // Staff intrusion direction
        DWORD               rgbaLowerBodyColor;         // Use direction same as rgbaMainColor,object  type as human is valid
    } DH_MSG_OBJECT_EX;
    
#pragma pack(pop)
    
    
    // snapshot info
    typedef struct
    {
        short              snSpeed;                          // current car speed,km/h
        short              snCarLength;                      // current car length, dm
        float              fRedTime;                         // current red light time, s.ms
        float              fCapTime;                         // current car way snapshot time, s.ms
        BYTE               bSigSequence;                     // current snapshot Sequence
        BYTE               bType;                            // current snapshot type
        // 0: radar up speed limit;1: radar low speed limit;2: car detector up speed limit;3:car detector low speed limit
        // 4: reverse;5: break red light;6: red light on;7: red light off;8: snapshot or traffic gate
        BYTE               bDirection;                       // breaking type :01:left turn;02:straight;03:right
        BYTE               bLightColor;                      // current car way traffic light state,0: green, 1: red, 2: yellow
        BYTE               bSnapFlag[16];                    // snap flag from device
    }DH_SIG_CARWAY_INFO;
    
    // Vehicle detector redundancy info
    typedef struct
    {
        BYTE                byRedundance[8];                // The vehicle detector generates the snap signal redundancy info
        BYTE                bReserved[120];                 // Reserved field
    }DH_SIG_CARWAY_INFO_EX;
    
    
    // car way info
    typedef struct
    {
        BYTE                bCarWayID;                           // current car way id
        BYTE                bReserve[2];                         // reserved
        BYTE                bSigCount;                           // being snapshotted
        DH_SIG_CARWAY_INFO  stuSigInfo[DH_MAX_SNAP_SIGNAL_NUM];  // the snapshot info
        BYTE                bReserved[12];                       // reserved
    }DH_CARWAY_INFO;
    
    // event file info
    typedef struct
    {
        BYTE               bCount;                               // the file count in the current file's group
        BYTE               bIndex;                               // the index of the file in the group
        BYTE               bFileTag;                             // file tag, see the enum struct EM_EVENT_FILETAG
        BYTE               bFileType;                            // file type,0-normal 1-compose 2-cut picture
        NET_TIME_EX        stuFileTime;                          // file time
        DWORD              nGroupId;                             // the only id of one group file
    }DH_EVENT_FILE_INFO;
    
    // pic resolution
    typedef struct
    {
        unsigned short   snWidth;    // width
        unsigned short   snHight;    // hight
    }DH_RESOLUTION_INFO;
    
    //  color RGBA
    typedef struct tagDH_COLOR_RGBA
    {
        int	        nRed;           // red
        int         nGreen;         // green
        int         nBlue;          // blue
        int         nAlpha;         // transparent
    } DH_COLOR_RGBA;
    
    // person info
    typedef struct tagFACERECOGNITION_PERSON_INFO
    {
        char                szPersonName[DH_MAX_NAME_LEN];		// name
        WORD				wYear;								// birth year
        BYTE				byMonth;							// birth month
        BYTE				byDay;								// birth day
        char                szID[DH_MAX_PERSON_ID_LEN];			// the unicle ID for the person
        BYTE                bImportantRank;						// importance level,1~10,the higher value the higher level
        BYTE                bySex;								// sex, 0-man, 1-female
        WORD                wFacePicNum;						// picture number
        DH_PIC_INFO         szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM]; // picture info
        BYTE                byType;                                         // Personnel types, see EM_PERSON_TYPE
        BYTE                byIDType;                                       // Document types, see EM_CERTIFICATE_TYPE
        BYTE                bReserved1[2];                                  // Byte alignment
        char                szProvince[DH_MAX_PROVINCE_NAME_LEN];           // province
        char                szCity[DH_MAX_CITY_NAME_LEN];                   // city
        char                szPersonNameEx[DH_MAX_PERSON_NAME_LEN];	        // Name, the name is too long due to the presence of 16 bytes can not be Storage problems, the increase in this parameter
        BYTE                bReserved[60];
    }FACERECOGNITION_PERSON_INFO;
    
    // cadidate person info
    typedef struct tagCANDIDATE_INFO
    {
        FACERECOGNITION_PERSON_INFO  stPersonInfo;            // person info
        BYTE                         bySimilarity;            // similarity
        BYTE                         byRange;                  // Range officer's database, see EM_FACE_DB_TYPE
        BYTE                         byReserved1[2];
        NET_TIME                     stTime;                  // When byRange historical database effectively, which means that the query time staff appeared
        char                         szAddress[MAX_PATH];     // When byRange historical database effectively, which means that people place a query appears
        BYTE                         byReserved[128];         // Reserved bytes
    }CANDIDATE_INFO;
    
    // TrafficCar
    typedef struct tagDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO
    {
        char               szPlateNumber[32];               // plate number
        char               szPlateType[32];                 // plate type
        char               szPlateColor[32];                // plate color, "Blue","Yellow", "White","Black"
        char               szVehicleColor[32];              // vehicle color, "White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
        int                nSpeed;                          // speed, Km/H
        char               szEvent[64];                     // trigger event type
        char               szViolationCode[32];             // violation code, see TrafficGlobal.ViolationCode
        char               szViolationDesc[64];             // violation describe
        int                nLowerSpeedLimit;                // lower speed limit
        int                nUpperSpeedLimit;                // upper speed limit
        int                nOverSpeedMargin;                // over speed margin, km/h
        int                nUnderSpeedMargin;               // under speed margin, km/h
        int                nLane;                           // lane
        int                nVehicleSize;                    // vehicle size, see VideoAnalyseRule's describe
        //  Bit 0:"Light-duty", small car
        // Bit 1:"Medium", medium car
        // Bit 2:"Oversize", large car
        // Bit 3:"Minisize", mini car
        // Bit 4:"Largesize", long car
        float              fVehicleLength;                  // vehicle length, m
        int                nSnapshotMode;                   // snap mode 0-normal,1-globle,2-near,4-snap on the same side,8-snap on the reverse side,16-plant picture
        char               szChannelName[32];               // channel name
        char               szMachineName[256];              // Machine name
        char               szMachineGroup[256];             // machine group
        char               szRoadwayNo[64];                 // road way number
        char               szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION];
        // DrivingDirection: for example ["Approach", "Shanghai", "Hangzhou"]
        // "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
        // the second and third param means the location of the driving direction
        char              *szDeviceAddress;                 // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
        char			   szVehicleSign[32];				// Vehicle identification, such as "Unknown" - unknown "Audi" - Audi, "Honda" - Honda ...
        DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // Generated by the vehicle inspection device to capture the signal redundancy
        char			  *szMachineAddr;					// Equipment deployment locations
        float              fActualShutter;                  // Current picture exposure time, in milliseconds
        BYTE               byActualGain;                    // Current picture gain, ranging from 0 to 100
        BYTE			   byDirection;						// 0 - south to north 1- Southwest to northeast 2 - West to east, 3 - Northwest to southeast 4 - north to south 5 - northeast to southwest 6 - East to West 7 - Southeast to northwest 8 - Unknown
        BYTE			   byReserved[2];
        char*			   szDetailedAddress;                   // Address, as szDeviceAddress supplement??
        char               szDefendCode[DH_COMMON_STRING_64];   // waterproof
        int                nTrafficBlackListID;                 // Link black list data recorddefualt main keyID, 0??invalid??> 0??black list data record
        DH_COLOR_RGBA      stuRGBA;                             // bofy color RGBA
        NET_TIME           stSnapTime;                          // snap time
        int                nRecNo;                              // Rec No
        char               szCustomParkNo[DH_COMMON_STRING_32 + 1]; // self defined parking space number?¡§for parking??
        BYTE               bReserved[703];                      // reserved
    }DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO;
    
    // the describe of EVENT_IVS_CROSSLINEDETECTION's data
    typedef struct tagDEV_EVENT_CROSSLINE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // rule detect line
        int                 nDetectLineNum;                        // rule detect line's point number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // object moveing track
        int                 nTrackLineNum;                         // object moveing track's point number
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
        BYTE                byReserved[1];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int        nOccurrenceCount;               // event trigger accumulated times
        BYTE                bReserved[608];	                // reserved
    } DEV_EVENT_CROSSLINE_INFO;
    
    // event type EVENT_IVS_CROSSLINEDETECTION_EX(warning line event )corresponding to  datadescriptioninfo
    typedef struct tagDEV_EVENT_CROSSLINE_INFO_EX
    {
        DWORD               dwSize;
        int                 nChannelID;                     // channel no.
        char                szName[128];                    // event name
        char                bReserved1[4];                  // field align
        float				PTS;                            // time stamp(unit is ms)
        NET_TIME_EX         UTC;                            // event occurance time
        int                 nEventID;                       // event ID
        DH_MSG_OBJECT_EX    stuObject;                      // detection object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event corresponding to file info
        DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // rule detection line
        int                 nDetectLineNum;                 // rule detection line top number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];// object motion track
        int                 nTrackLineNum;                  // object motion track top number
        BYTE                bEventAction;                   // event  motion ??0 means pulse event ,1 means continuity event  start ,2 means  continuity  event end;
        BYTE                bDirection;                     // means  intrusion direction, 0- leto to right, 1- right to left
        BYTE                byReserved[1];
        BYTE                byImageIndex;                   // picture no., same one time(accurate to second)may have multiple pictures , start from 0
        DWORD               dwSnapFlagMask;                 // snapshot mark(by bit)??see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // event source device index,-1 means invalid data,-1 means invalid data
        char                szSourceDevice[MAX_PATH];       // event source device SN, field do not existor is null means local device
        unsigned int        nOccurrenceCount;               // event trigger accumulated times
        int					nMsgObjArrayCount;              // detection object info number
        DH_MSG_OBJECT_EX*	pMsgObjArray;                   // detection object info group indicator
    } DEV_EVENT_CROSSLINE_INFO_EX;
    
    // the describe of EVENT_IVS_CROSSREGIONDETECTION's data
    typedef struct tagDEV_EVENT_CROSSREGION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved2[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
        int                 nDetectRegionNum;                          // rule detect region's point number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];          // object moving track
        int                 nTrackLineNum;                             // object moving track's point number
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bDirection;                     // direction, 0-in, 1-out,2-apaer,3-leave
        BYTE                bActionType;                    // action type,0-appear 1-disappear 2-in area 3-cross area
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int        nOccurrenceCount;               // event trigger times
        BYTE				bReserved[536];					// reserved
        int                 nObjectNum;                     // Detect object amount
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// Detected object
        int                 nTrackNum;                      // Locus amount(Corresponding to the detected object amount.)
        DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// Locus info(Corresponding to the detected object)
    } DEV_EVENT_CROSSREGION_INFO;
    
    // the describe of EVENT_IVS_PASTEDETECTION's data
    typedef struct tagDEV_EVENT_PASTE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        int                 nDetectRegionNum;				// rule detect region's point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        unsigned int        nOccurrenceCount;               // event trigger accumilated times
        BYTE				bReserved[884];			  	    // Reserved
        
    } DEV_EVENT_PASTE_INFO;
    
    // the describe of EVENT_IVS_LEFTDETECTION's data
    typedef struct tagDEV_EVENT_LEFT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[620];			  	// Reserved
        
    } DEV_EVENT_LEFT_INFO;
    
    // the describe of EVENT_IVS_PRESERVATION's data
    typedef struct tagDEV_EVENT_PRESERVATION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[620];			  	// Reserved
        
    } DEV_EVENT_PRESERVATION_INFO;
    
    // the describe of EVENT_IVS_STAYDETECTION's data
    typedef struct tagDEV_EVENT_STAY_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[620];			  	// Reserved
        
    } DEV_EVENT_STAY_INFO;
    
    // the describe of EVENT_IVS_WANDERDETECTION's data
    typedef struct tagDEV_EVENT_WANDER_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];                  //
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nObjectNum;                     // detected objects number
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// detected objects
        int                 nTrackNum;                      // track number
        DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track info
        int                 nDetectRegionNum;				// detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[756];					// reserved
        
    } DEV_EVENT_WANDER_INFO;
    
    // the describe of EVENT_IVS_MOVEDETECTION's data
    typedef struct tagDEV_EVENT_MOVE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        int                 nTrackLineNum;                  // Object trajectories vertices
        DH_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM]; // Object trajectories
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[536];					 // Reserved bytes, leave extended
        
    } DEV_EVENT_MOVE_INFO;
    
    // the describe of EVENT_IVS_TAILDETECTION's data
    typedef struct tagDEV_EVENT_TAIL_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //  detect region
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[620];
        
    } DEV_EVENT_TAIL_INFO;
    
    // the describe of EVENT_IVS_RIOTERDETECTION's data
    typedef struct tagDEV_EVENT_RIOTER_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nObjectNum;						// have being detected object number
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];                  //
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[624];
        
    } DEV_EVENT_RIOTERL_INFO;
    
    // the describe of EVENT_IVS_FIGHTDETECTION's data
    typedef struct tagDEV_EVENT_FIGHT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nObjectNum;						// have being detected object number
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];                  //
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[624];
    } DEV_EVENT_FIGHT_INFO;
    
    // the describe of EVENT_IVS_FIREDETECTION's data
    typedef struct tagDEV_EVENT_FIRE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];                  //
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// detect region point
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[620];					// Reserved
        
    } DEV_EVENT_FIRE_INFO;
    
    // Event type EVENT_IVS_GETOUTBEDDETECTION(event of getting out of bed in detention center) data block corresponding description information
    typedef struct tagDEV_EVENT_GETOUTBED_INFO
    {
        // Public field
        int                 nChannelID;                         // Channel Id
        char                szName[128];                        // Event name
        char                bReserved1[4];                      // byte alignment
        double              PTS;                                // Timestamp(millisecond)
        NET_TIME_EX         UTC;                                // The event happen time
        int                 nEventID;                           // Event ID
        // Event correspomds to field
        DH_MSG_OBJECT       stuObject;                          // Object said the object information who get off the bed
        int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
        DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
        BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
        
        BYTE                byReserved[2];                      // Reserve bytes
        BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON
        BYTE                bReserved[1024];                    // Reserve bytes,left to expand
    } DEV_EVENT_GETOUTBED_INFO;
    
    // Event type EVENT_IVS_PATROLDETECTION(guard detection event) data block corresponding description information
    typedef struct tagDEV_EVENT_PATROL_INFO
    {
        // Public field
        int                 nChannelID;                         // Channel Id
        char                szName[128];                        // Event name
        char                bReserved1[4];                      // byte alignment
        double              PTS;                                // Timestamp(millisecond)
        NET_TIME_EX         UTC;                                // the event happen time
        int                 nEventID;                           // Event ID
        // Event correspomds to field
        DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
        int                 nDetectRegionNum;                   // Number of vertex indetection region
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
        DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
        BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
        BYTE                byReserved[2];                      // Reserve bytes
        BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON
        BYTE                bReserved[1024];                    // Reserve bytes,left to expand
    } DEV_EVENT_PATROL_INFO;
    
    // Event type EVENT_IVS_ONDUTYDETECTION(guard detection event) data block corresponding description information
    typedef struct tagDEV_EVENT_ONDUTY_INFO
    {
        // Public field
        int                 nChannelID;                         // Channel Id
        char                szName[128];                        // Event name
        char                bReserved1[4];                      // byte alignment
        double              PTS;                                // Timestamp(millisecond)
        NET_TIME_EX         UTC;                                // the event happen time
        int                 nEventID;                           // Event ID
        // Field corresponding to the event
        DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
        int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
        DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
        BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
        
        BYTE                byReserved[2];                      // Reserve bytes,left to expand
        BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON
        DWORD               dwSnapFlagMask;                     // ¡Á???¡À¨º??(¡ã???)????????NET_RESERVED_COMMON
        BYTE                bReserved[1024];                    // Reserve bytes,left to expand
    } DEV_EVENT_ONDUTY_INFO;
    
    // the describe of EVENT_IVS_FIREDETECTION's data
    typedef struct tagDEV_EVENT_ELECTROSPARK_INFO
    {
        int					nChannelID;						// Channel Id
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        BYTE				bReserved[972];					// reserved
        
    } DEV_EVENT_ELECTROSPARK_INFO;
    
    // the describe of EVENT_IVS_SMOKEDETECTION's data
    typedef struct tagDEV_EVENT_SMOKE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[968];
        
    } DEV_EVENT_SMOKE_INFO;
    
    // the describe of EVENT_IVS_FLOWSTAT's data
    typedef struct tagDEV_EVENT_FLOWSTAT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nNumberLeft;					// the number of person across from left
        int					nNumberRight;					// the number of person across from right
        int					nUpperLimit;					// upper limit
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[972];
        
    } DEV_EVENT_FLOWSTAT_INFO;
    
    // the describe of EVENT_IVS_NUMBERSTAT's data
    typedef struct tagDEV_EVENT_NUMBERSTAT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved2[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nNumber;						// the number of object which is in the area
        int					nUpperLimit;					// upper limit
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bReserved1[2];                  //
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nEnteredNumber;                 // entered object number
        int                 nExitedNumber;                  // exited object number
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        unsigned int    nOccurrenceCount;          // event trigger accumilated times
        BYTE				bReserved[960];					// Reserved
        
    } DEV_EVENT_NUMBERSTAT_INFO;
    
    // the describe of EVENT_IVS_CROSSFENCEDETECTION's data
    typedef struct tagDEV_EVENT_CROSSFENCEDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int					nUpstairsLinePointNumber;		               // Upstairs Line Point Number
        DH_POINT		    stuUpstairsLine[DH_MAX_DETECT_LINE_NUM];	   // Upstairs Line info
        int					nDownstairsLinePointNumber;		               // Downstairs Line Point Number
        DH_POINT		    stuDownstairsLine[DH_MAX_DETECT_LINE_NUM];     // Downstairs Line info
        int                 nTrackLineNum;                                 // track line point number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];              // track line info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
        BYTE                byReserved[1];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[748];				// Reserved
    } DEV_EVENT_CROSSFENCEDETECTION_INFO;
    
    // the describe of EVENT_IVS_INREGIONDETECTION's data
    typedef struct tagDEV_EVENT_INREGIONDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int                 nObjectNum;                     // have being detected objects number
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// have being detected objects
        int                 nTrackNum;                      // track line number
        DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track lines info
        int                 nDetectRegionNum;				// detect regions number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect regions
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        BYTE				bReserved[1016];				// Reserved
        
    } DEV_EVENT_INREGIONDETECTION_INFO;
    
    // the describe of EVENT_IVS_TAKENAWAYDETECTION's data
    typedef struct tagDEV_EVENT_TAKENAWAYDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						//  have being detected object
        int                 nDetectRegionNum;				// detect region's point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[748];				  // Reserved
        
    } DEV_EVENT_TAKENAWAYDETECTION_INFO;
    
    // the describe of EVENT_IVS_VIDEOABNORMALDETECTION's data
    typedef struct tagDEV_EVENT_VIDEOABNORMALDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bType;                          // type, 0-video lost, 1-video freeze, 2-video blind, 3-camera moving, 4-too dark, 5-too light
        BYTE                byReserved[1];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[752];					// Reserved
        
    } DEV_EVENT_VIDEOABNORMALDETECTION_INFO;
    
    // the describe of EVENT_IVS_PARKINGDETECTION's data
    typedef struct tagDEV_EVENT_PARKINGDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int                 nDetectRegionNum;				// detect region's point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[748];				  // Reserved
        
    } DEV_EVENT_PARKINGDETECTION_INFO;
    
    // the describe of EVENT_IVS_ABNORMALRUNDETECTION's data
    typedef struct tagDEV_EVENT_ABNORMALRUNDETECTION
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        double              dbSpeed;                        // speed ,km/h
        double              dbTriggerSpeed;                 // triggerSpeed,km/h
        int                 nDetectRegionNum;				// detect region's point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
        int                 nTrackLineNum;                         // track line point number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // track line info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bRunType;                       // type, 0-run fast, 1-sudden speedup, 2-sudden speed-down
        BYTE                byReserved[1];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[748];				  // Reserved
        
    } DEV_EVENT_ABNORMALRUNDETECTION_INFO;
    
    // the describe of EVENT_IVS_RETROGRADEDETECTION's data
    typedef struct tagDEV_EVENT_RETROGRADEDETECTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int                 nTrackLineNum;                           // track line point number
        DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];        // track line info
        int                 nDirectionPointNum;                      // direction point number
        DH_POINT            stuDirections[DH_MAX_DETECT_LINE_NUM];   // direction info
        int                 nDetectRegionNum;				         // detect region's point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];  // detect region info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int    nOccurrenceCount;              // event trigger accumilated times
        BYTE				bReserved[748];				  // Reserved
        
    } DEV_EVENT_RETROGRADEDETECTION_INFO;
    
    // the describe of EVENT_IVS_FACERECOGNITION's data
    typedef struct tagDEV_EVENT_FACERECOGNITION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        int                 nEventID;                       // event ID
        NET_TIME_EX			UTC;							// the event happen time
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int                 nCandidateNum;                  // candidate number
        CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM]; // candidate info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        BYTE				byReserved1[2];				    // reserved
        BOOL                bGlobalScenePic;                // The existence panorama
        DH_PIC_INFO         stuGlobalScenePicInfo;          // Panoramic Photos
        char                szSnapDevAddress[MAX_PATH];     // Snapshot current face aadevice address
        unsigned int        nOccurrenceCount;               // event trigger accumilated times
        BYTE                bReserved[724];                 // reserved
    }DEV_EVENT_FACERECOGNITION_INFO;
    
    // Event type EVENT_IVS_DENSITYDETECTION(Population amount detect) corresponding data block description info
    typedef struct tagDEV_EVENT_DENSITYDETECTTION_INFO
    {
        int					nChannelID;						// Channel No.
        char				szName[128];					// Event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// Event ID
        int					nObjectNum;						// Detected object amount
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// Detected object list
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];                  // Reserved field
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				// Acme amount of the rule detect zone
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone
        
        DWORD               dwSnapFlagMask;	                // Snap flag(by bit).please refer to NET_RESERVED_COMMON
        int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int        nOccurrenceCount;               // event trigger accumilated times
        BYTE                bReserved[752];                 // Reserved field. For extension use.
    }DEV_EVENT_DENSITYDETECTION_INFO;
    
    // Event type  EVENT_IVS_QUEUEDETECTION(queue detection)corresponding data block description info
    typedef struct tagDEV_EVENT_QUEUEDETECTION_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved2[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE				bReserved1[2];				    // reserved
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DH_POINT            stuDetectLine[2];               // detect line
        unsigned int        nOccurrenceCount;               // event trigger accumilated times
        BYTE                bReserved[1012];                // reserved
    }DEV_EVENT_QUEUEDETECTION_INFO;
    
    // Event type EVENT_IVS_TRAFFICCONTROL(traffic control)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFICCONTROL_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        BYTE				bReserved[972];					// Reserved field. For extension use.
        
    } DEV_EVENT_TRAFFICCONTROL_INFO;
    
    // the describe of EVENT_IVS_TRAFFICACCIDENT's data
    typedef struct tagDEV_EVENT_TRAFFICACCIDENT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nObjectNum;						// have being detected object number
        DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        BYTE				bReserved[976];					// Reserved
        
    } DEV_EVENT_TRAFFICACCIDENT_INFO;
    
#define DH_EVENT_MAX_CARD_NUM       16    // Incident reporting information includes the maximum number of cards
#define DH_EVENT_CARD_LEN           36    // Card Name Length
    
    // Incidents reported to carry the card information
    typedef struct tagEVENT_CARD_INFO
    {
        char szCardNumber[DH_EVENT_CARD_LEN];     // Card number string
        BYTE bReserved[32];	                      // Reserved bytes, leave extended
    }EVENT_CARD_INFO;
    
    typedef enum tagEM_OPEN_STROBE_STATE
    {
        NET_OPEN_STROBE_STATE_UNKOWN,                   // unknown
        NET_OPEN_STROBE_STATE_CLOSE,                    // close
        NET_OPEN_STROBE_STATE_AUTO,                     // auto open
        NET_OPEN_STROBE_STATE_MANUAL,                   // manual open
    }EM_OPEN_STROBE_STATE;
    
    typedef enum tagEM_VEHICLE_DIRECTION
    {
        NET_VEHICLE_DIRECTION_UNKOWN,                   // unknown
        NET_VEHICLE_DIRECTION_HEAD,                     // head
        NET_VEHICLE_DIRECTION_TAIL,                     // rear
    }EM_VEHICLE_DIRECTION;
    
    //NTP???¡Àstatus
    typedef enum tagEM_NTP_STATUS
    {
        NET_NTP_STATUS_UNKNOWN = 0 ,
        NET_NTP_STATUS_DISABLE     ,
        NET_NTP_STATUS_SUCCESSFUL  ,
        NET_NTP_STATUS_FAILED      ,
    }EM_NTP_STATUS;
    
    typedef struct tagEVENT_COMM_INFO
    {
        EM_NTP_STATUS       emNTPStatus;	//NTP time sync status
        int                 nDriversNum;    //driver info number
        DH_MSG_OBJECT_EX*   pstDriversInfo; //driver info data
        char*               pszFilePath;    //writing path for loacl disk or sd card, or write to default path if NULL
        char*               pszFTPPath;     //ftp path
        char*               pszVideoPath;   //ftp path for assocated video
        BYTE                bReserved[2024];
    }EVENT_COMM_INFO;
    
    //?¡§Event Type EVENT_IVS_TRAFFICJUNCTION (transportation card traffic junctions old rule event / video port on the old electric alarm event rules) corresponding to the description of the data block??
    //?¡§Due to historical reasons, if you want to deal with bayonet event, DEV_EVENT_TRAFFICJUNCTION_INFO and EVENT_IVS_TRAFFICGATE be processed together to prevent police and video electrical coil electric alarm occurred while the case access platform??
    // ?¡§Also EVENT_IVS_TRAFFIC_TOLLGATE only support the new bayonet events??
    typedef struct tagDEV_EVENT_TRAFFICJUNCTION_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        BYTE                byMainSeatBelt;                 // main driver??s seat??safety belt ??1-fastened??2-unfastened
        BYTE                bySlaveSeatBelt;                // co-drvier??s seat??safety belt??1-fastened??2-unfastened
        BYTE                byVehicleDirection;             // Current snapshot is head or rear??see  EM_VEHICLE_DIRECTION
        BYTE                byOpenStrobeState;              // Open status??see EM_OPEN_STROBE_STATE
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int					nLane;							// road number
        DWORD				dwBreakingRule;					// BreakingRule's mask,first byte: crash red light;
        // secend byte:break the rule of driving road number;
        // the third byte:converse; the forth byte:break rule to turn around;
        // the five byte:traffic jam; the six byte:traffic vacancy;
        // the seven byte: Overline; defalt:trafficJunction
        NET_TIME_EX			RedLightUTC;					// the begin time of red light
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;                         // car's speed (km/h)
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byDirection;                    // Intersection direction 1 - denotes the forward 2 - indicates the opposite
        BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
        BYTE                byReserved;                  // reserved
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        char                szRecordFile[DH_COMMON_STRING_128]; // Alarm corresponding original video file information
        BYTE				bReserved[340];				    // Reserved bytes, leave extended_
        int                 nTriggerType;                   // Trigger Type:0 vehicle inspection device??1 radar??2 video
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        DWORD               dwRetCardNumber;                // Card Number
        EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // Card information
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFICJUNCTION_INFO;
    
    
    // the describe of EVENT_IVS_TRAFFICGATE's data
    typedef struct tagDEV_EVENT_TRAFFICGATE_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        BYTE                byOpenStrobeState;              // Open gateway status??see EM_OPEN_STROBE_STATE
        char                bReserved1[3];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        int					nLane;							// road number
        int					nSpeed;							// the car's actual rate(Km/h)
        int					nSpeedUpperLimit;				// rate upper limit(km/h)
        int					nSpeedLowerLimit;				// rate lower limit(km/h)
        DWORD				dwBreakingRule;					// BreakingRule's mask,first byte: Retrograde;
        // second byte:Overline; the third byte:Overspeed;
        // the forth byte:UnderSpeed;the five byte: crash red light;the six byte:passing(trafficgate)
        // the seven byte: OverYellowLine; the eight byte: WrongRunningRoute; the nine byte: YellowVehicleInRoute; default: trafficgate
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        BYTE                szManualSnapNo[64];             // manual snap sequence string
        int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[3];                  // reserved
        BYTE                szSnapFlag[16];                 // snap flag from device
        BYTE                bySnapMode;                     // snap mode,0-normal 1-globle 2-near 4-snap on the same side 8-snap on the reverse side 16-plant picture
        BYTE                byOverSpeedPercentage;          // over speed percentage
        BYTE                byUnderSpeedingPercentage;      // under speed percentage
        BYTE                byRedLightMargin;               // red light margin, s
        BYTE                byDriveDirection;               // drive direction,0-"Approach",where the car is more near,1-"Leave",means where if mor far to the car
        char                szRoadwayNo[32];                // road way number
        char                szViolationCode[16];            // violation code
        char                szViolationDesc[128];           // violation desc
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        char                szVehicleType[32];              // car type,"Motor", "Light-duty", "Medium", "Oversize", "Huge", "Other"
        BYTE                byVehicleLenth;                 // car length, m
        BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
        BYTE                byReserved1;                 // reserved
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nOverSpeedMargin;               // over speed margin, km/h
        int                 nUnderSpeedMargin;              // under speed margin, km/h
        char                szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION]; //
        // "DrivingDirection" : ["Approach", "Shanghai", "Hangzhou"],
        // "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
        // the second and third param means the location of the driving direction
        char                szMachineName[256];             // machine name
        char                szMachineAddress[256];          // machine address
        char                szMachineGroup[256];            // machine group
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // The vehicle detector generates the snap signal redundancy info
        char                szFilePath[MAX_PATH];           // File path
        NET_TIME_EX			RedLightUTC;					// the begin time of red light
        char              * szDeviceAddress;                // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
        float               fActualShutter;                 // Current picture exposure time, in milliseconds
        BYTE                byActualGain;                   // Current picture gain, ranging from 0 to 1000
        BYTE                byDirection;                    // 0-S to N  1-SW to NE 2-W to E 3-NW to SE 4-N to S 5-NE to SW 6-E to W 7-SE to NW 8-Unknown
        BYTE                bReserve;                       // Reserved bytes, byte alignment
        BYTE                bRetCardNumber;                 // Card Number
        EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];// Card information
        char               szDefendCode[DH_COMMON_STRING_64];// Waterproof
        int                nTrafficBlackListID;             // Link to balcklist main keyID, 0??invalid??> 0??blacklist data record
        EVENT_COMM_INFO     stCommInfo;                     // public info
        BYTE                bReserved[452];	                // Reserved bytes, leave extended
    } DEV_EVENT_TRAFFICGATE_INFO;
    
    //the describe of EVENT_TRAFFICSNAPSHOT's data
    typedef struct tagDEV_EVENT_TRAFFICSNAPSHOT_INFO
    {
        int					nChannelID;						// ChannelId
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        BYTE                bReserv[3];                       // reserved
        BYTE                bCarWayCount;                     // car way number being snapshotting
        DH_CARWAY_INFO      stuCarWayInfo[DH_MAX_CARWAY_NUM]; // car way info being snapshotting
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        BYTE				bReserved[344];		    		// Reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFICSNAPSHOT_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_RUNREDLIGHT's data
    typedef struct tagDEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;				              // the event happen time
        int					nEventID;			              // event ID
        int					nLane;				              // Corresponding Lane number
        DH_MSG_OBJECT		stuObject;	              	      // have being detected object
        DH_MSG_OBJECT       stuVehicle;                       // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
        int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
        int					nSpeed;			              	  // speed,km/h
        int                 nSequence;                        // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;					  // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;					  // flag(by bit),see NET_RESERVED_COMMON
        NET_TIME_EX         stRedLightUTC;                    // time of red light starting
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                byRedLightMargin;               // red light margin, s
        BYTE				bReserved[975];	                  // Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    } DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_OVERLINE's data
    typedef struct tagDEV_EVENT_TRAFFIC_OVERLINE_INFO
    {
        int					nChannelID;			// channel ID
        char				szName[128];		// event name
        char                bReserved1[4];      // byte alignment
        double				PTS;				// PTS(ms)
        NET_TIME_EX			UTC;				// the event happen time
        int					nEventID;			// event ID
        int					nLane;				// Corresponding Lane number
        DH_MSG_OBJECT		stuObject;			// have being detected object
        DH_MSG_OBJECT       stuVehicle;         // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
        int                 nSequence;          // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;             // speed,km/h
        BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;      // picture resolution
        BYTE				bReserved[1008];	// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    } DEV_EVENT_TRAFFIC_OVERLINE_INFO;
    
    
    //the describe of EVENT_IVS_TRAFFIC_RETROGRADE's data
    typedef struct tagDEV_EVENT_TRAFFIC_RETROGRADE_INFO
    {
        int					nChannelID;			// channel ID
        char				szName[128];		// event name
        char                bReserved1[4];      // byte alignment
        double				PTS;				// PTS(ms)
        NET_TIME_EX			UTC;				// the event happen time
        int					nEventID;			// event ID
        int					nLane;				// Corresponding Lane number
        DH_MSG_OBJECT		stuObject;			// have being detected object
        DH_MSG_OBJECT       stuVehicle;         // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
        int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;             // speed, km/h
        BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;        // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	     // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;       // picture resolution
        BOOL                bIsExistAlarmRecord;            // a corresponding alarm recording; false: no corresponding alarm recording
        DWORD               dwAlarmRecordSize;              // Video size
        char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
        BYTE				bReserved[656];	// Reserved bytes
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;    // Traffic vehicle info
        int                 nDetectNum;				  // Acme amount of the rule detect zone
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone
        EVENT_COMM_INFO   stCommInfo;                 // public info
    } DEV_EVENT_TRAFFIC_RETROGRADE_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_TURNLEFT's data
    typedef struct tagDEV_EVENT_TRAFFIC_TURNLEFT_INFO
    {
        int					nChannelID;			// channel ID
        char				szName[128];		// event name
        char                bReserved1[4];      // byte alignment
        double				PTS;				// PTS(ms)
        NET_TIME_EX			UTC;				// the event happen time
        int					nEventID;			// event ID
        int					nLane;				// Corresponding Lane number
        DH_MSG_OBJECT		stuObject;			// have being detected object
        DH_MSG_OBJECT       stuVehicle;         // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
        int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;             // speed,km/h
        BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;      // picture resolution
        
        BYTE				bReserved[1008];	// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    } DEV_EVENT_TRAFFIC_TURNLEFT_INFO;
    
    
    //the describe of EVENT_IVS_TRAFFIC_TURNRIGHT's data
    typedef struct tagDEV_EVENT_TRAFFIC_TURNRIGHT_INFO
    {
        int					nChannelID;			// channel ID
        char				szName[128];		// event name
        char                bReserved1[4];      // byte alignment
        double				PTS;				// PTS(ms)
        NET_TIME_EX			UTC;				// the event happen time
        int					nEventID;			// event ID
        int					nLane;				// Corresponding Lane number
        DH_MSG_OBJECT		stuObject;			// have being detected object
        DH_MSG_OBJECT       stuVehicle;         // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
        int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;             // speed,km/h
        BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;      // picture resolution
        
        BYTE				bReserved[1008];	// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    } DEV_EVENT_TRAFFIC_TURNRIGHT_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_UTURN's data
    typedef struct tagDEV_EVENT_TRAFFIC_UTURN_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;						   	  // the event happen time
        int					nEventID;					      // event ID
        int					nLane;							  // Corresponding Lane number
        DH_MSG_OBJECT		stuObject;						  // have being detected object
        DH_MSG_OBJECT       stuVehicle;                       // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
        int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int                 nSpeed;             			  // speed,km/h
        BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        
        BYTE                bReserved[1008];				  // Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    }DEV_EVENT_TRAFFIC_UTURN_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_OVERSPEED's data
    typedef struct tagDEV_EVENT_TRAFFIC_OVERSPEED_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;						   	  // the event happen time
        int					nEventID;					      // event ID
        int					nLane;							  // Corresponding Lane number
        DH_MSG_OBJECT		stuObject;						  // have being detected object
        DH_MSG_OBJECT       stuVehicle;                       // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
        int                 nSpeed;                           // vehicle speed Unit:Km/h
        int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
        int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h
        int                 nSequence;                        // snap index:such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2 means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        char                szFilePath[MAX_PATH];             // Faile path
        BYTE                bReserved[748];				      // Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    }DEV_EVENT_TRAFFIC_OVERSPEED_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_UNDERSPEED's data
    typedef struct tagDEV_EVENT_TRAFFIC_UNDERSPEED_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved2[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;						   	  // the event happen time
        int					nEventID;					      // event ID
        int					nLane;							  // Corresponding Lane number
        DH_MSG_OBJECT		stuObject;						  // have being detected object
        DH_MSG_OBJECT       stuVehicle;                       // vehicle info
        DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
        int                 nSpeed;                           // vehicle speed Unit:Km/h
        int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
        int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h
        int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bReserved1[2];                    // reserved
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nUnderSpeedingPercentage;         // under speed percentage
        DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        
        BYTE                bReserved[1004];				  // Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        EVENT_COMM_INFO   stCommInfo;                 // public info
    }DEV_EVENT_TRAFFIC_UNDERSPEED_INFO;
    
    //the describe of EVENT_IVS_FACEDETECT's data
    typedef struct tagDEV_EVENT_FACEDETECT_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;						   	  // the event happen time
        int					nEventID;					      // event ID
        DH_MSG_OBJECT		stuObject;						  // have being detected object
        DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
        BYTE                bEventAction;                     // Event action: 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                reserved[2];                      // reserved
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nDetectRegionNum;				  // detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
        DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
        char                szSnapDevAddress[MAX_PATH];       // snapshot current face device address
        unsigned int        nOccurrenceCount;                 // event trigger accumilated times
        BYTE                bReserved[672];                   // Reserved
    } DEV_EVENT_FACEDETECT_INFO;
    
    // the describe of EVENT_IVS_TRAFFICJAM's data
    typedef struct tagDEV_EVENT_TRAFFICJAM_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                bJamLenght;                     // Mean congestion length (percentage of total lane length) 0-100
        BYTE                reserved;                    // reserved
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        NET_TIME_EX         stuStartJamTime;				// the time of starting jam
        int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2)
        int                 nAlarmIntervalTime;             // interval time of alarm(s).(this is a continuous event,if the interval time of recieving next event go beyond this parm, we can judge that this event is over with exception)
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        int                 nJamRealLength;                 // means actual jam length, unit is meter
        BYTE				bReserved[1008];				// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFICJAM_INFO;
    
    // the describe of EVENT_IVS_TRAFFIC_PARKING's data
    typedef struct tagDEV_EVENT_TRAFFIC_PARKING_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                reserved[2];                    // Reserved bytes
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        NET_TIME_EX         stuStartParkingTime;            // the time of starting parking
        int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2)
        int                 nAlarmIntervalTime;             // interval time of alarm(s) (this is a continuous event,if the interval time of recieving next event go beyond this parm, we can judge that this event is over with exception)
        int                 nParkingAllowedTime;            // the time of legal parking
        int                 nDetectRegionNum;				// detect region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region point number
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
        DWORD               dwAlarmRecordSize;              // Video size
        char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
        char                szFTPPath[DH_COMMON_STRING_256];// FTP path
        BYTE				bReserved[404];				    // Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFIC_PARKING_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_WRONGROUTE's data
    typedef struct tagDEV_EVENT_TRAFFIC_WRONGROUTE_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nSpeed;                         // speed,km/h
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE				bReserved[1012];				// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFIC_WRONGROUTE_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_CROSSLANE's data
    typedef struct tagDEV_EVENT_TRAFFIC_CROSSLANE_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nSpeed;                         // speed,km/h
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE				bReserved[1008];				// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // traffic vehicle info
        EVENT_COMM_INFO     stCommInfo;                     // public info
    } DEV_EVENT_TRAFFIC_CROSSLANE_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_OVERYELLOWLINE's data
    typedef struct tagDEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nSpeed;                         // speed,km/h
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
        DWORD               dwAlarmRecordSize;              // Video size
        char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
        BYTE				bReserved[664];				// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        
        int                 nDetectNum;				                   // Acme amount of the rule detect zone
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone
        EVENT_COMM_INFO     stCommInfo;                                // public info
    } DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER's data
    typedef struct tagDEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nSpeed;                         // speed,km/h
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE				bReserved[1008];				//
        EVENT_COMM_INFO     stCommInfo;                     // public info
        
    } DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE's data
    typedef struct tagDEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// Corresponding Lane number
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nSpeed;                         // speed,km/h
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE				bReserved[1016];				// Reserved
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        EVENT_COMM_INFO     stCommInfo;                     // public info
        
    } DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO;
    
    
    //the describe of EVENT_IVS_TRAFFIC_NOPASSING's data
    typedef struct tagDEV_EVENT_TRAFFIC_NOPASSING_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[DH_EVENT_NAME_LEN];					// event name
        int                 nTriggerType;                   // Trigger Type, 0 vehicle inspection device, 1 radar, 2 video
        DWORD				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int                 UTCMS;                          //
        int                 nMark;                          //
        int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        BYTE                byReserved1[3];
        int                 nLane;                          // Corresponding lane number
        DH_MSG_OBJECT		stuObject;						// Object to be detected
        DH_MSG_OBJECT       stuVehicle;                     // car body information
        int                 nFrameSequence;                 // Video analysis frame number
        int                 nSource;                        // Data source address of the video analysis
        BYTE				byReserved[1024];	            // Reserved bytes
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_NOPASSING_INFO;
    typedef struct tagDH_TRAFFICFLOWSTAT
    {
        char				szMachineAddress[256];			// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineGroup
        char				szMachineName[256];				// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineName
        char				szDrivingDirection[3][32];		// DrivingDirection "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car,the scend and third param means the location of the driving direction
        int					nLane;							// lane number
        NET_TIME_EX			UTC;							// Statistic time
        int					nPeriod;						// Statistic period, m
        int					nVehicles;						// passed vehicle number
        float				fAverageSpeed;					// average speed, km/h
        float				fAverageLength;					// average length, m
        float				fTimeOccupyRatio;				// time occupy ratio,
        float				fSpaceOccupyRatio;				// space occupy ratio,
        float				fSpaceHeadway;					// space between two cars,m
        float				fTimeHeadway;					// time between two cars, s
        float				fDensity;						// car density, every km
        int					nOverSpeedVehicles;				// over speed vehicle number
        int					nUnderSpeedVehicles;			// under speed vehicle number
        int					nLargeVehicles;					// big car number
        int					nMediumVehicles;				// mid car number
        int					nSmallVehicles;					// small car number
        int					nMotoVehicles;					// moto car number
        int					nLongVehicles;					// long vehicle number
    }DH_TRAFFICFLOWSTAT;
    // the describe of EVENT_IVS_TRAFFIC_FLOWSTATE's data
    typedef struct tagDEV_EVENT_TRAFFIC_FLOWSTAT_INFO
    {
        char				szName[128];					// name
        double				PTS;							// time stamp(ms)
        NET_TIME_EX			UTC;							// occurrence time
        int					nEventID;						// event id
        int					nLaneCnt;						// channel number
        DH_TRAFFICFLOWSTAT	stTrafficFlowStats[DH_MAX_LANE_NUM];//traffic flow state info
        char				Reserved[4];					// byte alignment
    }DEV_EVENT_TRAFFIC_FLOWSTAT_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_MANUALSNAP's data
    typedef struct tagDEV_EVENT_TRAFFIC_MANUALSNAP_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        int					nLane;							// lane number
        BYTE                szManualSnapNo[64];             // manual snap number
        DH_MSG_OBJECT		stuObject;						// have being detected object
        DH_MSG_OBJECT       stuVehicle;                     // have being detected vehicle
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE				bReserved[1016];				//
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_MANUALSNAP_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_STAY's data
    typedef struct tagDEV_EVENT_TRAFFIC_STAY_INFO
    {
        int					nChannelID;						// channel id
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// object info
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// lane number
        int					nSequence;						// snap index
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction; 					// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved0[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE                byReserved[1012];
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_STAY_INFO;
    
    //the describe of EVENT_IVS_TRAFFIC_VEHICLEINROUTE's data
    typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO
    {
        int					nChannelID;						// channel id
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// object info
        DH_MSG_OBJECT       stuVehicle;                     // vehicle info
        int					nLane;							// lane number
        int					nSequence;						// snap index
        int					nSpeed;							// speed
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
        BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved0[2];
        BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        BYTE                byReserved[1016];
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO;
    
    // the describe of EVENT_ALARM_LOCALALARM and EVENT_ALARM_MOTIONALARM's data
    typedef struct tagDEV_EVENT_ALARM_INFO
    {
        int					nChannelID;						// channel id
        char				szName[128];					// evnent name
        char				Reserved[4];					// byte alignment
        double				PTS;							// PTS(ms)
        NET_TIME_EX			UTC;							// the event happen time
        int					nEventID;						// evnet ID
    }DEV_EVENT_ALARM_INFO;
    
    // Alarm event type EVENT_ALARM_ANALOGALARM(analog alarm channel alarm),
    typedef struct tagDEV_EVENT_ALARM_ANALOGALRM_INFO
    {
        int                 nChannelID;                                 // (video)channel no.
        char                szName[DH_COMMON_STRING_128];               // analog alarm channel name
        char                Reserved[4];                                // reserve text align
        double              PTS;                                        // time stamp(unit is ms)
        NET_TIME_EX         UTC;                                        // event time
        int                 nEventID;                                   // event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                                // event corresponding file info
        int                 nIndex;                                     // analog alarm channel no.
        NET_SENSE_METHOD    emSensor;                                   // sensor type
        int                 nStatus;                                    // data status, -1:unknown,0:normal,1:invalid data(over meansure),
        // 2:over threshold1,3:over threshold2,4:over threshold3,5: over threshold 4,
        // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
        float               fValue;                                     // detector value
        NET_TIME            stuCollectTime;                             // data collection time(UTC)
        DWORD               dwSnapFlagMask;                             // snapshotmark(by bit)??see NET_RESERVED_COMMON
        BYTE                bEventAction;                               // event action??0 means impulse event,1 means continuous event start,2 means continuous event end;
        BYTE                byReserved2[1023];                          // reserve text,for extension
    }DEV_EVENT_ALARM_ANALOGALRM_INFO;
    
    //EVENT_ALARM_VEHICLEACC(ACC outage alarm)
    typedef struct tagDEV_EVENT_ALARM_VEHICLEACC_INFO
    {
        int					nChannelID;						// (Channel number)
        char				szName[DH_COMMON_STRING_128];	// (Event Name)
        char				Reserved[4];					// (Reserved byte alignment)
        double				PTS;							// (Timestamp (in milliseconds)
        NET_TIME_EX			UTC;							// (Time the event occurred)
        int					nEventID;						// (Event ID)
        NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
        int					nACCStatus;						// (ACC status 0: Invalid (compatible with), 1: On, 2: Off)
        BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, an event starts, said persistent, 2 for persistent event ends;)
        BYTE				bConstantElectricStatus;		// (Often charged state 0: Invalid (compatible with), 1: Connection 2: Disconnect)
        BYTE                bReserved[1022];                // (Reserved bytes, left extensions.)
    }DEV_EVENT_ALARM_VEHICLEACC_INFO;
    
    
    // alarm event type EVENT_ALARM_VEHICLE_TURNOVER(vehicle side turn) , EVENT_ALARM_VEHICLE_COLLISION(collision)
    typedef struct tagDEV_EVENT_VEHICEL_ALARM_INFO
    {
        int					nChannelID;						// (Channel number)
        char				szName[128];					// ( event name )
        char				Reserved[4];					// ?¡§Reserved bytes, left extensions.)
        double				PTS;							// (Timestamp (in milliseconds))
        NET_TIME_EX			UTC;							// (Time for the event occurred )
        int					nEventID;						// (Event ID)
        NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
        DH_EVENT_FILE_INFO  stuFileInfo;                    // (Event corresponding to file information)
        BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
        BYTE                byReserved[2];					// (With Byte alignment)
        BYTE				byImageIndex;					// (Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0??)
        DWORD               dwSnapFlagMask;                 // (Grab flag (bit), see specific NET_RESERVED_COMMON)
        DH_RESOLUTION_INFO  stuResolution;                  // (Corresponding to the resolution of the picture??
        BYTE                bReserved[1024];                // (Reserved bytes, left extensions.)
    }DEV_EVENT_VEHICEL_ALARM_INFO;
    
    // the describe of  EVENT_IVS_PRISONERRISEDETECTION's data
    typedef struct tagDEV_EVENT_PRISONERRISEDETECTION_INFO
    {
        int					nChannelID;						  // channel id
        char				szName[128];					  // evnent name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // PTS(ms)
        NET_TIME_EX			UTC;						   	  // he event happen time
        int					nEventID;					      // evnet ID
        DH_MSG_OBJECT		stuObject;						  // object info
        int                 nDetectRegionNum;				  // region point number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // region
        DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
        double				dInitialUTC;			  		  // UTC init time
        BYTE                bEventAction;                     // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
        int                 nSourceIndex;                     // the source device's index,-1 means data in invalid
        char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
        unsigned int        nOccurrenceCount;                 // event trigger accumilated times
        BYTE				bReserved[748];	                  // Reserved
    }DEV_EVENT_PRISONERRISEDETECTION_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(Pedestal has higher priority at the  crosswalk) corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO
    {
        int                 nChannelID;                       // Channel No.
        char                szName[128];                      // Event name
        char                bReserved1[4];                    // byte alignment
        double              PTS;                              // Time stamp(ms)
        NET_TIME_EX         UTC;                              // Event occurred time
        int                 nEventID;                         // Event ID
        DH_MSG_OBJECT       stuObject;                        // Detected object
        DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
        int                 nLane;                            // Corresponding lane No.
        double				dInitialUTC;			  		  // Event initial UTC time 	UTC is the second of the event UTC (1970-1-1 00:00:00)
        BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;     // The record of the database of the traffic vehicle
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                bReserved[1024];                  // Reserved field for future extension.
        EVENT_COMM_INFO     stCommInfo;                       // public info
    }DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(vehicle in bus route)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO
    {
        int                 nChannelID;                       // channel ID
        char                szName[128];                      // event name
        char                bReserved1[4];                    // byte alignment
        double              PTS;                              // Time stamp(ms)
        NET_TIME_EX         UTC;                              // Event occurred time
        int                 nEventID;                         // Event ID
        DH_MSG_OBJECT       stuObject;                        // Detected object
        DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
        int                 nLane;                            // Corresponding lane No.
        int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int					nSpeed;							  // speed km/h
        BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                bReserved[1020];                  // reserved
        EVENT_COMM_INFO     stCommInfo;                       // public info
    }DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_BACKING(traffic backing)corresponding data block description info
    typedef struct tagDEV_EVENT_IVS_TRAFFIC_BACKING_INFO
    {
        int                 nChannelID;                       // channel ID
        char                szName[128];                      // event name
        char                bReserved1[4];                    // byte alignment
        double              PTS;                              // Time stamp(ms)
        NET_TIME_EX         UTC;                              // Event occurred time
        int                 nEventID;                         // Event ID
        DH_MSG_OBJECT       stuObject;                        // Detected object
        DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
        int                 nLane;                            // Corresponding lane No.
        int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        int					nSpeed;							  // speed km/h
        BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                bReserved[1020];                  // reserved
        EVENT_COMM_INFO     stCommInfo;                       // public info
    }DEV_EVENT_IVS_TRAFFIC_BACKING_INFO;
    
    //Event type EVENT_IVS_AUDIO_ABNORMALDETECTION(audio abnormal detection)corresponding data block description info
    typedef struct tagDEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO
    {
        int                 nChannelID;                       // channel ID
        char                szName[128];                      // event name
        char                bReserved1[4];                    // byte alignment
        double              PTS;                              // Time stamp(ms)
        NET_TIME_EX         UTC;                              // Event occurred time
        int                 nEventID;                         // Event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
        int                 nDecibel;                         // decubel
        int                 nFrequency;                       // frequency
        BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                bReserved[1024];                  // reserved
    }DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(traffic run yellow light)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO
    {
        int					nChannelID;						  // channel ID
        char				szName[128];					  // event name
        char                bReserved1[4];                    // byte alignment
        double				PTS;							  // Time stamp(ms)
        NET_TIME_EX			UTC;				              // Event occurred time
        int					nEventID;			              // Event ID
        int					nLane;				              // Corresponding lane No.
        DH_MSG_OBJECT		stuObject;	              	      // have being detected object
        DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
        int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
        int					nSpeed;			              	  // speed km/h
        int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;					  // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                  // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        NET_TIME_EX         stYellowLightUTC;                 // begin time of yellow light
        unsigned int        nYellowLightPeriod;               // yellow light period time (s)
        DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
        BYTE                byRedLightMargin;                 // time interval(s)
        char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
        BYTE				bReserved[1024];	              // reserved
        EVENT_COMM_INFO     stCommInfo;                       // public info
    } DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO;
    
    //Event type  EVENT_IVS_LEAVEDETECTION(leave check)corresponding data block description info
    typedef struct tagDEV_EVENT_IVS_LEAVE_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// Event ID
        DH_MSG_OBJECT		stuObject;						// Detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        int                 nDetectRegionNum;				// Rule Detect Area Top Number
        DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //Rule Detect Area
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        BYTE				bReserved[1026];	            // reserved
    } DEV_EVENT_IVS_LEAVE_INFO;
    
    //Event type  EVENT_IVS_CLIMBDETECTION(climb check)corresponding data block description info
    typedef struct tagDEV_EVENT_IVS_CLIMB_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[4];                  // byte alignment
        double				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// event ID
        DH_MSG_OBJECT		stuObject;						// Detected object
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        int                 nDetectLineNum;                        // Acme amount of the rule detect zone
        DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // Rule detect zone
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        unsigned int        nOccurrenceCount;               // event trigger accumilated times
        BYTE				bReserved[1022];	            // reserved
    }DEV_EVENT_IVS_CLIMB_INFO;
    
    //EVENT_IVS_MULTISCENESWITCH Event Type EVENT_IVS_MULTISCENESWITCH (multi-scene change event) corresponding to the description of the data block
    typedef struct tagDEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO
    {
        int					nChannelID;						// (Channel number)
        char				szName[128];					// (Event name)
        char                bReserved1[4];                  //
        double				PTS;							// (Timestamp (in milliseconds))
        NET_TIME_EX			UTC;							// (Time for the event occurred )
        int					nEventID;						// (Event ID)
        BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
        BYTE				bReserved[1027];	            // (Reserved bytes)
    } DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(parking on yellow)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO
    {
        int					nChannelID;						// channel ID
        char				szName[128];					// event name
        char                bReserved1[8];                  // byte alignment
        DWORD				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// Event ID
        int					nLane;							// Corresponding lane No.
        DH_MSG_OBJECT		stuObject;						// Detected object
        DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        
        int					nInterval1;						// the first and second time interval(s)
        int					nInterval2;						// 3rd and 2nd delay time, unit is second
        int					nFollowTime;					// follow time,if a car and a car before entering the pornographic websites,is less than this value,just as with car to enter, to enter the case if the parkingis not illegal
        
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        BYTE				bReserved[1024];	            // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(parking space parking)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO
    {
        int					nChannelID;						// channel ID
        char                szName[DH_EVENT_NAME_LEN];      // event name
        char                bReserved1[8];                  // byte alignment
        DWORD				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// Event ID
        int					nLane;							// Corresponding lane No.
        DH_MSG_OBJECT		stuObject;						// Detected object
        DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        
        int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        BYTE				bReserved[1024];	            // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(parking space no parking)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO
    {
        int					nChannelID;						// channel ID
        char                szName[DH_EVENT_NAME_LEN];      // event name
        char                bReserved1[8];                  // byte alignment
        DWORD				PTS;							// Time stamp(ms)
        NET_TIME_EX			UTC;							// Event occurred time
        int					nEventID;						// Event ID
        int					nLane;							// Corresponding lane No.
        DH_MSG_OBJECT		stuObject;						// Detected object
        DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        
        int                 nSequence;                       // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                byReserved[2];
        BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
        BYTE				bReserved[1024];	            // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO;
    
    // EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE Corresponding data block description
    typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO
    {
        int					nChannelID;						// ?¡§Channel number??
        char                szName[DH_EVENT_NAME_LEN];      // ?¡§Event name??
        DWORD				PTS;							// ?¡§Timestamp (in milliseconds)??
        NET_TIME_EX			UTC;							// ?¡§The time of events??
        int					nEventID;						// (Event ID)
        int					nLane;							// (Corresponding lane number)
        DH_MSG_OBJECT		stuObject;						// ( object detected)
        DH_MSG_OBJECT       stuVehicle;                     // (Car Body Information)
        DH_EVENT_FILE_INFO  stuFileInfo;                    // ?¡§Event corresponding to file information??
        
        int                 nSequence;                      // ?¡§Means??capture serial number, such as 3,2,1,1 capture end, 0 indicates abnormal end??
        BYTE                byEventAction;                  // ?¡§Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends;...??
        BYTE				byImageIndex;					// (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
        BYTE                byReserved1[2];
        DWORD               dwSnapFlagMask;	                // (Grab flag (bit), see specific NET_RESERVED_COMMON)
        DH_RESOLUTION_INFO  stuResolution;                  // (the resolution of relative picture)
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // (Transportation Vehicle Information)
        BYTE				byReserved[1024];	            // (Reserved bytes)
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_PEDESTRAIN(pedestrain)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAIN_INFO
    {
        int                 nChannelID;                     // channel ID
        char                szName[DH_EVENT_NAME_LEN];      // event name
        char                bReserved1[8];                  // byte alignment
        DWORD               PTS;                            // Time stamp(ms)
        NET_TIME_EX         UTC;                            // Event occurred time
        int                 nEventID;                       // Event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                bReserved2[2];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nLane;                          // Corresponding lane No.
        DH_MSG_OBJECT       stuObject;                      // Detected object
        BYTE                bReserved[1024];                // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_THROW(throw)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_THROW_INFO
    {
        int                 nChannelID;                     // channel ID
        char                szName[DH_EVENT_NAME_LEN];      // event name
        char                bReserved1[8];                  // byte alignment
        DWORD               PTS;                            // Time stamp(ms)
        NET_TIME_EX         UTC;                            // Event occurred time
        int                 nEventID;                       // Event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                bReserved2[2];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nLane;                          // Corresponding lane No.
        DH_MSG_OBJECT       stuObject;                      // Detected object
        BYTE                bReserved[1024];                // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_THROW_INFO;
    
    //Event type  EVENT_IVS_TRAFFIC_IDLE(idle)corresponding data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_IDLE_INFO
    {
        int                 nChannelID;                     // channel ID
        char                szName[DH_EVENT_NAME_LEN];      // event name
        char                bReserved1[8];                  // byte alignment
        DWORD               PTS;                            // Time stamp(ms)
        NET_TIME_EX         UTC;                            // Event occurred time
        int                 nEventID;                       // Event ID
        DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
        DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
        DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout"
        BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
        BYTE                bReserved2[2];
        BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
        int                 nLane;                          // Corresponding lane No.
        BYTE                bReserved[1024];                // reserved
        EVENT_COMM_INFO     stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_IDLE_INFO;
    
#define MAX_DRIVING_DIR_NUM          16                             //  lane direction max quantity
    
    // direction
    typedef enum tagNET_FLOWSTAT_DIRECTION
    {
        DRIVING_DIR_UNKNOW = 0 ,		// (Before compatible)
        DRIVING_DIR_APPROACH ,			// (Uplink, the vehicle away from the device deployment point is getting closer)
        DRIVING_DIR_LEAVE ,				// (Go down, that the vehicle is farther away from  equipment deployment point)
    }NET_FLOWSTAT_DIRECTION;
    
    // road direction
    typedef enum tagNET_ROAD_DIRECTION
    {
        ROAD_DIR_UNKNOW,             // unknown
        ROAD_DIR_TURNLEFT,           // left turn
        ROAD_DIR_TURNRIGHT,          // right turn
        ROAD_DIR_STRAIGHT,           // direction
        ROAD_DIR_UTURU,              // u turn
        ROAD_DIR_NUM,
    }NET_ROAD_DIRECTION;
    
    //Vehicle flow statistics lane direction information
    typedef struct tagNET_TRAFFIC_FLOWSTAT_INFO_DIR
    {
        NET_FLOWSTAT_DIRECTION		emDrivingDir;							//(Driving direction)
        char						szUpGoing[FLOWSTAT_ADDR_NAME];			//(Uplink locations)
        char						szDownGoing[FLOWSTAT_ADDR_NAME];		//(Go down location)
        BYTE						reserved[32];							//(Reserved bytes)
        
    }NET_TRAFFIC_FLOWSTAT_INFO_DIR;
    
    //road jam status
    typedef enum tagNET_TRAFFIC_JAM_STATUS
    {
        JAM_STATUS_UNKNOW  =0 ,  // unknown
        JAM_STATUS_CLEAR      ,  //clear
        JAM_STATUS_JAMMED     ,  //jammed
    }NET_TRAFFIC_JAM_STATUS;
    
    typedef struct tagNET_TRAFFIC_FLOW_STATE
    {
        int								nLane;				// (Lane number)
        DWORD							dwState;			// (State value)
        // (1 - heavy traffic)
        // (2-heavy traffic recovery)
        // (3-normal)
        // (4 - Flow is too  little)
        // (5-Traffic too low recovery)
        DWORD							dwFlow;				// (Flow value, units: vehicles)
        DWORD							dwPeriod;			// (Corresponding statistical time of the flow value )
        NET_TRAFFIC_FLOWSTAT_INFO_DIR	stTrafficFlowDir;	// (Lane direction information)
        int					            nVehicles;			// (Total number of passing vehicles)
        float				            fAverageSpeed;		// (Average speed, unit km / h)
        float				            fAverageLength;		// (The average vehicle length, unit meters)
        float				            fTimeOccupyRatio;	// (Share of the time , i.e., The ratio of the sum time for the vehicle passing the cross-section  in  the unit  time and per unit time )
        float				            fSpaceOccupyRatio;	// (Share of the space ,is the result that the average driving distance intervals vehicle is divided the sum of the length of the vehicle measured by the percentage
        float			            	fSpaceHeadway;		// (Headway, the distance between adjacent vehicles in m / vehicle)
        float				            fTimeHeadway;		// (Headway in seconds / vehicle)
        float				            fDensity;			// (Vehicle density, the number of vehicles per kilometer, unit vehicles / km)
        int					            nOverSpeedVehicles;	// (The number of Speeding vehicles)
        int					            nUnderSpeedVehicles;// (The number of low speeding vehicles)
        int				            	nLargeVehicles;		// (Carts traffic (9 m <car length <12 m), vehicle / unit time)
        int				            	nMediumVehicles;	// (Medium car Traffic 6 m ??<car length <9 meters), vehicle / unit time
        int				            	nSmallVehicles;		// (Car Traffic 4 m ??<car length <6 meters), vehicle / unit time
        int				            	nMotoVehicles;		// (Motorized traffic (mini-car, car length <4 m), vehicle / unit time??
        int				            	nLongVehicles;		// (long traffic (car length> = 12 m), vehicle / unit time??
        int                             nVolume;            // (Traffic, vehicles / unit time, the number of vehicles which pass through the lane, the road and other vehicles, caculated in one hour)
        int                             nFlowRate;          // (Flow rate of the car, Vehicles / hour, equivalent hours for Vehicle through the lane, a section or a section of the road)
        int                             nBackOfQueue;       // (Queue length, unit: m, distance from the signalized intersection stop line between the upstream end of the line vehicle)
        int                             nTravelTime;        // (Travel time, unit: second, a road vehicle used by a certain time. Including all parking delays)
        int                             nDelay;             // (Delay unit: seconds, extra travel time for the driver, passenger or pedestrian spend)
        BYTE                            byDirection[MAX_DRIVING_DIR_NUM]; // lane direction??see NET_ROAD_DIRECTION
        BYTE                            byDirectionNum;                 // lane direction quantity
        BYTE                            reserved1[3];       // text align
        NET_TRAFFIC_JAM_STATUS          emJamState;         // road jam status
        BYTE							reserved[852];		// (Reserved bytes)
    }NET_TRAFFIC_FLOW_STATE;
    
    // EVENT_IVS_TRAFFIC_FLOWSTATE (Corresponding data block description)
    typedef struct tagDEV_EVENT_TRAFFIC_FLOW_STATE
    {
        int                 nChannelID;                     // (Channel number)
        char                szName[DH_EVENT_NAME_LEN];      // (Event name)
        char                bReserved1[8];                  // (Byte alignment)
        DWORD               PTS;                            // (Timestamp (in milliseconds))
        NET_TIME_EX         UTC;                            // (Time for the event occurred)
        int                 nEventID;                       // (Event ID)
        int					nSequence;						// (No.)
        int					nStateNum;						// (the number of traffic state)
        NET_TRAFFIC_FLOW_STATE stuStates[DH_MAX_LANE_NUM];	// (Flow state, each lane corresponding to an element in the array)
        BYTE                bReserved[1024];                // (Reserved bytes)
    }DEV_EVENT_TRAFFIC_FLOW_STATE;
    
    // EVENT_IVS_VIDEOSTATIC(Corresponding to data block description)
    typedef struct tagDEV_EVENT_ALARM_VIDEOSTATIC_INFO
    {
        int                 nChannelID;                                 // Channel number
        char                szName[DH_EVENT_NAME_LEN];                  // Event name
        char                bReserved1[8];                              // Byte alignment
        DWORD               PTS;                                        // Timestamp (in milliseconds)
        NET_TIME_EX         UTC;                                        // Time for the event occurred
        int                 nEventID;                                   // Event ID
        EM_ALARM_VIDEO_STATIC_MODE  emMode;                             // the mode
        BYTE                bEventAction;                               // Even action
        BYTE                bReserved[1027];                            // Reserved bytes
    }DEV_EVENT_ALARM_VIDEOSTATIC_INFO;
    
    // EVENT_IVS_VIDEOTIMINGCorresponding to data block description)
    typedef struct tagDEV_EVENT_ALARM_VIDEOTIMING_INFO
    {
        int                 nChannelID;                                 // Channel number
        char                szName[DH_EVENT_NAME_LEN];                  // Event name
        char                bReserved1[8];                              // Byte alignment
        DWORD               PTS;                                        // Timestamp (in milliseconds)
        NET_TIME_EX         UTC;                                        // Time for the event occurred
        int                 nEventID;                                   // Event ID
        BYTE                bEventAction;                               // the mode
        BYTE                bReserved[1027];                            // Reserved bytes
    }DEV_EVENT_ALARM_VIDEOTIMING_INFO;
    
    // Media file search criteria
    typedef enum __EM_FILE_QUERY_TYPE
    {
        DH_FILE_QUERY_TRAFFICCAR,							// Vehicle information
        DH_FILE_QUERY_ATM,									// ATM information
        DH_FILE_QUERY_ATMTXN,								// ATM transaction information
        DH_FILE_QUERY_FACE,  								// Face info
        DH_FILE_QUERY_FILE,                                 // file info, corresponding to NET_IN_MEDIA_QUERY_FILE and NET_OUT_MEDIAFILE_FILE
        DH_FILE_QUERY_TRAFFICCAR_EX,						// Transportation vehicle information, expand DH_FILE_QUERY_TRAFFICCAR, support more fields
        DH_FILE_QUERY_FACE_DETECTION,                       // face recognition event info MEDIAFILE_FACE_DETECTION_PARAM  and MEDIAFILE_FACE_DETECTION_INFO
    } EM_FILE_QUERY_TYPE;
    
    typedef enum _EM_RECORD_SNAP_FLAG_TYPE
    {
        FLAG_TYPE_TIMING ,                  //Schele
        FLAG_TYPE_MANUAL ,                  //Manual
        FLAG_TYPE_MARKED ,                  //Important
        FLAG_TYPE_EVENT  ,                  //Event
        FLAG_TYPE_MOSAIC ,                  //Combined
        FLAG_TYPE_CUTOUT ,                  //Cut
        FLAG_TYPE_LEAVE_WORD ,              //Message
        FLAG_TYPE_TALKBACK_LOCAL_SIDE ,     //Talk Local
        FLAG_TYPE_TALKBACK_REMOTE_SIDE ,    //Talk Remote
        FLAG_TYPE_SYNOPSIS_VIDEO ,          //Compressed Video
        FLAG_TYPE_ORIGINAL_VIDEO ,          //Original Video
        FLAG_TYPE_PRE_ORIGINAL_VIDEO ,      //Processed
        FLAG_TYPE_BLACK_PLATE ,             //Blacklist Picture
        FLAG_TYPE_ORIGINAL_PIC ,            //Original Picture
        FLAG_TYPE_CARD,                     //card no. record
        FLAG_TYPE_MAX = 128,
    }EM_RECORD_SNAP_FLAG_TYPE;
    
    // ATM trsaction type
    typedef enum
    {
        ATM_TRADE_ALL,                      // all types
        ATM_TRADE_ENQUIRY,                  // search
        ATM_TRADE_WITHDRAW,                 // withdraw
        ATM_TRADE_MODIFY_PASSWORD,          // change password
        ATM_TRADE_TRANSFER,                 // transfer
        ATM_TRADE_DEPOSIT,                  // deposit
        ATM_TRADE_CARDLESS_ENQUIRY,         // search without card
        ATM_TRADE_CARDLESS_DEPOSIT,         // deposit without card
        ATM_TRADE_OTHER,                    // other
    }EM_ATM_TRADE_TYPE;
    
    // card no. record info
    typedef struct
    {
        DWORD               dwSize;
        int                 nType;          // type, 0-Card, 1-Field
        char                szCardNo[DH_MAX_CARD_INFO_LEN]; // card no.
        EM_ATM_TRADE_TYPE   emTradeType;    // transaction type
        char                szAmount[DH_COMMON_STRING_64]; // transaction amount, nullstring means no limit amount
        int                 nError;         // error code, 0-all errors, 1-retain cash, 2-retain card
        int                 nFieldCount;    // domain quantity, by domain search is valid
        char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256];   // domain info, by domain search is valid
    }NET_RECORD_CARD_INFO;
    
#define MAX_IVS_EVENT_NUM    256
    
    // record info, corresponde to CLIENT_FindFileEx, search condition
    // support paths search in curent
    typedef struct
    {
        DWORD               dwSize;                 // size
        char*               szDirs;                 // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
        int					nMediaType;		        // file info,0:any type,1:search jpg image,2:search dav
        int                 nChannelID;             // Channel start from 0??-1 means search all channel
        NET_TIME            stuStartTime;           // start time
        NET_TIME            stuEndTime;             // end time
        int                 nEventLists[MAX_IVS_EVENT_NUM]; // Event type list, see intelligent analysis event type
        int                 nEventCount;            // event total
        BYTE                byVideoStream;          // video stream 0-unknown  1-main 2-sub 1 3-sub 2 4- sub 3
        BYTE                bReserved[3];           // aligh text
        EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // Record or snapshot file mark, not set mark to search all files
        int                 nFalgCount;             // total mark
        NET_RECORD_CARD_INFO stuCardInfo;           // card no. record info, emFalgLists including card no. video is valid
    }NET_IN_MEDIA_QUERY_FILE;
    
    // record info, corresponde to CLIENT_FindFileEx, search result
    typedef struct
    {
        DWORD               dwSize;                 // size
        int					nChannelID;				// channel ID,from 0,-1 means search all
        NET_TIME			stuStartTime;			// start time
        NET_TIME			stuEndTime;				// end time
        unsigned int		nFileSize;				// size of file
        BYTE				byFileType;				// file type 1:jpg, 2: dav
        BYTE                byDriveNo;              // drive no.
        BYTE                byPartition;            // zone no.
        BYTE                byVideoStream;          // video stream 0-unknown  1-main 2-sub 1 3-sub 4-sub
        unsigned int        nCluster;               // cluster
        char				szFilePath[MAX_PATH];	// FilePath
        int                 nEventLists[MAX_IVS_EVENT_NUM]; // Link event list,see event intelligent analysis event type
        int                 nEventCount;            //event total
        EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // record or snapshot file mark
        int                 nFalgCount;             //mark total
        unsigned int        nDriveNo;               // disk driver number
    }NET_OUT_MEDIA_QUERY_FILE;
    //The corresponding search criteria of  DH_MEDIA_QUERY_TRAFFICCAR
    typedef struct
    {
        int					nChannelID;						// The channel number begins with 0. -1 is to search information of all channels .
        NET_TIME			StartTime;						// Start time
        NET_TIME			EndTime;						// End time
        int					nMediaType;						// File type:0=search any type.1=search jpg file
        int					nEventType;						// Event type,please refer to Intelligent Analytics Event Type. 0 means search any event.
        char				szPlateNumber[32];				// Vehicle plate. "\0" is to search any plate number.
        int					nSpeedUpperLimit;				// The searched vehicle speed range. Max speed unit is km/h
        int					nSpeedLowerLimit;				// The searched vehicle speed range. Min speed unit is km/h
        BOOL				bSpeedLimit;					// Search according to the speed or not.  TRUE: search according to the speed.nSpeedUpperLimit and nSpeedLowerLimit is valid.
        DWORD				dwBreakingRule;					// Illegal type:
        // When event type is EVENT_IVS_TRAFFICGATE
        //		bit1: Retrograde;   bit2: Overline;
        //		bit3: Overspend; 	bit4:Under speed;
        //		bit5: RunRedLight;
        // When event type is EVENT_IVS_TRAFFICJUNCTION
        //		bit1: RunRedLight;  bit2: WrongLan;
        //		bit3: Retrograde; 	bit4:UTurn;
        //	    bit5: Overline;
        char                szPlateType[32];                // plate type,"Unknown" ,"Normal" ,"Yellow" ,"DoubleYellow" ,"Police" "Armed"
        char                szPlateColor[16];               // plate color, "Blue","Yellow", "White","Black"
        char				szVehicleColor[16];		        // vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
        char				szVehicleSize[16];		        // vehicle type:"Light-duty";"Medium"; "Oversize"
        int                 nGroupID;                       // id of event group(it works when >= 0)
        short               byLane;                         // lane number(it works when >= 0)
        BYTE				byFileFlag;						// file flag, 0xFF-use nFileFlagEx, 0-all record, 1-timing file, 2-manual, 3-event, 4-important, 5-mosaic
        BYTE				byRandomAccess;                 // The need for random jumps in the query process, 0 - no need 1 - need
        int					nFileFlagEx;					// file flag, bit0-timing, bit1-manual, bit2-event, bit3-important, bit4-mosaic, 0xFFFFFFFF-all
        int					nDirection;				        // direction(to the direction of car)	0-north 1-northeast 2-east 3-southeast 4-south 5-southwest 6-west 7-northwest 8-unknown -1-all directions
        char*               szDirs;                         // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
        int*                pEventTypes;                    // Check the event type to be an array of pointers, event type, see "intelligent analysis event type", if the query is NULL considered all events (buffer required to apply by the user)
        int                 nEventTypeNum;                  // Event Type array size
        char*				pszDeviceAddress;               // Device address, NULL indicates that the field does not work
        char*				pszMachineAddress;				// Machine deployment locations, NULL indicates that the field does not work
        char*				pszVehicleSign;					// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ... NULL indicates that the field does not work
        int					bReserved[32];					// Reserved field for future extension.
    } MEDIA_QUERY_TRAFFICCAR_PARAM;
    
    
    // The media file information searched by DH_MEDIA_QUERY_TRAFFICCAR
    typedef struct
    {
        unsigned int		ch;						// Channel number
        char				szFilePath[128];		// File path
        unsigned int		size;					// File length
        NET_TIME			starttime;				// Start time
        NET_TIME			endtime;				// End time
        unsigned int		nWorkDirSN;				// Working directory serial number
        BYTE				nFileType;				// File type.  1:jpg file
        BYTE                bHint;					// File location index
        BYTE                bDriveNo;               // drive number
        BYTE                bReserved2;
        unsigned int        nCluster;               // cluster number
        BYTE				byPictureType;			// flags
        BYTE                bReserved[3];           // Reserved field for future extension.
        
        //The following contents is the vehicle information
        char				szPlateNumber[32];		// Vehicle plate number
        char				szPlateType[32];		// Plate type: "Unknown" =Unknown; "Normal"=Blue and black plate. "Yellow"=Yellow plate. "DoubleYellow"=Double-layer yellow plate
        // "Police"=Police plate ; "Armed"= =Military police plate; "Military"=Army plate; "DoubleMilitary"=Army double-layer
        // "SAR" =HK SAR or Macao SAR plate; "Trainning" =rehearsal plate; "Personal"=Personal plate; "Agri"=Agricultural plate
        // "Embassy"=Embassy plate; "Moto"=Moto plate ; "Tractor"=Tractor plate; "Other"=Other plate
        char				szPlateColor[16];		// Plate color:"Blue","Yellow", "White","Black"
        char				szVehicleColor[16];		// Vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
        int					nSpeed;					// Speed. The unit is Km/H
        int					nEventsNum;				// Activation event amount
        int					nEvents[32];			// Activation event list. The number refers to the corresponding event. Please refer to Intelligent Analytics Event Type.
        DWORD				dwBreakingRule;			// Detailed offense type subnet mask. The first bit means redlight offense, the second bit is illegal straight/left-turn/right-turn driving.
        // The third bit is the wrong way driving; the four bit is illegal U-turn. Otherwise default value is intersection accident.
        char				szVehicleSize[16];		// Vehicle type:"Light-duty"=small;"Medium"=medium; "Oversize"=large
        char				szChannelName[DH_CHAN_NAME_LEN];// Local or remote channel name
        char				szMachineName[DH_MAX_NAME_LEN];	// Local or remote device name
        int					nSpeedUpperLimit;	    // up limit of speed, km/h
        int					nSpeedLowerLimit;		// lower limit of speed km/h
        int                 nGroupID;               // id of event group
        BYTE                byCountInGroup;         // total count of the event group
        BYTE                byIndexInGroup;         // the index of this event
        BYTE                byLane;                 // lane number
        BYTE                bReserved1[21];			// reserved
        NET_TIME            stSnapTime;             // snap time
        int					nDirection;				// direction,MEDIA_QUERY_TRAFFICCAR_PARAM
        char                szMachineAddress[MAX_PATH]; // machine address
    } MEDIAFILE_TRAFFICCAR_INFO, *LPMEDIAFILE_TRAFFICCAR_INFO;
    
    // DH_MEDIA_QUERY_TRAFFICCAR_EX Corresponding query
    typedef struct tagMEDIA_QUERY_TRAFFICCAR_PARAM_EX
    {
        DWORD				dwSize;
        MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;	        	// The basic query parameters
    } MEDIA_QUERY_TRAFFICCAR_PARAM_EX;
    
    // DH_MEDIA_QUERY_TRAFFICCAR_EX Check out the file information
    typedef struct tagMEDIAFILE_TRAFFICCAR_INFO_EX
    {
        DWORD				dwSize;
        MEDIAFILE_TRAFFICCAR_INFO stuInfo;			        // Basic Information
        char				szDeviceAddr[DH_COMMON_STRING_256];	// Device Address
        char				szVehicleSign[DH_COMMON_STRING_32];	// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ..
        char                szCustomParkNo[DH_COMMON_STRING_64];    // self defined parking space number?¡§for parking??
    } MEDIAFILE_TRAFFICCAR_INFO_EX;
    
    // FINDNEXT Find input parameter
    typedef struct __NET_FINDNEXT_RESERVED
    {
        DWORD               dwSize;                 // Structure size
        
        unsigned int        nBeginNumber;           // Search begin number, start from begin number, 0<=beginNumber<= totalCount-1
    }NET_FINDNEXT_RESERVED;
    
    // Enquiry jump condition
    typedef struct __NET_FINDING_JUMP_OPTION_INFO
    {
        DWORD           dwSize;
        int             nOffset;                            // Query results offset relative to the first query results position offset current query
    }NET_FINDING_JUMP_OPTION_INFO;
    
    // DH_FILE_QUERY_FACE Corresponding face recognition service search parameter
    typedef struct __MEDIAFILE_FACERECOGNITION_PARAM
    {
        DWORD               dwSize;                 // Structure size
        
        // Search filter criteria
        NET_TIME			stStartTime;			       // start time
        NET_TIME			stEndTime;				       // closing time
        char                szMachineAddress[MAX_PATH];    // Place to support fuzzy matching
        int                 nAlarmType;                    // To query the type of alarm, see EM_FACERECOGNITION_ALARM_TYPE
        BOOL                abPersonInfo;                   // staff info is valid or not
        FACERECOGNITION_PERSON_INFO stPersonInfo;           // staff info
        int                 nChannelId;                     // channel no.
        int                 nGroupIdNum;                    // staff group
        char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID
    }MEDIAFILE_FACERECOGNITION_PARAM;
    
    typedef struct  tagDH_PIC_INFO_EX
    {
        DWORD                dwSize;                        // structure size
        DWORD                dwFileLenth;                   // file size,unit:bite
        char                 szFilePath[MAX_PATH];          // file path
    }DH_PIC_INFO_EX;
    
    typedef struct __NET_CANDIDAT_PIC_PATHS
    {
        DWORD                dwSize;                        // structure size
        int                  nFileCount;                    // actual file amount
        DH_PIC_INFO_EX       stFiles[DH_MAX_PERSON_IMAGE_NUM];// file information
    }NET_CANDIDAT_PIC_PATHS;
    
    // corresponding facial recognition service  DH_FILE_QUERY_FACE FINDNEXT search returned parameter
    typedef struct __MEDIAFILE_FACERECOGNITION_INFO
    {
        DWORD               dwSize;                                   // Structure size
        BOOL                bGlobalScenePic;                          // The existence panorama
        DH_PIC_INFO_EX      stGlobalScenePic;                         // Panoramic image file path
        DH_MSG_OBJECT		stuObject;						          // the target face object information
        DH_PIC_INFO_EX      stObjectPic;                              // the target face file path
        int                 nCandidateNum;                            // Face Matching the current number of candidates
        CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM];      // Face candidates to match this informatio
        NET_CANDIDAT_PIC_PATHS stuCandidatesPic[DH_MAX_CANDIDATE_NUM];// The current face matching candidates to the image file path
        NET_TIME            stTime;                                   // time for an alarm
        char                szAddress[MAX_PATH];                      // Place for an alarm
        int                 nChannelId;                               // channel no.
    }MEDIAFILE_FACERECOGNITION_INFO;
    
    typedef enum __EM_FACEPIC_TYPE
    {
        NET_FACEPIC_TYPE_UNKOWN,            // unknown type
        NET_FACEPIC_TYPE_GLOBAL_SENCE,      // face full size picture
        NET_FACEPIC_TYPE_SMALL,             // face small pictrure
    }EM_FACEPIC_TYPE;
    
#define  NET_MAX_FRAMESEQUENCE_NUM     2
#define  NET_MAX_TIMESTAMP_NUM         2
    
    typedef struct __MEDIAFILE_FACE_DETECTION_DETAIL_PARAM
    {
        DWORD               dwSize;
        DWORD               dwObjectId;                     // object ID
        DWORD               dwFrameSequence;                // frame no.
        NET_TIME_EX         stTime;                         // time
    }MEDIAFILE_FACE_DETECTION_DETAIL_PARAM;
    
    // DH_FILE_QUERY_FACE_DETECTION corresponding face recognition service search parameter
    typedef struct __MEDIAFILE_FACE_DETECTION_PARAM
    {
        DWORD               dwSize;                         //  structure size
        
        // search filter
        int                 nChannelID;                     // channel no.
        NET_TIME            stuStartTime;                   // start time
        NET_TIME            stuEndTime;                     // end time
        EM_FACEPIC_TYPE     emPicType;                      // picture type??see  EM_FACEPIC_TYPE
        BOOL                bDetailEnable;                  // if has detailed info
        MEDIAFILE_FACE_DETECTION_DETAIL_PARAM stuDetail;    // parameter detailed info
        
    }MEDIAFILE_FACE_DETECTION_PARAM;
    
    // DH_FILE_QUERY_FACE_DETECTIONcorresponding face recognition service FINDNEXT search return parameter
    typedef struct __MEDIAFILE_FACE_DETECTION_INFO
    {
        DWORD               dwSize;                                     //  structure size
        
        unsigned int        ch;                                         // channel no.
        char                szFilePath[128];                            // file path
        unsigned int        size;                                       // file length
        NET_TIME            starttime;                                  // start time
        NET_TIME            endtime;                                    // end time
        unsigned int        nWorkDirSN;                                 // working directory no.
        BYTE                nFileType;                                  // file type  1??jpg picture
        BYTE                bHint;                                      // file positioning index
        BYTE                bDriveNo;                                   // disk no.
        BYTE                byPictureType;                              // picture type, 0-normal, 1-combined, 2-cut
        unsigned int        nCluster;                                   // cluster no.
        
        EM_FACEPIC_TYPE     emPicType;                                  // picture type??see EM_FACE_PIC_TYPE
        DWORD               dwObjectId;                                 // object ID
        DWORD               dwFrameSequence[NET_MAX_FRAMESEQUENCE_NUM]; // frame no.,group has two elements??one means small picture??two means large picture
        int                 nFrameSequenceNum;                          // frame no.quantity
        NET_TIME_EX         stTimes[NET_MAX_TIMESTAMP_NUM];             // time??group has two elements??one means small picture??two means large picture
        int                 nTimeStampNum;
        int                 nPicIndex;                                  // Picture number in the cluster
        // For packaged multiple images in the same cluster,provides indexed mode to position pictures
    }MEDIAFILE_FACE_DETECTION_INFO;
    
    // query video synopsis param
    typedef struct __MEDIA_QUERY_VIDEOSYNOPSIS_PARAM
    {
        DWORD               dwSize;
        NET_TIME			StartTime;						// start time
        NET_TIME			EndTime;						// end time
        int					nMediaType;						// file type,0:arbitrariness,1:image,2:record
        int                 nQueryType;                     // query type,1:source video file 2:reduce video file
    }MEDIA_QUERY_VIDEOSYNOPSIS_PARAM;
    
    typedef struct __MEDIAFILE_VIDEOSYNOPSIS_INFO
    {
        char				szFilePath[128];		// file path
        unsigned int		size;					// file size
        NET_TIME			starttime;				// start time
        NET_TIME			endtime;				// end time
        unsigned int		nWorkDirSN;				// worl dir serial number
        BYTE				nFileType;				// file type  1:jpg
        BYTE                bHint;					// index file location
        BYTE                bDriveNo;               // drive no.
        BYTE                bReserved2;
        unsigned int        nCluster;               // cluster
        BYTE				byPictureType;			// picture type, 0-normal, 1-synthesis, 2-cutout
        BYTE                bReserved[3];           // reserved
        
        // video source file info
        int                nTaskID;                 // task ID
        char               szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; //video synopsis state
        int                nProgress;               // sorresponding state
        int                nObjectNum;              // object num
        
        // video synopsis file info
        int                nDurationTime;          // duration time (s)
    }MEDIAFILE_VIDEOSYNOPSIS_INFO;
    // correlate with NET_IN_SNAPSHOT, flash control,array,each element corresponding to a flash light configuration
    typedef struct __NET_FLASHCONTROL
    {
        DWORD				dwSize;					// struct size
        int					nMode;					// work mode 0-no flash,1-always flash,2-auto flash
    }NET_FLASHCONTROL;
    
    // Capture client type
    typedef enum tagSNAP_CLIENT_TYPE
    {
        SNAP_CLIENT_TYPE_COMMON,               // Corresponding to "Common" type, the default type
        SNAP_CLIENT_TYPE_PARKINGSPACE,         // Correspondence "ParkingSpace" type, parking
    }SNAP_CLIENT_TYPE;
    
#define DH_MAX_USER_DEFINE_INFO        1024
    
    // when nTriggerType==2, client snap info
    typedef struct _NET_CLIENT_SNAP_INFO
    {
        DWORD				dwSize;					// struct info
        unsigned int        nFrameSequence;         // frame sequence
        double              PTS;                    // pts,64 bit
        char				szUserDefinedInfo[DH_MAX_USER_DEFINE_INFO];	// String, custom client, "\ 0" at the end
        SNAP_CLIENT_TYPE    emSNAP_CLIENT_TYPE;     // Client Type
        DWORD               dwRetCardNumber;        // card amount
        EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // card information
    }NET_CLIENT_SNAP_INFO;
    
    // CLIENT_TrafficSnapByNetwork's input param
    typedef struct __NET_IN_SNAPSHOT
    {
        DWORD				dwSize;					// struct size
        int					nTriggerType;			// trigger type	0-unknown 1-zhongmeng net trigger
        int					nLaneID;				// lane id
        int					nGroupID;				// group id
        int					nGrabTimes;				// picture number
        int					nStartPicNum;			// the start picture id
        int					nDirection;				// road direction 0-north 1-east north 2-east 3-east south 4-south 5-west south 6-west 7-west north 8-unknown
        int					nGrabWaitTime;			// pGrabWaitTime group member number
        DWORD*				pGrabWaitTime;			// interval time between two picture
        int					nLowerSpeedLimit;		// lower speed limit, km/h
        int					nUpperSpeedLimit;		// upper speed limit, km/h
        int					nSpeed;					// speed, km/h
        int					nViolationNo;			// violation number 0-not transgress
        // 1-black shit
        // 2-over speed not over 50%
        // 3-over speed between 50% and 100%
        // 4-over speed over 100%
        // 5-retrograde
        // 6-run red
        // 7-under speed
        // 8-no passing,wrong route
        int					nRedLightTime;			// red light time,s
        int					nFlashControl;			// pFlashControl group member number
        NET_FLASHCONTROL*   pFlashControl;			// flash control
        DWORD				dwUser;					// user data
        NET_CLIENT_SNAP_INFO stClientInfo;          // the incoming snap parameter
    }NET_IN_SNAPSHOT;
    
    // CLIENT_TrafficSnapByNetwork's output param
    typedef struct __NET_OUT_SNAPSHOT
    {
        DWORD				dwSize;					// structure size
    }NET_OUT_SNAPSHOT;
    
    // interface(CLIENT_TrafficForceLightState)input parameter
    typedef struct __NET_IN_FORCELIGHTSTATE
    {
        DWORD				dwSize;					// struct size
        unsigned int        nDirection;             // 0 bit:"Straight",1 bit:"TurnLeft",2 bit:"TurnRight",3 bit:"U-Turn"
    }NET_IN_FORCELIGHTSTATE;
    
    // interface (CLIENT_TrafficForceLightState)output parameter
    typedef struct __NET_OUT_FORCELIGHTSTATE
    {
        DWORD				dwSize;					// struct size
    }NET_OUT_FORCELIGHTSTATE;
    // CLIENT_StartTrafficFluxStat's callback function
    typedef int  (CALLBACK *fFluxStatDataCallBack)(LLONG lFluxStatHandle, DWORD dwEventType, void* pEventInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);
    
    // CLIENT_StartTrafficFluxStat's input param
    typedef struct __NET_IN_TRAFFICFLUXSTAT
    {
        DWORD				dwSize;					// structure size
        fFluxStatDataCallBack		cbData;			// callback function pointer
        LDWORD				dwUser;					// user data
    }NET_IN_TRAFFICFLUXSTAT;
    
    // CLIENT_StartTrafficFluxStat's output param
    typedef struct __NET_OUT_TRAFFICFLUXSTAT
    {
        DWORD				dwSize;					// structure size
    }NET_OUT_TRAFFICFLUXSTAT;
    
    // CLIENT_StartFindFluxStat's input param
    typedef struct __NET_IN_TRAFFICSTARTFINDSTAT
    {
        DWORD				dwSize;					// structure size
        NET_TIME			stStartTime;			// start time, temporarily
        NET_TIME			stEndTime;				// end time, temporarily
        int					nWaittime;				// the time to wait result
    }NET_IN_TRAFFICSTARTFINDSTAT;
    
    // CLIENT_StartFindFluxStat's output param
    typedef struct __NET_OUT_TRAFFICSTARTFINDSTAT
    {
        DWORD				dwSize;					// structure size
        DWORD               dwTotalCount;           // The total amount that matched current search criteria
    }NET_OUT_TRAFFICSTARTFINDSTAT;
    
    // CLIENT_DoFindFluxStat's input param
    typedef struct __NET_IN_TRAFFICDOFINDSTAT
    {
        DWORD				dwSize;					// structure size
        unsigned int		nCount;					// the number of flow Statistic for query
        int					nWaittime;				// the time to wait result
    }NET_IN_TRAFFICDOFINDSTAT;
    
    typedef struct
    {
        DWORD				dwSize;					// structure size
        
        int					nStatInfo;				// the number of statistic info
        DH_TRAFFICFLOWSTAT *pStatInfo;				// the statistic pointer
    }DH_TRAFFICFLOWSTAT_OUT;
    
    // CLIENT_DoFindFluxStat's out param
    typedef struct __NET_OUT_TRAFFICDOFINDSTAT
    {
        DWORD				dwSize;					// structure size
        
        DH_TRAFFICFLOWSTAT_OUT stStatInfo;			// the statistic pointer
    }NET_OUT_TRAFFICDOFINDSTAT;
    
    // interface(CLIENT_StartFindNumberStat)'s input param
    typedef struct __NET_IN_FINDNUMBERSTAT
    {
        DWORD				dwSize;					// size
        int                 nChannelID;             // channel ID
        NET_TIME			stStartTime;			// start time
        NET_TIME			stEndTime;				// end time
        int                 nGranularityType;       // granularity type, 0:minute,1:hour,2:day,3:week,4:month,5:quarter,6:year
        int					nWaittime;				// wait time
    }NET_IN_FINDNUMBERSTAT;
    
    // CLIENT_StartFindNumberStat's output param
    typedef struct __NET_OUT_FINDNUMBERSTAT
    {
        DWORD				dwSize;
        DWORD               dwTotalCount;           // total count
    }NET_OUT_FINDNUMBERSTAT;
    
    // CLIENT_DoFindNumberStat's input param
    typedef struct __NET_IN_DOFINDNUMBERSTAT
    {
        DWORD				dwSize;
        unsigned int        nBeginNumber;           // [0, totalCount-1]
        unsigned int		nCount;					// count
        int					nWaittime;				// wait time
    }NET_IN_DOFINDNUMBERSTAT;
    
    typedef struct __DH_NUMBERSTAT
    {
        DWORD    dwSize;
        int      nChannelID;                           // channel id
        char     szRuleName[DH_CHAN_NAME_LEN];         // rule name
        NET_TIME stuStartTime;                         // start time
        NET_TIME stuEndTime;                           // end time
        int      nEnteredSubTotal;                     // entered total
        int      nExitedSubtotal;                      // entered total
        int      nAvgInside;                           // average number inside
        int      nMaxInside;                           // max number inside
        int      nEnteredWithHelmet;                   //people enter with helmet count
        int      nEnteredWithoutHelmet;                //people enter without helmet count
        int      nExitedWithHelmet;                    //people exit with helmet count
        int      nExitedWithoutHelmet;                 //people exit without helmet count
    }DH_NUMBERSTAT;
    
    // CLIENT_DoFindNumberStat's ouput param
    typedef struct __NET_OUT_DOFINDNUMBERSTAT
    {
        DWORD				dwSize;
        int                 nCount;                              // count
        DH_NUMBERSTAT       *pstuNumberStat;                     // state array
        int                 nBufferLen;
    }NET_OUT_DOFINDNUMBERSTAT;
    
    //// intelligent traffic detector
    
    // CLIENT_GetParkingSpaceStatus's input param
    typedef struct tagNET_IN_GET_PARKINGSPACE_STATUS
    {
        DWORD                dwSize;                         // struct size
        DWORD                dwWaitTime;                     // wait time
        int                  nChannelID;                     // channel ID
        int *                pLaneID;                        // range[0,255], pLaneID==NULL means all parking space, the max number is DH_PRODUCTION_DEFNITION.nMaxRoadWays
        int                  nLaneCount;                     // apply to sizeof(int)*nLaneCount memory
    } NET_IN_GET_PARKINGSPACE_STATUS;
    
    typedef struct tagNET_LANE_PARKINGSPACE_STATUS
    {
        DWORD                dwSize;                         // struct size
        int                  nLaneID;                        // lane ID
        unsigned int         nPictureId;                     // picture ID,get picture data
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;      // traffic car info
    } NET_LANE_PARKINGSPACE_STATUS;
    
    // CLIENT_GetParkingSpaceStatus's output param
    typedef struct tagNET_OUT_GET_PARKINGSPACE_STATUS
    {
        DWORD                dwSize;                         // struct size
        NET_LANE_PARKINGSPACE_STATUS* pStatus;               // status
        int                  nMaxStatus;                     // need apply to sizeof(NET_LANE_PARKINGSPACE_STATUS)*nMaxStatus, and nMaxStatus == DH_PRODUCTION_DEFNITION.nMaxRoadWays memory
        int                  nRetStatus;                     // actual returns status number of parking spaces
    } NET_OUT_GET_PARKINGSPACE_STATUS;
    
    // CLIENT_AttachParkingSpaceData's input param
    typedef struct tagNET_CB_PARKINGSPACE_DATA
    {
        DWORD                dwSize;                         // struct size
        void*                pPicBuffer;                     // image binary data
        unsigned int         nPicLength;                     // picture length
    } NET_CB_PARKINGSPACE_DATA;
    
    // CLIENT_AttachParkingSpaceData callback function , pBuf is json and image data info , nBufLen is pBuf length,for forwarding services
    typedef int (CALLBACK *fNotifySnapData)(LLONG lParkingHandle, NET_CB_PARKINGSPACE_DATA* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttachParkingSpaceData's input param
    typedef struct tagNET_IN_ATTACH_PARKINGSPACE
    {
        DWORD                dwSize;                         // struct size
        DWORD                dwWaitTime;                     // wait time
        int                  nChannelID;                     // channel ID
        unsigned int         nPictureId;                     // picture ID, can look for NET_LANE_PARKINGSPACE_STATUS.nPictureId
        
        fNotifySnapData      cbNotifySnapData;               // callback function
        LDWORD               dwUser;                         // user-defined parameters
    } NET_IN_ATTACH_PARKINGSPACE;
    
    
    //NET_CAR_PASS_INFOS related enumerated type
    typedef enum tagNET_CAR_SIZE
    {
        CAR_SIZE_UNKNOWN  = 0 ,     //unknown
        CAR_SIZE_SAMLL        ,     //small car
        CAR_SIZE_BIG          ,     //big car
    }NET_CAR_SIZE;
    
    typedef enum tagNET_CAR_ACTION
    {
        CAR_ACTION_UNKNOWN = 0 ,
        CAR_ACTION_ENTER       ,  //Enter the detection area
        CAR_ACTION_LEAVE       ,  //Leave the detection area
    }NET_CAR_ACTION;
    
    
    //CLIENT_AttachCarPassInfo callback function returns the structure of the car pass information typedef struct tagNET_CAR_PASS_INFO
    typedef struct tagNET_CAR_PASS_INFO
    {
        DWORD                dwSize;
        
        DWORD                nID;                              // Car ID
        DWORD                nLaneNumber;                      // Start from0,for example, if there is 3 lane, the number of the lane is 0 1 2 respectively
        DWORD                nRoadwayNumber;                   // Custom lane number, User configurable lane number, the current value in the range of 1-16
        DWORD                nSpeed;                           // Car speed (km/h)
        NET_CAR_SIZE         emCarSize;                        // Car size type
        NET_CAR_ACTION       emCarAction;                      // Car action type
        NET_TIME_EX          stuTime;                          // Action happens time,accurate to seconds
    }NET_CAR_PASS_INFO;
    
    // Port CLIENT_AttachCarPassInfo callback function
    // nInfoNum the number of car pass information
    // pstuCarPassInfos the array of car pass information number
    typedef int (CALLBACK *fNotifyCarPassInfo)(LLONG lCarPassHandle, NET_CAR_PASS_INFO* pstuCarPassInfos,  int nInfoNum ,   LDWORD dwUser);
    
    // Port CLIENT_AttachCarPassInfo input parameter
    typedef struct tagNET_IN_ATTACH_CAR_PASS_INFO
    {
        DWORD                dwSize;                         // he size of the structure is too small,should be assigned
        int                  nChannelID;                     // Channel ID
        
        fNotifyCarPassInfo   cbNotifyCarPassInfo;            // Callback function, when thereis a car information,a callback to the top
        LDWORD               dwUser;                         // User-defined parameters
    }NET_IN_ATTACH_CAR_PASS_INFO;
    
    //Port CLIENT_AttachCarPassInfo output parameter
    typedef struct tagNET_OUT_ATTACH_CAR_PASS_INFO
    {
        DWORD       dwSize;         // The size of the structure is too small,should be assigned
    }NET_OUT_ATTACH_CAR_PASS_INFO;
    
    // CLIENT_AttachParkingSpaceData's output param
    typedef struct tagNET_OUT_ATTACH_PARKINGSPACE
    {
        DWORD                dwSize;                         // struct size
    } NET_OUT_ATTACH_PARKINGSPACE;
    
    // CLIENT_DetachParkingSpaceData's input param
    typedef struct tagNET_IN_DETACH_PARKINGSPACE
    {
        DWORD                dwSize;                         // struct size
        DWORD                dwWaitTime;                     // wait time
        LLONG                lParkingHandle;                 // CLIENT_AttachParkingSpaceData return handle
    } NET_IN_DETACH_PARKINGSPACE;
    // CLIENT_DetachParkingSpaceData's output param
    typedef struct tagNET_OUT_DETACH_PARKINGSPACE
    {
        DWORD                dwSize;                         // struct size
    } NET_OUT_DETACH_PARKINGSPACE;
    
    // Batch download file
    
    // Download progress callback function prototypes?? nError Indicates that an error occurred during the download of??1-insufficient buffer??2-parity errof of return data??3-failed to download current file??4-failed to create corresponding storage file
    // When download according to the file,ID setting by the User is dwFileID, When download according to the conditions,ID setting by the User is dwConditionID
    typedef void (CALLBACK *fMultiFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);
    
    //Ways to download file
    typedef enum tagEM_DOWNLOAD_FILE_TYPE
    {
        EM_DOWNLOAD_BY_FILENAME = 0      ,       //Download according to file name
        EM_DOWNLOAD_BY_CONDITION         ,       //Download according to query conditions
    }EM_DOWNLOAD_FILE_TYPE;
    
    //Download time type
    typedef enum tagEM_DOWNLOAD_TIME_TYPE
    {
        EM_DOWNLOAD_TIME_SNAP = 0       ,         //¡Á????¡À??
        EM_DOWNLOAD_TIME_STORAGE        ,         //Storage time
    }EM_DOWNLOAD_TIME_TYPE;
    
    //Download data type
    typedef enum tagEM_DOWNLOAD_DATA_TYPE
    {
        EM_DOWNLOAD_DATA_RECORD = 0 ,               //Record
        EM_DOWNLOAD_DATA_PICTURE ,                  //Picture
    }EM_DOWNLOAD_DATA_TYPE;
    
    // CLIENT_DownLoadMultiFile  port parameter
    typedef struct tagNET_DOWNLOADFILE_INFO
    {
        DWORD               dwSize;
        DWORD               dwFileID;                       // Document ID, assigned by the user
        int                 nFileSize;                      // Query to the file size
        char                szSourceFilePath[MAX_PATH];     // Query to the file path
        char                szSavedFileName[MAX_PATH];      // Save the file path
    }NET_DOWNLOADFILE_INFO;
    
    typedef struct tagNET_DOWNLOAD_CONDITION_INFO
    {
        DWORD                   dwSize;
        DWORD                   dwConditionID;                  // Condition ID, assign by the User
        int                     nChannel;                       // Channel ID
        NET_TIME                stuStartTime;                   // Start time
        NET_TIME                stuEndTime;                     // End time
        EM_DOWNLOAD_TIME_TYPE   emTimeType;                     // Time type
        EM_DOWNLOAD_DATA_TYPE   emDataType;                     // Data type
        char                    szSavedFileName[MAX_PATH];      //Save the file path
    }NET_DOWNLOAD_CONDITION_INFO;
    
    typedef struct tagNET_IN_DOWNLOAD_MULTI_FILE
    {
        DWORD               dwSize;
        // Download according to file name
        int                 nFileCount;                     // The number of files to be downloaded
        NET_DOWNLOADFILE_INFO* pFileInfos;                  // File information to be downloaded
        
        fMultiFileDownLoadPosCB cbPosCallBack;              // Progress callback function
        LDWORD              dwUserData;                     // User data
        EM_DOWNLOAD_FILE_TYPE           emDownloadType;             // Download ways
        //Download according to query conditions
        int                             nConditionCount;             // Number of download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid
        NET_DOWNLOAD_CONDITION_INFO*    pConditionInfos;             // Download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid
    }NET_IN_DOWNLOAD_MULTI_FILE;
    
    typedef struct tagNET_OUT_DOWNLOAD_MULTI_FILE
    {
        DWORD               dwSize;
        LLONG               lDownLoadHandle;                // Download the handle
    }NET_OUT_DOWNLOAD_MULTI_FILE;
    
    typedef struct __NET_VIDEOANALYSE_STATE
    {
        DWORD              dwSize;
        DWORD              dwProgress;                   // Analysis of progress??0-100
        char               szState[DH_COMMON_STRING_64]; // Channel Status,Running"??Run??"Stop"??Stop??"NoStart"??Not started??"Failed"??failed ??"Successed"??successed
        char               szFailedCode[DH_COMMON_STRING_64]; // Error code
    }NET_VIDEOANALYSE_STATE;
    
    //Real-time video analysis progress status callbacks
    typedef int (CALLBACK *fVideoAnalyseState)(LLONG lAttachHandle, NET_VIDEOANALYSE_STATE* pAnalyseStateInfos, LDWORD dwUser, void* pReserved);
    
    // CLIENT_AttachVideoAnalyseState  Interface input parameters
    typedef struct __NET_IN_ATTACH_VIDEOANALYSE_STATE
    {
        DWORD              dwSize;
        int                nChannleId;            // Channel number
        fVideoAnalyseState cbVideoAnalyseState;   // Video analysis status callback function
        LDWORD             dwUser;                //User Information
    }NET_IN_ATTACH_VIDEOANALYSE_STATE;
    
    // CLIENT_AttachVideoAnalyseState  Interface output parameters
    typedef struct __NET_OUT_ATTACH_VIDEOANALYSE_STATE
    {
        DWORD              dwSize;
        LLONG              lAttachHandle;         // Analysis of the progress of the analysis progress handle that uniquely identifies a particular channel
    }NET_OUT_ATTACH_VIDEOANALYSE_STATE;
    
    // ????????¡Á???
    typedef enum tagEM_TALK_STATE
    {
        EM_TALK_STATE_UNKNOWN,                 // ????
        EM_TALK_STATE_INVITING,                // ?¡Â??
        EM_TALK_STATE_RINGING,                 // ¡À???
        EM_TALK_STATE_ANSWER,                  // ????
        EM_TALK_STATE_REFUSE,                  // ????
        EM_TALK_STATE_HANGUP,                  // ????
        EM_TALK_STATE_BUSYING,                 // ????
        EM_TALK_STATE_CANCEL,                  // ????????
    } EM_TALK_STATE;
    
#define NET_CALL_NUM_MAX           128         // ¡Á??¨®?¡§?¡ã????????
    
    // CLIENT_AttachTalkState ???¡Â??????????????????¡Á???
    typedef struct tagNET_TALK_STATE
    {
        DWORD                dwSize;
        char                 szCallID[DH_COMMON_STRING_64];  // ????????¡À¨º????
        int                  nAudioPort;                     // ????????
        int                  nVideoPort;                     // ????????
        char                 szMediaAddr[DH_MAX_IPADDR_LEN]; // ???¡Â????
        EM_TALK_STATE        emState;                        // ¡Á???
        int                  nNumberCount;                   // ??????????
        char                 szNumbers[NET_CALL_NUM_MAX][DH_COMMON_STRING_32]; // ??????????¡À¨ª
    } NET_TALK_STATE;
    
    // ???? CLIENT_AttachTalkState ?????¡Â????
    typedef void (CALLBACK *fNotifyTalkState)(LLONG lAttachHandle, NET_TALK_STATE* pstuState, int nLen, LDWORD dwUser);
    
    // ???? CLIENT_AttachTalkState ??????????
    typedef struct tagNET_IN_ATTACH_TALK_STATE
    {
        DWORD                dwSize;                         // ???¨¢?????¨®??,¡À???????
        int                  nChnId;                         // ?¡§??????????¡À¨º??????????
        fNotifyTalkState     cbCallBack;                     // ???¡Â????,??????¡Á????¡À,???¡Â??????
        LDWORD               dwUser;                         // ???¡ì¡Á??¡§??????
    }NET_IN_ATTACH_TALK_STATE;
    
    // ???? CLIENT_AttachTalkState ??????????
    typedef struct tagNET_OUT_ATTACH_TALK_STATE
    {
        DWORD       dwSize;                                  // ???¨¢?????¨®??,¡À???????
        char        szCallID[DH_COMMON_STRING_64];           // ????????¡À¨º????
    }NET_OUT_ATTACH_TALK_STATE;
    
    ///////////////////////////////// IVS server video analysis module /////////////////////////////////
    // Video analysis  report result detect type definition
#define NET_DIAGNOSIS_DITHER                    "VideoDitherDetection"                       // Video vibration detect  Corresponding structure body(NET_VIDEO_DITHER_DETECTIONRESULT)
#define NET_DIAGNOSIS_STRIATION                 "VideoStriationDetection"                    // Video stria detect  Corresponding structure body(NET_VIDEO_STRIATION_DETECTIONRESULT)
#define NET_DIAGNOSIS_LOSS                      "VideoLossDetection"                         // Video loss detect  Corresponding structure body(NET_VIDEO_LOSS_DETECTIONRESULT)
#define NET_DIAGNOSIS_COVER                     "VideoCoverDetection"                        // Camera masking detect Corresponding structure body(NET_VIDEO_COVER_DETECTIONRESULT)
#define NET_DIAGNOSIS_FROZEN                    "VideoFrozenDetection"                       // Video freeze detect Corresponding structure body(NET_VIDEO_FROZEN_DETECTIONRESULT)
#define NET_DIAGNOSIS_BRIGHTNESS                "VideoBrightnessDetection"                   // Video brightness abnormal detect Corresponding structure body(NET_VIDEO_BRIGHTNESS_DETECTIONRESULT)
#define NET_DIAGNOSIS_CONTRAST                  "VideoContrastDetection"                     // Video contrast abnormal detect  Corresponding structure body(NET_VIDEO_CONTRAST_DETECTIONRESULT)
#define NET_DIAGNOSIS_UNBALANCE                 "VideoUnbalanceDetection"                    // Video color cast detect Corresponding structure body(NET_VIDEO_UNBALANCE_DETECTIONRESULT)
#define NET_DIAGNOSIS_NOISE                     "VideoNoiseDetection"                        // Video noise detect Corresponding structure body(NET_VIDEO_NOISE_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLUR                      "VideoBlurDetection"                         // Video blur detect Corresponding structure body(NET_VIDEO_BLUR_DETECTIONRESULT)
#define NET_DIAGNOSIS_SCENECHANGE               "VideoSceneChangeDetection"                  // Video scene change detect Corresponding structure body(NET_VIDEO_SCENECHANGE_DETECTIONRESULT)
    
    typedef enum tagNET_STATE_TYPE
    {
        NET_EM_STATE_ERR,        // Others
        NET_EM_STATE_NORMAL,     // "Normal"
        NET_EM_STATE_WARNING,    // "Warning"
        NET_EM_STATE_ABNORMAL,   // "Abnormal"
    }NET_STATE_TYPE;
    // video stream type
    typedef enum tagNET_STREAM_TYPE
    {
        NET_EM_STREAM_ERR,                   // Others
        NET_EM_STREAM_MAIN,					// "Main"-Main stream
        NET_EM_STREAM_EXTRA_1,				// "Extra1"-Extra stream 1
        NET_EM_STREAM_EXTRA_2,				// "Extra2"-Extra stream 2
        NET_EM_STREAM_EXTRA_3,				// "Extra3"-Extra stream 3
        NET_EM_STREAM_SNAPSHOT,				// "Snapshot"-Snap bit stream
        NET_EM_STREAM_OBJECT,				// "Object"-Object stream
        NET_EM_STREAM_AUTO,                 // "Auto"
        NET_EM_STREAM_PREVIEW,              // "Preview"
        NET_EM_STREAM_NONE,					// No video stream (audio only)
    }NET_STREAM_TYPE;
    // Video diagnosis type
    typedef enum tagNET_VIDEODIAGNOSIS_RESULT_TYPE
    {
        NET_EM_ROTATION   ,					// "Rotation"	-Video analysis of polling
        NET_EM_REAL		  ,					// "Real" -Real-time video analysis
        NET_EM_NR_UNKNOW  ,					// Undefined
    }NET_VIDEODIAGNOSIS_RESULT_TYPE;
    //Video causes of diagnostic error
    typedef enum tagNET_VIDEODIAGNOSIS_FAIL_TYPE
    {
        NET_EM_NO_ERROR				 ,			// Diagnostic success
        NET_EM_DISCONNECT			 ,			// "Disconnect"				- End devices can be connected
        NET_EM_CH_NOT_EXIST			 ,			// "ChannelNotExist"		- Channel does not exist
        NET_EM_LOGIN_OVER_TIME		 ,			// "LoginOverTime"			- Login Timeout
        NET_EM_NO_VIDEO				 ,			// "NoVideo"				- No video successful login
        NET_EM_NO_RIGHT				 ,			// "NoRight"				- No operating authority
        NET_EM_PLATFROM_LOGIN_FAILED ,			// "PlatformLoginFailed"	- Login failed platform
        NET_EM_PLATFROM_DISCONNECT 	 ,			// "PlatformDisconnect"		- Disconnect platform
        NET_EM_GET_STREAM_OVER_TIME  ,			// "GetStreamOverTime"		- Get stream timeout
        NET_EM_NF_UNKNOW			 ,			// Other reasons, as detailed in the structure described in the reason for the failure
    }NET_VIDEODIAGNOSIS_FAIL_TYPE;
    
    // General long character ended with '\0'
    typedef struct tagNET_ARRAY
    {
        DWORD                dwSize;                         // Current structure body size
        char*                pArray;                         // Buffer zone. Now the min value is 260 byte.Caller shall apply for the memory. The filling in data shall ended with '\0'.
        DWORD                dwArrayLen;                     // Buffer space length
    }NET_ARRAY;
    
    // Video analysis result report general data
    typedef struct tagNET_VIDEODIAGNOSIS_COMMON_INFO
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nDiagnosisID;                   // Detect channel
        NET_ARRAY            stProject;                      // Project name
        NET_ARRAY            stTask;                         // Task name
        NET_ARRAY            stProfile;                      // Parameter list name
        NET_ARRAY            stDeviceID;                     // Device unique ID
        NET_TIME             stStartTime;                    // Start time
        NET_TIME             stEndTime;                      // End time
        int                  nVideoChannelID;                // Video channel No. The channel of the front-end device such as DVR,IPC.
        NET_STREAM_TYPE      emVideoStream;                  // Video bit stream
        NET_VIDEODIAGNOSIS_RESULT_TYPE	emResultType;					// Diagnosis type
        BOOL							bCollectivityState;             // Diagnostic results
        NET_VIDEODIAGNOSIS_FAIL_TYPE	emFailedCause;					// Reasons for failure
        char                            szFailedCode[DH_COMMON_STRING_64]; // Describe the reason for the failure
        char                            szResultAddress[DH_COMMON_STRING_128];  // Diagnosis result storage address
        int                             nFrameRate;                             // ????	???? kb/s, ???¨¬??¡À¡§????
        int                             nFrameWidth;                            // ?¨ª	???¨¬??¡À¡§????
        int                             nFrameHeight;                           // ??	???¨¬??¡À¡§????
    }NET_VIDEODIAGNOSIS_COMMON_INFO;
    
    // The result of detect type (NET_DIAGNOSIS_DITHER)  Video vibration detect -- Video change,wind or vibration,rotation including the PTZ movement.
    typedef struct tagNET_VIDEO_DITHER_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status  Usually smaller than is normal. Larger than is abnormal and the value in the middle is warning.
        int                  nDuration;                      // Status lasts time  Detect item last time. It is null right now.
    }NET_VIDEO_DITHER_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_STRIATION) Video stria detect  -- There is abnormal stria on the camera resulting from the interference.
    typedef struct tagNET_VIDEO_STRIATION_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_STRIATION_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_LOSS) Video loss detect  -- Result from power failure or disconnection.
    typedef struct tagNET_VIDEO_LOSS_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_LOSS_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_COVER) Camera masking detect -- The camera masking occurred
    typedef struct tagNET_VIDEO_COVER_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_COVER_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_FROZEN) Video freeze detect -- The video idles for specified time is regarded as freeze.
    typedef struct tagNET_VIDEO_FROZEN_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_FROZEN_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_BRIGHTNESS) Video brightness abnormal detect --The following contents are some camera improper setup detect.
    typedef struct tagNET_VIDEO_BRIGHTNESS_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_BRIGHTNESS_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_CONTRAST) Video contrast abnormal detect
    typedef struct tagNET_VIDEO_CONTRAST_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_CONTRAST_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_UNBALANCE) Video color cast detect
    typedef struct tagNET_VIDEO_UNBALANCE_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_UNBALANCE_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_NOISE) Video noise detect
    typedef struct tagNET_VIDEO_NOISE_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_NOISE_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_BLUR) Video blur detect
    typedef struct tagNET_VIDEO_BLUR_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_BLUR_DETECTIONRESULT;
    
    // The result of detect type (NET_DIAGNOSIS_SCENECHANGE) Video scene change detect
    typedef struct tagNET_VIDEO_SCENECHANGE_DETECTIONRESULT
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nValue;                         // Detect result value
        NET_STATE_TYPE       emState;                        // Detect result status
        int                  nDuration;                      // Status lasts time
    }NET_VIDEO_SCENECHANGE_DETECTIONRESULT;
    
    typedef struct tagNET_DIAGNOSIS_RESULT_HEADER
    {
        DWORD                dwSize;                         // Current structure body size
        
        char                 szDiagnosisType[MAX_PATH];      // Analysis type. Please refer to dhnetsdk.h for "video analysis report result type definition"  such as NET_DIAGNOSIS_DITHER
        int                  nDiagnosisTypeLen;              // The structure body size of current analysis type
    }NET_DIAGNOSIS_RESULT_HEADER;
    
    // cbVideoDiagnosis Call parameter type
    typedef struct tagNET_REAL_DIAGNOSIS_RESULT
    {
        DWORD                dwSize;                         // Current structure body size
        
        NET_VIDEODIAGNOSIS_COMMON_INFO* pstDiagnosisCommonInfo;  //Video analysisi general info
        
        int					 nTypeCount;					 // Analysis result data analysis type amount
        void*                pDiagnosisResult;               // The analysis result data for once. The format is as NET_DIAGNOSIS_RESULT_HEADER+analysis type1+NET_DIAGNOSIS_RESULT_HEADER+analysis type 2+...
        DWORD                dwBufSize;                      // Buffer length
    }NET_REAL_DIAGNOSIS_RESULT;
    
    // Video analysis result report call function
    typedef int (CALLBACK *fRealVideoDiagnosis)(LLONG lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);
    
    //The input parameter of interface  CLIENT_StartVideoDiagnosis
    typedef struct tagNET_IN_VIDEODIAGNOSIS
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nDiagnosisID;                   // Video analysis ID begins with 0
        DWORD                dwWaitTime;                     // Interface time out waiting time
        
        fRealVideoDiagnosis  cbVideoDiagnosis;               // Video analysis result call function.
        LDWORD                dwUser;                         // User customized parameter
    }NET_IN_VIDEODIAGNOSIS;
    
    // The output parameter of interface CLIENT_StartVideoDiagnosis
    typedef struct tagNET_OUT_ATTACH_REALDIAGNOSIS
    {
        DWORD                dwSize;                         // Current structure body size
        LLONG                 lDiagnosisHandle;               // Subscribe handle
    }NET_OUT_VIDEODIAGNOSIS;
    
    // The input parameter of interface CLIENT_StartFindDiagnosisResult
    typedef struct tagNET_IN_FIND_DIAGNOSIS
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nDiagnosisID;                   // Video analysis ID begins with 0
        DWORD                dwWaitTime;                     // Interface time out waiting time
        
        NET_ARRAY            stuDeviceID;                    // Device unique ID.pArray:NULL means does not search by device ID.
        NET_TIME             stuStartTime;                   // Start time
        NET_TIME             stuEndTime;                     // End time
        int                  nVideoChannel;                  // Video channel No.,-1: All channel No.
        int                  nTypeCount;                     // Analysis type amount.0:Do not use analysis type to search.
        NET_ARRAY*           pstDiagnosisTypes;              // Analysis type array. It is the analysis type to be searched.
        char                 szProjectName[MAX_PATH];        // Project name
    } NET_IN_FIND_DIAGNOSIS;
    
    // The output parameter of interface CLIENT_StartFindDiagnosisResult
    typedef struct tagNET_OUT_FIND_DIAGNOSIS
    {
        DWORD                dwSize;                         // Current structure body size
        LLONG                 lFindHandle;                    // Search handle
        DWORD                dwTotalCount;                   // The total amount that matched the criteria
    }NET_OUT_FIND_DIAGNOSIS;
    
    // The input parameter of interface CLIENT_DoFindDiagnosisResult
    typedef struct tagNET_IN_DIAGNOSIS_INFO
    {
        DWORD                dwSize;                         // Current structure body size
        int                  nDiagnosisID;                   // Video analysis ID begins with 0
        DWORD                dwWaitTime;                     // Interface time out waiting time
        
        int                  nFindCount;                     // The video analysis result amount of each search
        int                  nBeginNumber;                   // Search initial SN 0<=beginNumber<= totalCount-1
    }NET_IN_DIAGNOSIS_INFO;
    
    // CLIENT_StartRealTimeProject Interface input parameters
    typedef struct tagNET_IN_START_RT_PROJECT_INFO
    {
        DWORD                dwSize;                         // This structure size
        char*                pszProjectInfo;                 // Real-time schedule information by calling dhconfigsdk.dll get the package in the interface CLIENT_PacketData
        // Package command corresponding CFG_CMD_VIDEODIAGNOSIS_REALPROJECT
    }NET_IN_START_RT_PROJECT_INFO;
    
    // CLIENT_StartRealTimeProject Interface output parameters
    typedef struct tagNET_OUT_START_RT_PROJECT_INFO
    {
        DWORD                dwSize;                         // This structure size
    }NET_OUT_START_RT_PROJECT_INFO;
    
    // CLIENT_StopRealTimeProject Interface output parameters
    typedef struct tagNET_IN_STOP_RT_PROJECT_INFO
    {
        DWORD                dwSize;                         // This structure size
        char*                 pszProjectNames;               // Program name to the name of the separator && as the example??Project1&&Project2
    }NET_IN_STOP_RT_PROJECT_INFO;
    
    // CLIENT_StopRealTimeProject Interface output parameters
    typedef struct tagNET_OUT_STOP_RT_PROJECT_INFO
    {
        DWORD                dwSize;                         // This structure size
    }NET_OUT_STOP_RT_PROJECT_INFO;
    
    // carport light info
    typedef struct tagNET_CARPORTLIGHT_INFO
    {
        DWORD               dwSize;
        NET_CARPORTLIGHT_TYPE emType;                        // carport type
        NET_CARPORTLIGHT_MODE emMode;                        // light way
    }NET_CARPORTLIGHT_INFO;
    
    // carpor light status
    typedef struct tagNET_CARPORTLIGHT_STATUS
    {
        DWORD                dwSize;                         // struct size
        int                  nLightNum;                      // light num
        NET_CARPORTLIGHT_INFO stuLights[DH_MAX_CARPORTLIGHT_NUM]; // light info,don't repeat
        int                  nFiringTime;                   // firing time(s)
        int                  nHoldTime;                     // hold time(s), -1 means keep,0 auto control
    }NET_CARPORTLIGHT_STATUS;
    
    // CLIENT_GetCarPortLightStatus's interface input
    typedef struct tagNET_IN_GET_CARPORTLIGHT_STATUS
    {
        DWORD                dwSize;                         // struct size
        int                  nChannelId;                     // channel ID
    }NET_IN_GET_CARPORTLIGHT_STATUS;
    
    // CLIENT_GetCarPortLightStatus's interface output
    typedef struct tagNET_OUT_GET_CARPORTLIGHT_STATUS
    {
        DWORD                dwSize;                         //struct size
        NET_CARPORTLIGHT_STATUS stuLightStatus;              //light status
    }NET_OUT_GET_CARPORTLIGHT_STATUS;
    
    // CLIENT_SetCarPortLightStatus's interface input
    typedef struct tagNET_IN_SET_CARPORTLIGHT_STATUS
    {
        DWORD                dwSize;                         // struct size
        int                  nChannelId;
        NET_CARPORTLIGHT_STATUS stuLightStatus;              // light status
    }NET_IN_SET_CARPORTLIGHT_STATUS;
    
    // CLIENT_SetCarPortLightStatus's interface output
    typedef struct tagNET_OUT_SET_CARPORTLIGHT_STATUS
    {
        DWORD                dwSize;                         // struct size
        
    }NET_OUT_SET_CARPORTLIGHT_STATUS;
    typedef struct tagNET_DEV_VIDEODIAGNOSIS_MULTI_INFO
    {
        DWORD                dwSize;                         // Current structure body size
        
        NET_VIDEODIAGNOSIS_COMMON_INFO*          pstDiagnosisCommonInfo;  //Video analysis general info. You need to allocate the following pointer of the structure body.
        
        BOOL                 abDither;						 // It is to stand for current analysis item is valid or not in this result.
        NET_VIDEO_DITHER_DETECTIONRESULT*        pstDither;  //  Video vibration detect
        
        BOOL                 abStration;
        NET_VIDEO_STRIATION_DETECTIONRESULT*     pstStration;// Video stria detect
        
        BOOL                 abLoss;
        NET_VIDEO_LOSS_DETECTIONRESULT*          pstLoss;    // Video loss detect
        
        BOOL                 abCover;
        NET_VIDEO_COVER_DETECTIONRESULT*         pstCover;   // Camera masking detect
        
        BOOL                 abFrozen;
        NET_VIDEO_FROZEN_DETECTIONRESULT*        pstFrozen;  // Video freeze detect
        
        BOOL                 abBrightness;
        NET_VIDEO_BRIGHTNESS_DETECTIONRESULT*    pstBrightness;// Video brightness abnormal detect
        
        BOOL                 abContrast;
        NET_VIDEO_CONTRAST_DETECTIONRESULT*      pstContrast;//Video contrast abnormal detect
        
        BOOL                 abUnbalance;
        NET_VIDEO_UNBALANCE_DETECTIONRESULT*     pstUnbalance;//  Video color cast detect
        
        BOOL                 abNoise;
        NET_VIDEO_NOISE_DETECTIONRESULT*         pstNoise;   //Video noise detect
        
        BOOL                 abBlur;
        NET_VIDEO_BLUR_DETECTIONRESULT*          pstBlur;    // Video blur detect
        
        BOOL                 abSceneChange;
        NET_VIDEO_SCENECHANGE_DETECTIONRESULT*   pstSceneChange;// Video scene change detect
    }NET_VIDEODIAGNOSIS_RESULT_INFO;
    
    // The output parameter of interface CLIENT_DoFindDiagnosisResult
    typedef struct tagNET_OUT_DIAGNOSIS_INFO
    {
        DWORD                dwSize;                         // Current structure body size
        
        int                  nInputNum;                      // The amount of the NET_DEV_RESULT_VIDEODIAGNOSIS_INFO you allocate
        int                  nReturnNum;                     // Returned amount
        NET_VIDEODIAGNOSIS_RESULT_INFO*  pstDiagnosisResult; // Result data You need to allocate the pointer of the structure body
    }NET_OUT_DIAGNOSIS_INFO;
    
    ///////////////////////////////// master-slave device control module////////////////////////////
    ///////////////////////////////// CLIENT_OperateMasterSlaveDevice /////////////////////////////////
#define        MASTERSLAVE_CMD_START                   "masterSlaveTracker.start"                   // start
#define        MASTERSLAVE_CMD_STOP                    "masterSlaveTracker.stop"                    // stop
#define        MASTERSLAVE_CMD_MANUALTRACK             "masterSlaveTracker.manualSelectObjectTrack" // manual select object
#define        MASTERSLAVE_CMD_POINTTRACK              "masterSlaveTracker.selectPointTrack"        // points tracking
#define        MASTERSLAVE_CMD_GETCALIBPOINTS          "masterSlaveTracker.getCalibratePoints"      // get calibrate points
#define        MASTERSLAVE_CMD_CALIBRATE               "masterSlaveTracker.calibrate"               // save calibrate points
#define        MASTERSLAVE_CMD_ADDCALIBPOINT           "masterSlaveTracker.addCalibratePoint"       // add calibrate points
#define        MASTERSLAVE_CMD_REMOVECALIBPOINT        "masterSlaveTracker.removeCalibratePoint"    // remove calibrate points
#define        MASTERSLAVE_CMD_MARKMAXZOOM             "masterSlaveTracker.markSceneMaxZoom"        // mark scene max zoom
    
    // master-slave device pair points
    typedef struct __NET_MS_PAIRPOINTS
    {
        int                nStructSize;
        DH_POINT           stMasterPoint;    // master point,range[0,8192]
        DH_POINT           stSlavePoint;     // slave point,range[0,8192]
    }NET_MS_PAIRPOINTS;
    //MASTERSLAVE_CMD_START
    typedef struct __NET_IN_MS_START
    {
        int                nStructSize;
    }NET_IN_MS_START;
    
    //MASTERSLAVE_CMD_START
    typedef struct __NET_OUT_MS_START
    {
        int                nStructSize;
    }NET_OUT_MS_START;
    
    //MASTERSLAVE_CMD_STOP
    typedef struct __NET_IN_MS_STOP
    {
        int                nStructSize;
    }NET_IN_MS_STOP;
    
    //MASTERSLAVE_CMD_STOP
    typedef struct __NET_OUT_MS_STOP
    {
        int                nStructSize;
    }NET_OUT_MS_STOP;
    
    //MASTERSLAVE_CMD_MANUALTRACK
    typedef struct __NET_IN_MS_MANUALTRACK
    {
        int                nStructSize;
        DWORD              dwObject;          // -1 any position of the entire region, >=0 specify the object(can be obtained from the device to return to intelligent frame)
    }NET_IN_MS_MANUALTRACK;
    
    //MASTERSLAVE_CMD_MANUALTRACK
    typedef struct __NET_OUT_MS_MANUALTRACK
    {
        int                nStructSize;
    }NET_OUT_MS_MANUALTRACK;
    
    //MASTERSLAVE_CMD_POINTTRACK
    typedef struct __NET_IN_MS_POINTTRACK
    {
        int                nStructSize;
        DH_POINT           stTrackerPoint;    // Tracker point,range[0,8192]
    }NET_IN_MS_POINTTRACK;
    
    //MASTERSLAVE_CMD_POINTTRACK
    typedef struct __NET_OUT_MS_POINTTRACK
    {
        int                nStructSize;
    }NET_OUT_MS_POINTTRACK;
    
    //MASTERSLAVE_CMD_GETCALIBPOINTS
    typedef struct __NET_IN_MS_GETCALIBPOINTS
    {
        int                nStructSize;
    }NET_IN_MS_GETCALIBPOINTS;
    
    //MASTERSLAVE_CMD_GETCALIBPOINTS
    typedef struct __NET_OUT_MS_GETCALIBPOINTS
    {
        int                        nStructSize;
        int                        nPointsNum;                           // practicality points num
        NET_MS_PAIRPOINTS          stPairPoints[MAX_CALIBPOINTS_NUM];    // pair points
    }NET_OUT_MS_GETCALIBPOINTS;
    
    //MASTERSLAVE_CMD_CALIBRATE
    typedef struct __NET_IN_MS_CALIBRATE
    {
        int                nStructSize;
    }NET_IN_MS_CALIBRATE;
    
    //MASTERSLAVE_CMD_CALIBRATE
    typedef struct __NET_OUT_MS_CALIBRATE
    {
        int                nStructSize;
    }NET_OUT_MS_CALIBRATE;
    
    //MASTERSLAVE_CMD_ADDCALIBPOINT
    typedef struct __NET_IN_MS_ADDCALIBPOINT
    {
        int                        nStructSize;
        BOOL                       bSlavePointEn;        // enable, TURE able;FASLE disable
        NET_MS_PAIRPOINTS          stPairPoints;         // master-slave camera pair point
    }NET_IN_MS_ADDCALIBPOINT;
    
    //MASTERSLAVE_CMD_ADDCALIBPOINT
    typedef struct __NET_OUT_MS_ADDCALIBPOINT
    {
        int                nStructSize;
        DH_POINT           stPoint;      // slave point
    }NET_OUT_MS_ADDCALIBPOINT;
    
    
    //MASTERSLAVE_CMD_REMOVECALIBPOINT
    typedef struct __NET_IN_MS_REMOVECALIBPOINT
    {
        int                nStructSize;
        DH_POINT           stPoint;      // master point
    }NET_IN_MS_REMOVECALIBPOINT;
    
    //MASTERSLAVE_CMD_REMOVECALIBPOINT
    typedef struct __NET_OUT_MS_REMOVECALIBPOINT
    {
        int                nStructSize;
    }NET_OUT_MS_REMOVECALIBPOINT;
    
    //MASTERSLAVE_CMD_MARKMAXZOOM
    typedef struct __NET_IN_MS_MARKMAXZOOM
    {
        int                nStructSize;
    }NET_IN_MS_MARKMAXZOOM;
    
    //MASTERSLAVE_CMD_MARKMAXZOOM
    typedef struct __NET_OUT_MS_MARKMAXZOOM
    {
        int                nStructSize;
    }NET_OUT_MS_MARKMAXZOOM;
    
    ///////////////////////////////// CLIENT_OperateCommDevice Interface parameters defined /////////////////////////////////
#define		COMMDEV_GET_EXTERNLDATA							"devComm.getExternalData"		//get serial external data for 3rd party general data
    
#define        MAX_EXTERN_DATA_LEN                2048
    
    //COMMDEV_GET_EXTERNLDATA Input parameters
    typedef struct __COMMDEV_IN_GET_EXTERNDATA
    {
        DWORD        dwSize;
        
    }COMMDEV_IN_GET_EXTERNDATA;
    
    //COMMDEV_GET_EXTERNLDATA Output parameters
    typedef struct __COMMDEV_OUT_GET_EXTERNDATA
    {
        DWORD		dwSize;
        char		szGetData[MAX_EXTERN_DATA_LEN];				//External serial devices to collect data (data format based on custom projects)
    }COMMDEV_OUT_GET_EXTERNDATA;
    
    
    /////////////////////////////////CLIENT_OperateVideoAnalyseDevice Interface parameter /////////////////////////////////
#define     NET_SET_MODULESTATE                         "devVideoAnalyse.setModuleState"                        // Set module status
#define		NET_TEST_WITH_SCREENPOINTS					"devVideoAnalyse.testCalibrateWithScreenPoints"			// Detect depth of the field according to the coordinates on the screen. It is the actual distance between these two points. Please complete the parameter setup before you test.
#define		NET_TEST_WITH_METRICLENGTH					"devVideoAnalyse.testCalibrateWithMetricLength"		    // Detect parameter of depth of the field according to actual lenght,start point,and direction coordinates.
#define		NET_GET_INTERNALOPTIONS						"devVideoAnalyse.getInternalOptions"					// Get internal option
#define		NET_TUNE_INTERNALOPTIONS					"devVideoAnalyse.tuneInternalOptions"					// Debug internal item
#define		NET_RESET_INTERNALOPTIONS					"devVideoAnalyse.resetInternalOptions"					// Reset all debug internal item
#define     NET_SET_PTZ_PRESET_STATUS                   "devVideoAnalyse.setPtzPresetStatus"                    // get preset info
    
    // Line type
    typedef enum tagNET_EM_LINETYPE
    {
        NET_EM_HORIZONTAL,
        NET_EM_VERTICAL,
    }NET_EM_LINETYPE;
    
    // PTZ preset status type
    typedef enum tagEM_DH_PTZ_PRESET_STATUS
    {
        EM_DH_PTZ_PRESET_STATUS_UNKNOWN,        // unknown
        EM_DH_PTZ_PRESET_STATUS_REACH,          // preset reach the point
        EM_DH_PTZ_PRESET_STATUS_UNREACH,        // preset do not reach the point yet
    }EM_DH_PTZ_PRESET_STATUS;
    
    //PTZ positioning information alarm
    typedef struct
    {
        int     nChannelID;             // Channel number
        int     nPTZPan;                // Horizontal movement of the head position, effective range: [0,3600]
        int     nPTZTilt;               // PTZ vertical position, the effective range: [-1800,1800]
        int     nPTZZoom;               // PTZ iris position changes, effective range: [0,128]
        BYTE    bState;                 // PTZ motion, 0 - Unknown 1 - Movement 2 - Idle
        BYTE    bAction;                // PTZ movement, 0 - preset 1 - line scan 2 - Cruise 3 - patrol track 4 - horizontal rotation
        BYTE    bFocusState;            // PTZ focus state, 0 - unknown 1 - state of motion 2 - Idle
        BYTE    bEffectiveInTimeSection; //In the period of validity of the preset state
        //If the current is preset reported preset period of time, compared with one, otherwise 0
        int     nPtzActionID;           // Cruise ID number
        DWORD   dwPresetID;             // PTZ preset number where
        float   fFocusPosition;         // Focus position
        BYTE	bZoomState;				// ZOOM PTZ status, 0 - Unknown,1-ZOOM, 2 - Idle
        BYTE	bReserved[3];			// Alignment
        DWORD   dwSequence;             // Packet sequence number, used to verify whether the loss
        DWORD   dwUTC;                  // Corresponding UTC (1970-1-1 00:00:00) seconds.
        EM_DH_PTZ_PRESET_STATUS emPresetStatus; // preset status
        int     reserved[248];          // Reserved field
    }DH_PTZ_LOCATION_INFO;
    
    // NET_SET_PTZ_PRESET_STATUS
    typedef struct __NET_IN_PTZ_PRESET_STATUS
    {
        DWORD                    dwSize;
        DH_PTZ_LOCATION_INFO     stPTZStatus;
    }NET_IN_PTZ_PRESET_STATUS;
    
    typedef struct __NET_OUT_PTZ_PRESET_STATUS
    {
        DWORD    dwSize;
    }NET_OUT_PTZ_PRESET_STATUS;
    
    // NET_TEST_WITH_SCREENPOINTS
    typedef struct __NET_IN_CALIBRATE_BY_POINTS
    {
        DWORD               dwSize;                 // Current structure body size
        DH_POINT            stStartPoint;           // Start point of the line 	 The point of the line is within [0,8191].
        DH_POINT            stEndPoint;             // End point 	The point of the line is within [0,8191]
        NET_EM_LINETYPE     emType;                 // Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")
    }NET_IN_CALIBRATE_BY_POINTS;
    
    typedef struct __NET_OUT_CALIBRATE_BY_POINTS
    {
        DWORD               dwSize;                 // Current structure body size
        double              dlength;                // The actual length between these two points. Unit is meter.
    }NET_OUT_CALIBRATE_BY_POINTS;
    
    // NET_TEST_WITH_METRICLENGTH
    typedef struct __NET_IN_CALIBRATE_BY_LENGTH
    {
        DWORD               dwSize;                 // Current structure body size
        double				nLength;				// The actual length between these two points. Unit is meter.
        DH_POINT			stStartPoint;			// Start point of the line	The point of the line is within [0,8191]
        DH_POINT			stDirection;			// Line direction coordinates	For vertical line ony. The point of the line is within [0,8191]
        NET_EM_LINETYPE		emType;					// Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")
    }NET_IN_CALIBRATE_BY_LENGTH;
    
    typedef struct __NET_OUT_CALIBRATE_BY_LENGTH
    {
        DWORD               dwSize;                 // Current structure body size
        DH_POINT			stEndPoint;				// Coordinates of the end of the line on the screen. 	The point of the line is within[0,8191]
    }NET_OUT_CALIBRATE_BY_LENGTH;
    
    typedef struct __NET_INTERNAL_OPTION
    {
        DWORD               dwSize;                 // Current structure body size
        int					nIndex;					// Item SN
        NET_ARRAY           stKey;				    // Option name. 256 bytes including'\0'. Encryption data
        int					nValue;					// Option value
        int					nMinValue;				// Min value
        int					nMaxValue;				// Max value
    }NET_INTERNAL_OPTION;
    
    // Debug internal option NET_GET_INTERNALOPTIONS
    typedef struct __NET_IN_GETINTERNAL_OPTIONS
    {
        DWORD               dwSize;                 // Current structure body size
    }NET_IN_GETINTERNAL_OPTIONS;
    
    typedef struct __NET_OUT_GETINTERNAL_OPTIONS
    {
        DWORD               dwSize;                 // Current structure body size
        
        int					nTotalOptionNum;		// Option amount. Max value search capability.
        int					nReturnOptionNum;		// returned actual option amount.
        NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. Caller shall allocate the address.
    }NET_OUT_GETINTERNAL_OPTIONS;
    
    // NET_TUNE_INTERNALOPTIONS
    typedef struct __NET_IN_TUNEINTERNAL_OPTION
    {
        DWORD               dwSize;                 // Current structure body size
        int					nOptionCount;	    	// Option amount
        NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. The amount stands for the capability.
    }NET_IN_TUNEINTERNAL_OPTION;
    
    typedef struct __NET_OUT_TUNEINTERNAL_OPTION
    {
        DWORD               dwSize;                 // Current structure body size
    }NET_OUT_TUNEINTERNAL_OPTION;
    
    // NET_RESET_INTERNALOPTIONS
    typedef struct __NET_IN_RESETINTERNAL_OPTION
    {
        DWORD               dwSize;                 // Current structure body size
    }NET_IN_RESETINTERNAL_OPTION;
    
    typedef struct __NET_OUT_RESETINTERNAL_OPTION
    {
        DWORD               dwSize;                 // Current structure body size
    }NET_OUT_RESETINTERNAL_OPTION;
    
    // NET_SET_MODULESTATE
    typedef enum tagNET_EM_MODULESTATE
    {
        NET_EM_MODULESTATE_OK,
        NET_EM_MODULESTATE_PAUSE,
    }NET_EM_MODULESTATE;
    typedef struct __NET_IN_SETMODULESTATE
    {
        DWORD				dwSize;					// Current structure body size
        NET_EM_MODULESTATE  emState;				// 0-Normal work.1-Pause. Need to rebuild background when you switch to the normal video since it may change.
        int                 nIndex;                 // Model SN.	-1 stands for all modules.
    }NET_IN_SETMODULESTATE;
    
    typedef struct __NET_OUT_SETMODULESTATE
    {
        DWORD				dwSize;					// Current structure body size
    }NET_OUT_SETMODULESTATE;
    
    /////////////////////////////////CLIENT_DeleteDevConfig Interface parameter/////////////////////////////////
    /*
     * CLIENT_DeleteDevConfig Input and output parameter
     */
    
    typedef enum tagNET_EM_CONFIGOPTION
    {
        NET_EM_CONFIGOPTION_OK,
        NET_EM_CONFIGOPTION_NEEDRESTART,
        NET_EM_CONFIGOPTION_NEEDREBOOT=2,
        NET_EM_CONFIGOPTION_WRITEFILEERROR=4,
        NET_EM_CONFIGOPTION_CAPSNOTSUPPORT=8,
        NET_EM_CONFIGOPTION_VALIDATEFAILED=16,
    }NET_EM_CONFIGOPTION;
    
    typedef struct tagNET_IN_DELETECFG
    {
        DWORD         dwSize;						// Structure body size
        char*         szCommand;                    // Configuration command
    }NET_IN_DELETECFG;
    
    typedef struct tagNET_OUT_DELETECFG
    {
        DWORD         dwSize;                       // Structure body size
        int           nError;                       // The error code device returns
        int           nRestart;                     // Device reboot or not
        DWORD         dwOptionMask;                 // Option. Please refer to enumeration NET_EM_CONFIGOPTION
    }NET_OUT_DELETECFG;
    
    /////////////////////////////////CLIENT_GetMemberNames interface parameter/////////////////////////////////
    /*
     * CLIENT_GetMemberNames Input and output parameter
     */
    typedef struct tagNET_IN_MEMBERNAME
    {
        DWORD         dwSize;                       // Structure body size
        char*         szCommand;                    // Configuration command
    }NET_IN_MEMBERNAME;
    
    typedef struct tagNET_OUT_MEMBERNAME
    {
        DWORD         dwSize;                       // Structure body size
        int           nError;                       // The error code device returns
        int           nRestart;                     // Device reboot or not
        int           nTotalNameCount;              // Name amount. Fromt the capability set. Caller fill in.
        int           nRetNameCount;                // The returned actual name amount
        NET_ARRAY*    pstNames;                     // Name array. The caller apply for the memory. The amount is nTotalNameCount.
    }NET_OUT_MEMBERNAME;
    
    ////////////////////////////////////video compression//////////////////////////////////////
    // staff type
    typedef enum tagNET_EM_STAFF_TYPE
    {
        NET_EM_STAFF_TYPE_ERR,
        NET_EM_STAFF_TYPE_HORIZONTAL,                       // "Horizontal"
        NET_EM_STAFF_TYPE_VERTICAL,                         // "Vertical"
        NET_EM_STAFF_TYPE_ANY,                              // "Any"
        NET_EM_STAFF_TYPE_CROSS,                            // "Cross"
    }NET_EM_STAFF_TYPE;
    
    // region type
    typedef enum tagNET_EM_CALIBRATEAREA_TYPE
    {
        NET_EM_CALIBRATEAREA_TYPE_ERR,
        NET_EM_CALIBRATEAREA_TYPE_GROUD,		            // "Groud"
        NET_EM_CALIBRATEAREA_TYPE_HORIZONTAL,	            // "Horizontal"
        NET_EM_CALIBRATEAREA_TYPE_VERTICAL,		            // "Vertical"
        NET_EM_CALIBRATEAREA_TYPE_ANY,			            // "Any"
    }NET_EM_CALIBRATEAREA_TYPE;
    
    // The concentrated output data subtype
    typedef enum tagNET_EM_OUTPUT_SUB_TYPE
    {
        NET_EM_OUTPUT_SUB_TYPE_ERR,
        NET_EM_OUTPUT_SUB_TYPE_NORMAL,                      // Normal playback speed (the parent type is concentrated Video valid)
        NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS,                    //Concentrated by the playback speed (parent type is effective when concentrated video), quick release in the absence of an object, the object appears when playing at normal speed
    }NET_EM_OUTPUT_SUB_TYPE;
    
    // staff info
    typedef struct tagNET_STAFF_INFO
    {
        DH_POINT	        stuStartLocation;	            // start location
        DH_POINT	        stuEndLocation;		            // end location
        float			    nLenth;				            // length(m)
        NET_EM_STAFF_TYPE	emType;			                // type
    }NET_STAFF_INFO;
    
    // calibration area,common scenario use
    typedef struct tagNET_CALIBRATEAREA_INFO
    {
        int				    nLinePoint;					    // horizontal line point
        DH_POINT	        stuLine[DH_MAX_POLYLINE_NUM];	// horizontal line
        float			    fLenth;						    // lenth
        DH_POLY_POINTS	    stuArea;					    // area
        int				    nStaffNum;					    // number of vertical line
        NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];    // vertical line
        NET_EM_CALIBRATEAREA_TYPE emType;			        // area type
    }NET_CALIBRATEAREA_INFO;
    
    typedef struct tagNET_LOCALFILE_INFO
    {
        DWORD			    dwSize;
        char			    szFilePath[MAX_PATH];	        // file path
    }NET_LOCALFILE_INFO;
    
    typedef struct tagNET_REMOTEFILE_INFO
    {
        DWORD			    dwSize;
        char			    szIP[MAX_PATH];	                // the remote device IP
        unsigned int	    nPort;				            // the remote device  port
        char			    szName[DH_MAX_NAME_LEN];        // the remote device  userName
        char			    szPassword[DH_MAX_NAME_LEN];    // the remote device  password
        BYTE			    byProtocolType;			        // the remote device protocol type,2-the second generation of private 3-the third generation of private
        BYTE			    byReserved[3];			        // byte alignment
        char			    szFilePath[MAX_PATH];           // file path,when byProtocolType == 3 effective.
        int				    nStartCluster;		  	        // start cluster,when byProtocolType == 2 effective.
        int				    nDriverNo;				        // driver no.when byProtocolType == 2 effective.
        
    }NET_REMOTEFILE_INFO;
    
    // file path info
    typedef struct tagNET_FILEPATH_INFO
    {
        DWORD				dwSize;
        BOOL				bFileType;			            // TRUE: local server's file; FALSE: remote device's file
        NET_LOCALFILE_INFO	stuLocalFile;		            // local file, when bFileType==TRUE effective
        NET_REMOTEFILE_INFO	stuRemoteFile;		            // remote file, when bFileType==FALSE effective
    }NET_FILEPATH_INFO;
    
    // global param info
    typedef struct tagNET_GLOBAL_INFO
    {
        DWORD			    dwSize;
        char			    szSceneType[DH_MAX_NAME_LEN];	// scene type,only support "Normal"
        int				    nStaffNum;						// staff num
        NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];	// staffs
        int				    nCalibrateAreaNum;				// number of calibrate area
        NET_CALIBRATEAREA_INFO stuCalibrateArea[DH_MAX_CALIBRATEBOX_NUM]; // calibrate area(if the filed does not exist,return the entire tegion)
        int				    nJitter;		                // vidicon jitter, range[0-100],the value of static camera shake,the more powerful shake,the bigger the value.
        BOOL			    bDejitter;		                // if start to wobble
    }NET_GLOBAL_INFO;
    
    // module info
    typedef struct tagNET_MODULE_INFO
    {
        DWORD			    dwSize;							// size
        BYTE			    bSensitivity;					// sensitivity,range[1-10],the lower the value the sensitivity.
        BYTE			    bReserved[3];
        int				    nDetectRegionPoint;				// detect region point
        DH_POINT		    stuDetectRegion[DH_MAX_POLYGON_NUM]; // detect region
        int				    nExcludeRegionNum;				// number of exclude region
        DH_POLY_POINTS	    stuExcludeRegion[DH_MAX_EXCLUDEREGION_NUM];	// exclude region
    }NET_MODULE_INFO;
    
    // object filter info
    typedef struct tagNET_OBJFILTER_INFO
    {
        DWORD		        dwSize;						    // size
        NET_TIME	        stuStartTime;				    // start time
        NET_TIME	        stuEndTime;					    // end time
        char		        szObjectType[DH_MAX_NAME_LEN];	// object type, support for the following:
        //"Unknown", "Human", "Vehicle",
        //"Fire", "Smoke", "Plate", "HumanFace", "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "Entity"
        char		        szObjectSubType[64];		    // object sub type,support for the following:
        // Vehicle Category:"Unknown"  "Motor" "Non-Motor" "Bus""Bicycle"  "Motorcycle"
        // Plate Category: "Unknown" "Normal" "Yellow" "DoubleYellow" "Police" Armed"
        // "Military" "DoubleMilitary" "SAR" "Trainning"
        // "Personal" "Agri" "Embassy" "Moto" "Tractor" "Other"
        // HumanFace Category:"Normal" "HideEye" "HideNose" "HideMouth"
        DWORD		        dwRGBMainColor[DH_MAX_COLOR_NUM];	// main color,object to the person,said the upper part of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
        DWORD		        dwLowerBodyColor[DH_MAX_COLOR_NUM];	// object to the person,said the lower half of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
        int			        nMinSize;					    // min siez, m
        int			        nMaxSize;					    // max size, m
        int			        nMinSpeed;					    // min speed km/h
        int			        nMaxSpeed;					    // max speed km/h
        DWORD		        dwRGBMainColorNum;			    // object is the person,dwRGBMainColor effective number of colors
        DWORD		        dwLowerBodyColorNum;		    // object is the person, and bRGBMainColor==true,is the lower half of the effective color
        BOOL		        bRGBMainColor;				    // true-dwRGBMainColor the upper part of the color,dwLowerBodyColor the lower half of the color; false-dwRGBMainColor means main color,dwLowerBodyColor nullity
    }NET_OBJFILTER_INFO;
    
    // param of rule
    typedef struct tagNET_VIDEOSYNOPSISRULE_INFO
    {
        DWORD				dwSize;				            // struct size
        BYTE				byOutputType;		            // out tyope,1-snapshot;2-condensatal video;3-snapshot with video
        BYTE				byDensity;			            // density, 1-10, the more value,the density higher
        bool				bShowTime;			            // show time
        bool				bShowBox;			            // show object box
        bool				bEnableRecordResult;            // the result recoded or not
        BYTE				byReserved[3];
        NET_OBJFILTER_INFO	stuFilter[MAX_OBJFILTER_NUM];   // fileter info
        DWORD				dwObjFilterNum;		            // number of filter
        
        // NET_OUT_QUERY_VIDEOSYNOPSIS , CFG_CMD_ANALYSERULE transfer dhconfigsdk.dll get CLIENT_ParseData
        // NET_IN_ADD_VIDEOSYNOPSIS ,CFG_CMD_ANALYSERULEtransfer  dhconfigsdk.dll get CLIENT_PacketData
        char*		        szAnalyseRuleInfo;				// JSON rule info
        int                 nBufferLen;                     // NET_OUT_QUERY_VIDEOSYNOPSIS,apply szAnalyseRuleInfo length
        BOOL				bCustomResolution;				// Custom resolution enabled, TRUE-resolution is determined by emResolution, FALSE-concentrate production based on the original video resolution video
        CAPTURE_SIZE		emResolution;					// Resolution, bCustomResolution is TRUE only valid
        BOOL				bEnableMaxUsedCPU;				// Are maximize occupy CPU resource requirements
        BOOL				bEnableSmoothBorder;			// Target is smooth border
        NET_EM_OUTPUT_SUB_TYPE emOutputSubType;             // After concentrating the output data sub-type, see NET_EM_OUTPUT_SUB_TYPE
        int					nExtractFrameRate;				// Video frame rate pumping concentrated 1-32, the value, the higher the pumping rate of the frame, the client presents the faster playback
        // This field is concentrated only in the output data sub-type (emOutputSubType) is valid NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS
    }NET_VIDEOSYNOPSISRULE_INFO;
    
    // add video synopsis input param
    typedef struct tagNET_IN_ADD_VIDEOSYNOPSIS
    {
        DWORD			    dwSize;			                // size
        NET_FILEPATH_INFO*	pFilePathInfo;	                // file path info
        DWORD				dwFileCount;	                // effective number of files
        NET_GLOBAL_INFO		stuGlobalInfo;	                // global info
        NET_MODULE_INFO		stuModuleInfo;	                // module info
        NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;	        // rule info
        unsigned int		nWaitTime;		                // wait time(ms)
    }NET_IN_ADD_VIDEOSYNOPSIS;
    
    // add video synopsis output param
    typedef struct tagNET_OUT_ADD_VIDEOSYNOPSIS
    {
        DWORD	            dwSize;			                // size
        DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
        DWORD	            nTaskIDCount;	                // count of TaskID
    }NET_OUT_ADD_VIDEOSYNOPSIS;
    
    // pause video synopsis input param
    typedef struct tagNET_IN_PAUSE_VIDEOSYNOPSIS
    {
        DWORD	            dwSize;			                // size
        BOOL                bPause;                         // TRUE-pause  FALSE-resume
        DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
        DWORD	            nTaskIDCount;	                // count of TaskID
        DWORD	            nWaitTime;		                // wait time(ms)
    }NET_IN_PAUSE_VIDEOSYNOPSIS;
    
    //  remove video synopsis input param
    typedef struct tagNET_IN_REMOVE_VIDEOSYNOPSIS
    {
        DWORD	            dwSize;			                // size
        DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
        DWORD	            nTaskIDCount;	                // count of TaskID
        DWORD	            nWaitTime;		                // wait time(ms)
    }NET_IN_REMOVE_VIDEOSYNOPSIS;
    
    // return objece info of video synopsis
    typedef struct tagNET_REAL_SYNOPSIS_OBJECT_INFO
    {
        DWORD               dwSize;
        
        DWORD               dwTaskID;                       // task ID
        DH_MSG_OBJECT       stuObjectInfo;                  // object info
    }NET_REAL_SYNOPSIS_OBJECT_INFO;
    
    typedef struct tagNET_REAL_SYNOPSIS_STATE_INFO
    {
        DWORD               dwSize;
        
        DWORD               dwTaskID;                       // task ID
        int                 nObjectNum;                     // number of object
        int                 nTaolProgress;                  // progress of condensation,0~100
        char                szState[DH_MAX_SYNOPSIS_STATE_NAME]; // state of condensation,"Downloading"  "Synopsising"
        // "DownloadFailed""DownloadSucceeded"
        // "SynopsisFailed" ,"Succeeded"
        // "DownloadPause" ,"SynopsisPause"
        int           nProgressOfCurrentState;              //  progress of current state,0~100
        char				szFailedCode[DH_MAX_STRING_LEN];// Failure code??szState="SynopsisFailed"Effective
        // "OutOfMemory" Out of memory;
        // "TooMany_TargetInVideo"  Too many goals the entire video;
        // "InvalidFilePointer" File pointer is invalid;
        // "InvalidFilePath" File path is invalid;
        // "CreateDirectoryFailed"  Create a folder path fails;
        // "WriteDataFailed" Intermediate file failed to write Tube
        // "DataSizeTooLarge" Tube file is too large
        // "Detect_Nothing" Scene without moving target
        // "OpenDataFailed" Failed to open the intermediate file
        // "InvalidSynopsisBackgroud" Invalid concentrated background
        // "ColorRetrieval" Wrong color retrieve configuration
        // "UnsupportRuleType" Unsupported rule type
        // "RuleNumberExceedLimit" Number of rules overrun
        // "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
        // "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
        // "PointsExceedLimit" Point line or area overrun
        // "BadFunctionType" Error function type
        // "RulePointNumber" Points rule error
        // "MaskRegionNumberExceedLimit" Shielded area overrun quantity
        // "CameraSceneSwitch" Cameras scene change
        // "TooManyTargeInFrame" Excessive number of single-frame target
        // "InalidSynopsisDesity" Concentrated density invalid
        // "ExtrackColorFeatureFailed" Failed to extract color features
        // "JpegEncodeFrameFailed" Jpeg encoder failure
        // "JpegParamRestFailed" Jpeg encoding parameters fail reset
        // "JpegDecodeFrameFailed" Jpeg decoding failure
        // "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
        // "RetrieveImageInvalid" Invalid image retrieval
        // "NetworkAnomaly" DISH Network anomaly map
        // "ObjectNumberLimit" Limit the number of goals over analysis
        // "CreateChannelFailed" Create a channel failure
        // "ReadUGFileFailed" Read UG file failed
        // "GetSynopsisInfoFailed" Failed to obtain concentrated Video
        // "ObjectNumberExceedLimit" The number of targets in the scene over the limit
        // "RebuildBackgroudFailed" Background reconstruction failure
        // "NotExistMiddleFile" Intermediate file does not exist
        // "NotExistSourceFile" Original file does not exist
        // "NotDog" No dongle
        // "NotEnoughFreeDisk" Disk space is not enough
        // "StartDecodeFail" Start decoding failure
        // "DecodeTimeOut" Decoding wait timeout
        // "EncodeTimeOut" Coding wait timeout
        // "ExactTimeOut" Extract snapshots wait timeout
        // "ReadMidlleFileFail" Failed to read the intermediate file
        // "ExactPictureFail" Failed to extract pictures
    }NET_REAL_SYNOPSIS_STATE_INFO;
    
    //callback function of synopsis video info
    typedef int (CALLBACK *fVideoSynopsisObjData)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_OBJECT_INFO* pSynopsisObjectInfo, void* pBuf, int nBufLen, LDWORD dwUser, void* pReserved);
    
    //callback function of synopsis video state
    typedef int (CALLBACK *fVideoSynopsisState)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_STATE_INFO* pSynopsisStateInfos, int nInfoCount, LDWORD dwUser, void* pReserved);
    
    
    
    // CLIENT_RealLoadObjectData's interface define
    typedef struct tagNET_IN_REALLOAD_OBJECTDATA
    {
        DWORD               dwSize;                         // size
        
        int                 nTaskIDNum;                     // number of taskID
        DWORD               *pTaskIDs;                      // material taskID
        BOOL                bNeedPicFile;                   // need download corresponding to the picture
        int                 nWaitTime;                      // wait time(ms)
        fVideoSynopsisObjData cbVideoSynopsisObjData;       // callback function's pointer
        LDWORD         dwUser;
    }NET_IN_REALLOAD_OBJECTDATA;
    
    typedef struct tagNET_OUT_REALLOAD_OBJECTDATA
    {
        DWORD               dwSize;                         // size
        
        LLONG               lRealLoadHandle;                // return subscriptal handle
    }NET_OUT_REALLOAD_OBJECTDATA;
    
    // CLIENT_StopLoadObjectData's interface define
    typedef struct tagNET_IN_STOPLOAD_OBJECTDATA
    {
        DWORD               dwSize;
        
        int                 nTackIDNum;                     // number of tackID
        DWORD               *pTaskIDs;                      // specific taskID
    }NET_IN_STOPLOAD_OBJECTDATA;
    
    // CLIENT_RealLoadSynopsisState's interface define
    typedef struct tagNET_IN_REALLAOD_SYNOPSISSTATE
    {
        DWORD               dwSize;                         // size
        
        int                 nTaskIDNum;                     // number of taskID
        DWORD               *pTaskIDs;                      // specific taskID
        int                 nWaitTime;                      // wait time(ms)
        fVideoSynopsisState cbVideoSynopsisState;           // callback function's pointer
        LDWORD         dwUser;
    }NET_IN_REALLAOD_SYNOPSISSTATE;
    
    typedef struct tagNET_OUT_REALLOAD_SYNOPSISSTATE
    {
        DWORD               dwSize;                         // size
        
        LLONG               lRealLoadHandle;                // return subscriptal handle
    }NET_OUT_REALLOAD_SYNOPSISSTATE;
    
    // CLIENT_StopLoadSynopsisState's interface define
    typedef struct tagNET_IN_STOPLOAD_SYNOPSISSTATE
    {
        DWORD               dwSize;
        
        int                 nTackIDNum;                     // number of taskID
        DWORD               *pTaskIDs;                      // specific taskID
    }NET_IN_STOPLOAD_SYNOPSISSTATE;
    
    // type of video synopsis's query
    typedef enum tagEM_VIDEOSYNOPSIS_QUERY_TYPE
    {
        EM_VIDEOSYNOPSIS_TASK,	                            // task info
        EM_VIDEOSYNOPSIS_OBJ,	                            // snapshot
    }EM_VIDEOSYNOPSIS_QUERY_TYPE;
    
    // query the task of video synopsis infomation
    typedef struct tagNET_QUERY_VSTASK_INFO
    {
        DWORD	            dwSize;			                // size
        DWORD	            dwTaskID;		                // taskID,when value = 0,query all task
    }NET_QUERY_VSTASK_INFO;
    
    // query conditions of video objects in the task infomation
    typedef struct tagNET_QUERY_VSOBJECT_INFO
    {
        DWORD			    dwSize;			                // size
        DWORD*			    pdwTaskID;                		// taskID,when value = -1,query all task
        DWORD			    dwTaskIDCount;                	// count of taskID
        DH_MSG_OBJECT	    stuObjInfo;	                	// object info,when objectID!=0,query all
    }NET_QUERY_VSOBJECT_INFO;
    
    //--CLIENT_QueryVideoSynopsisInfo's interface input define
    typedef struct tagNET_IN_QUERY_VIDEOSYNOPSIS
    {
        DWORD	            dwSize;							// size
        EM_VIDEOSYNOPSIS_QUERY_TYPE emQueryType;            // query type
        DWORD	            dwCount;						// count of query
        DWORD	            dwBeginNumber;					// begin number
        void*	            pQueryInfo;						// information query condition
        // when emQueryType==EM_VIDEOSYNOPSIS_TASK, corresponding to NET_QUERY_VSTASK_INFO
        // when emQueryType==EM_VIDEOSYNOPSIS_OBJ, corresponding to NET_QUERY_VSOBJECT_INFO
        
        DWORD	            dwWaitTime;						// wait time(ms)
    }NET_IN_QUERY_VIDEOSYNOPSIS;
    
    // query to the task of each synopsis video information
    typedef struct tagNET_VSTASK_INFO
    {
        DWORD		        dwSize;			                // size
        DWORD				dwTaskID;		                // task ID
        NET_MODULE_INFO		stuModuleInfo;                	// module info
        NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;           	// info of task rule
        NET_GLOBAL_INFO		stuGlobalInfo;	                // global param
        NET_TIME			stuCreateTime;	                // create time
        char				szCurrState[DH_MAX_SYNOPSIS_STATE_NAME];  // current state,"Downloading" "Synopsising"
        // "DownloadFailed" "DownloadSucceeded"
        // "SynopsisFailed" "Succeeded"
        // "DownloadPause" "SynopsisPause"
        char				szCreateUser[DH_MAX_NAME_LEN];	// the creator
        int					nProgressOfCurrentState;		// progress of current state [0~100]
        char				szLocalFilePath[MAX_PATH];		// local file path
        int					nObjectNum;						// number of object
        NET_FILEPATH_INFO	stuVideoSourceFilePath;			// path of video source file
        NET_FILEPATH_INFO	stuSynopsisVideoFilePath;		// path of synopsis video file
        char                szFailedCode[DH_MAX_STRING_LEN];// Concentrated video failed error code??szCurrState when "SynopsisFailed" Effective
        // "OutOfMemory" Out of memory;
        // "TooMany_TargetInVideo"  Too many goals the entire video;
        // "InvalidFilePointer" File pointer is invalid;
        // "InvalidFilePath" File path is invalid;
        // "CreateDirectoryFailed"  Create a folder path fails;
        // "WriteDataFailed" Intermediate file failed to write Tube
        // "DataSizeTooLarge" Tube file is too large
        // "Detect_Nothing" Scene without moving target
        // "OpenDataFailed" Failed to open the intermediate file
        // "InvalidSynopsisBackgroud" Invalid concentrated background
        // "ColorRetrieval" Wrong color retrieve configuration
        // "UnsupportRuleType" Unsupported rule type
        // "RuleNumberExceedLimit" Number of rules overrun
        // "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
        // "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
        // "PointsExceedLimit" Point line or area overrun
        // "BadFunctionType" Error function type
        // "RulePointNumber" Points rule error
        // "MaskRegionNumberExceedLimit" Shielded area overrun quantity
        // "CameraSceneSwitch" Cameras scene change
        // "TooManyTargeInFrame" Excessive number of single-frame target
        // "InalidSynopsisDesity" Concentrated density invalid
        // "ExtrackColorFeatureFailed" Failed to extract color features
        // "JpegEncodeFrameFailed" Jpeg encoder failure
        // "JpegParamRestFailed" Jpeg encoding parameters fail reset
        // "JpegDecodeFrameFailed" Jpeg decoding failure
        // "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
        // "RetrieveImageInvalid" RetrieveImageInvalid
        // "NetworkAnomaly" NetworkAnomaly
        // "ObjectNumberLimit" bjectNumberLimit
        // "CreateChannelFailed" CreateChannelFailed
        // "ReadUGFileFailed" ReadUGFileFailed
        // "GetSynopsisInfoFailed" GetSynopsisInfoFailed
        // "ObjectNumberExceedLimit" ObjectNumberExceedLimit
        // "RebuildBackgroudFailed" RebuildBackgroudFailed
        // "NotExistMiddleFile" NotExistMiddleFile
        // "NotExistSourceFile" NotExistSourceFile
        // "NotDog" NotDog
        // "NotEnoughFreeDisk" NotEnoughFreeDisk
        // "StartDecodeFail"StartDecodeFail
        // "DecodeTimeOut" DecodeTimeOut
        // "EncodeTimeOut" EncodeTimeOut
        // "ExactTimeOut" ExactTimeOut
        // "ReadMidlleFileFail" ReadMidlleFileFail
        // "ExactPictureFail" ExactPictureFail
    }NET_VSTASK_INFO;
    
    // each object in the synopsis video task info
    typedef struct tagNET_VSOBJECT_INFO
    {
        DWORD				dwSize;			                // size
        DWORD				dwTaskID;		                // task ID
        DH_MSG_OBJECT		stuObjInfo;		                // object info
        NET_FILEPATH_INFO	stuFilePathInfo;                // file info
        DWORD				dwFileLength;	                // file length
    }NET_VSOBJECT_INFO;
    
    //--CLIENT_QueryVideoSynopsisInfo's interface output define
    typedef struct tagNET_OUT_QUERY_VIDEOSYNOPSIS
    {
        DWORD	            dwSize;			                // size
        DWORD	            dwTotalCount;	                // total count
        DWORD            	dwFoundCount;	                // found count
        void*	            pResult;                		// return result info
        // if emQueryType==EM_VIDEOSYNOPSIS_TASK,corresponding to NET_VSTASK_INFO
        // if emQueryType==EM_VIDEOSYNOPSIS_OBJ,corresponding to NET_VSOBJECT_INFO
        DWORD	            dwMaxCount;		                // hope tp get the number
    }NET_OUT_QUERY_VIDEOSYNOPSIS;
    
    // CLIENT_FindSynopsisFile's interface define
    // query type of file
    typedef enum tagNET_EM_QUERY_SYNOPSIS_FILE
    {
        DH_FILE_QUERY_VIDEO,                                // normal record file info,corresponding to:NET_SYNOPSIS_QUERY_VIDEO_PARAM, return result:NET_SYNOPSISFILE_VIDEO_INFO
        DH_FILE_QUERY_SYNOPSISVIDEO,                        // synopsis video file,corresponding to:NET_QUERY_SYNOPSISVIDEO_PARAM,return result:NET_QUERY_SYNOPSISVIDEO_INFO
    }NET_EM_QUERY_SYNOPSIS_FILE;
    
    typedef struct __NET_SYNOPSIS_QUERY_VIDEO_PARAM
    {
        DWORD               dwSize;
        DWORD				dwQueryMask;					// query type mask, according to from low to high,the first bit is period of time, the second is file path
        NET_TIME			stuStartTime;					// start time
        NET_TIME			stuEndTime;						// end time
        char				szFilePath[DH_MAX_SYNOPSIS_QUERY_FILE_COUNT][MAX_PATH];	// file path
        DWORD				dwFileCount;					// file count
    }NET_SYNOPSIS_QUERY_VIDEO_PARAM;
    
    typedef struct
    {
        DWORD               dwSize;
        int                 nTaskId;                        // taskID
        DWORD               dwOutPutTypeMask;               // output type in current,the first bit is snapshot,the second bit is synopsis video
        char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // current state
    }NET_VIDEOSYNOPSIS_TASK_INFO;
    
    // DH_FILE_QUERY_VIDEO return video file info
    typedef struct
    {
        DWORD               dwSize;
        unsigned int		nchannelId;						// channel ID
        char				szFilePath[MAX_PATH];		    // file path
        unsigned int		nFileLenth;					    // file lenth(byte)
        NET_TIME			stuStarttime;				    // start time
        NET_TIME			stuEndtime;				        // end time
        unsigned int		nWorkDirSN;				        // work dir SN
        unsigned int        nCluster;                       // cluster
        BYTE                bHint;					        // hint
        BYTE                bDriveNo;                       // drive no.
        BYTE                bReserved[18];                  // reserved
        
        int                 nTaskInfoNum;                   // task info number
        NET_VIDEOSYNOPSIS_TASK_INFO stuTaskInfo[16];        // video synopsis task info
    }NET_SYNOPSISFILE_VIDEO_INFO;
    
    // DH_FILE_QUERY_SYNOPSISVIDEO synopsis viedo file query param
    typedef struct __NET_QUERY_SYNOPSISVIDEO_PARAM
    {
        DWORD               dwSize;
        int                 nTaskID;                        // taskID
    }NET_QUERY_SYNOPSISVIDEO_PARAM;
    
    // DH_FILE_QUERY_SYNOPSISVIDEO query result
    typedef struct __NET_QUERY_SYNOPSISVIDEO_INFO
    {
        DWORD               dwSize;
        char				szFilePath[MAX_PATH];        	// file path
        unsigned int		nFileLenth;					    // file lenth
        int                 nDurationTime;                  // duration time(s)
    }NET_QUERY_SYNOPSISVIDEO_INFO;
    
    // CLIENT_FindSynopsisFile's interface param
    typedef struct tagNET_IN_FIND_SYNOPSISFILE
    {
        DWORD               dwSize;
        NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
        void*               pQueryCondition;                // query's type
        int                 nWaitTime;                      // wait time(ms)
    }NET_IN_FIND_SYNOPSISFILE;
    
    typedef struct tagNET_OUT_FIND_SYNOPSISFILE
    {
        DWORD               dwSize;
        LLONG               lFindHandle;                    // find handle
    }NET_OUT_FIND_SYNOPSISFILE;
    
    // CLIENT_FindNextSynopsisFile's interface param
    typedef struct tagNET_IN_FINDNEXT_SYNOPSISFILE
    {
        DWORD               dwSize;
        int                 nFileCount;                     // count of file
        NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
        void*               pSynopsisFileInfo;              // info of file buf
        int                 nMaxlen;                        // size of buf
        int                 nWaitTime;                      // wait time(ms)
    }NET_IN_FINDNEXT_SYNOPSISFILE;
    
    typedef struct tagNET_OUT_FINDNEXT_SYNOPSISFILE
    {
        DWORD               dwSize;
        int                 nRetFileCount;                  // the actual return information artucle number,return<nFileCount(input param) corresponding period of the finished file query
    }NET_OUT_FINDNEXT_SYNOPSISFILE;
    
    // download progress's callback,nError means downloading appear error,1 - cashe is insufficient,2-data validation error,3.download failed,4,create file failed
    typedef void (CALLBACK *fSynopsisFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwFileID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);
    
    // CLIENT_DownLoadSynosisFile's interface param
    typedef  NET_DOWNLOADFILE_INFO NET_SYNOPSIS_DOWNLOADFILE_INFO;
    
    typedef struct tagNET_IN_DOWNLOAD_SYNOPSISFILE
    {
        DWORD               dwSize;
        int                 nFileCount;                     // count of file
        NET_SYNOPSIS_DOWNLOADFILE_INFO* pFileInfos;         // file info
        fSynopsisFileDownLoadPosCB cbPosCallBack;           // post of callback function
        LDWORD              dwUserData;                     // user's data
        int                 nWaitTime;                      // wait time(ms)
    }NET_IN_DOWNLOAD_SYNOPSISFILE;
    
    typedef struct tagNET_OUT_DOWNLOAD_SYNOPSISFILE
    {
        DWORD               dwSize;
        LLONG               lDownLoadHandle;                // handle of download
    }NET_OUT_DOWNLOAD_SYNOPSISFILE;
    
    // path of file's info
    typedef struct	tagNET_SET_FILEPATH_INFO
    {
        DWORD		        dwSize;
        char		        szFilePath[MAX_PATH];	        // can be a folder ,can be the file,current server only supports the dav format file
    }NET_SET_FILEPATH_INFO;
    
    // CLIENT_SetFilePathInfo()interface input param
    typedef struct tagNET_IN_SET_FILEPATHINFO
    {
        DWORD		        dwSize;
        DWORD		        dwCount;		                // count of added file
        void*	        	pFilePathInfo;                	// look for NET_SET_FILEPATH_INFO
        DWORD		        dwWaitTime;		                // wait time(ms)
    }NET_IN_SET_FILEPATHINFO;
    
    
    // fAddFileStateCB param
    typedef struct tagNET_CB_ADDFILESTATE
    {
        DWORD		        dwSize;
        const char*         szFileName;                     // file name
        const char*         szState;                        // analyse file's state, "Successed" ; "Failed" ;
    }NET_CB_ADDFILESTATE;
    
    // burning device callback function, pBuf->dwSize == nBufLen
    typedef void (CALLBACK *fAddFileStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_ADDFILESTATE* pBuf,  int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttacAddFileState()interface input param
    typedef struct tagNET_IN_ADDFILE_STATE
    {
        DWORD		        dwSize;
        fAddFileStateCB     cbAttachState;                 // listenint to increase callback file state
        LDWORD              dwUser;                        // user's data
    }NET_IN_ADDFILE_STATE;
    typedef struct tagNET_OUT_ADDFILE_STATE
    {
        DWORD		        dwSize;
    }NET_OUT_ADDFILE_STATE;
    
    ///////////////////////////////////Face recognition module related structures///////////////////////////////////////
    
    // CLIENT_OperateFaceRecognitionDBInterface input parameters
    typedef struct __NET_IN_OPERATE_FACERECONGNITIONDB
    {
        DWORD             dwSize;
        EM_OPERATE_FACERECONGNITIONDB_TYPE emOperateType;  // Type of operation
        FACERECOGNITION_PERSON_INFO        stPersonInfo;   // Personnel information
        
        // Picture binary data
        char                *pBuffer;                      // Buffer address
        int                 nBufferLen;                    // Buffer data length
    }NET_IN_OPERATE_FACERECONGNITIONDB;
    
    // CLIENT_OperateFaceRecognitionDB port output parameter
    typedef struct __NET_OUT_OPERATE_FACERECONGNITIONDB
    {
        DWORD               dwSize;
    }NET_OUT_OPERATE_FACERECONGNITIONDB;
    
    typedef struct __NET_FACE_MATCH_OPTIONS
    {
        DWORD               dwSize;
        unsigned int        nMatchImportant;               // Important level 1 to 10 staff, the higher the number the more important (check important level greater than or equal to this level of staff)
        EM_FACE_COMPARE_MODE emMode;                       // Face comparison mode, see EM_FACE_COMPARE_MODE
        int                 nAreaNum;                      // Face the number of regional
        EM_FACE_AREA_TYPE   szAreas[MAX_FACE_AREA_NUM];    // Regional groupings of people face is NET_FACE_COMPARE_MODE_AREA effective when emMode
        int                 nAccuracy;                     // Recognition accuracy (ranging from 1 to 10, with the value increases, the detection accuracy is improved, the detection rate of decline. Minimum value of 1 indicates the detection speed priority, the maximum is 10, said detection accuracy preferred. Temporarily valid only for face detection)
        int                 nSimilarity;                   // Similarity (must be greater than the degree of acquaintance before the report; expressed as a percentage, from 1 to 100)
        int                 nMaxCandidate;                 // Reported the largest number of candidate (based on similarity to sort candidates to take the maximum number of similarity report)
        
    }NET_FACE_MATCH_OPTIONS;
    
    typedef struct __NET_FACE_FILTER_CONDTION
    {
        DWORD               dwSize;
        NET_TIME			stStartTime;			       // Start time
        NET_TIME			stEndTime;				       // End Time
        char                szMachineAddress[MAX_PATH];    // Place to support fuzzy matching
        int                 nRangeNum;                     // The actual number of database
        BYTE                szRange[MAX_FACE_DB_NUM];      // To query the database type, see EM_FACE_DB_TYPE
        EM_FACERECOGNITION_FACE_TYPE emFaceType;           // Face to query types, see EM_FACERECOGNITION
        int                 nGroupIdNum;                   // staff group
        char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID
    }NET_FACE_FILTER_CONDTION;
    // CLIENT_StartFindFaceRecognitionInterface input parameters
    typedef struct __NET_IN_STARTFIND_FACERECONGNITION
    {
        DWORD               dwSize;
        BOOL                bPersonEnable;                 // Personnel information query is valid
        FACERECOGNITION_PERSON_INFO stPerson;              // Personnel information query
        NET_FACE_MATCH_OPTIONS stMatchOptions;             // Face Matching Options
        NET_FACE_FILTER_CONDTION stFilterInfo;             // Query filters
        
        // Picture binary data
        char                *pBuffer;                      // Buffer address
        int                 nBufferLen;                    //Buffer data length
        
        int                 nChannelID;                    // Channel ID
    }NET_IN_STARTFIND_FACERECONGNITION;
    
    // CLIENT_StartFindFaceRecognitionInterface output parameters
    typedef struct __NET_OUT_STARTFIND_FACERECONGNITION
    {
        DWORD               dwSize;
        int                 nTotalCount;                   // Record number of returns that match the query criteria
        LLONG               lFindHandle;                   // Query handle
    }NET_OUT_STARTFIND_FACERECONGNITION;
    
#define MAX_FIND_COUNT  20
    
    // CLIENT_DoFindFaceRecognition Interface input parameters
    typedef struct __NET_IN_DOFIND_FACERECONGNITION
    {
        DWORD               dwSize;
        LLONG               lFindHandle;                   // Query handle
        int                 nBeginNum;                     // Queries starting serial number
        int                 nCount;                        // The current number of records you want to search for
    }NET_IN_DOFIND_FACERECONGNITION;
    
    // CLIENT_DoFindFaceRecognitionInterface output parameters
    typedef struct __NET_OUT_FINDNEXT_FACERECONGNITION
    {
        DWORD               dwSize;
        int                 nCadidateNum;                  // The actual number of candidate information structure returned
        CANDIDATE_INFO      stCadidateInfo[MAX_FIND_COUNT];// An array of candidate information
        
        // Picture binary data
        char                *pBuffer;                      // Buffer address
        int                 nBufferLen;                    // Buffer data length
    }NET_OUT_DOFIND_FACERECONGNITION;
    
    // CLIENT_DetectFaceInterface input parameters
    typedef struct __NET_IN_DETECT_FACE
    {
        DWORD               dwSize;
        DH_PIC_INFO         stPicInfo;                     // Big picture information
        
        // Picture binary data
        char                *pBuffer;                      // Buffer address
        int                 nBufferLen;                    // Buffer data length
    }NET_IN_DETECT_FACE;
    
    // CLIENT_DetectFaceInterface output parameters
    typedef struct __NET_OUT_DETECT_FACE
    {
        DWORD               dwSize;
        DH_PIC_INFO         *pPicInfo;                     // The detected face image information from the user space applications
        int                 nMaxPicNum;                    // The maximum number of face image information
        int                 nRetPicNum;                    // The actual number of returning faces pictures
        
        // Picture binary data
        char                *pBuffer;                      // Buffer address, the user application space to store the detected face image data
        int                 nBufferLen;                    // Buffer data length
    }NET_OUT_DETECT_FACE;
    
    // staff group operation enumeration
    typedef enum tagEM_OPERATE_FACERECONGNITION_GROUP_TYPE
    {
        NET_FACERECONGNITION_GROUP_UNKOWN,
        NET_FACERECONGNITION_GROUP_ADD,           // add staff group info
        NET_FACERECONGNITION_GROUP_MODIFY,         // modify staff group info
        NET_FACERECONGNITION_GROUP_DELETE,         // delete staff group info
    }EM_OPERATE_FACERECONGNITION_GROUP_TYPE;
    
    // staff group info
    typedef struct tagNET_FACERECONGNITION_GROUP_INFO
    {
        DWORD        dwSize;
        EM_FACE_DB_TYPE   emFaceDBType;         // staff group type ?? see  EM_FACE_DB_TYPE
        char        szGroupId[DH_COMMON_STRING_64];// staff group ID??SN(cannot modify, invalid when adding operation)
        char        szGroupName[DH_COMMON_STRING_128]; // staff operation name
        char        szGroupRemarks[DH_COMMON_STRING_256]; // staff group note info
        int         nGroupSize;          //  current group staff number
    }NET_FACERECONGNITION_GROUP_INFO;
    
    // add staff group info
    typedef struct tagNET_ADD_FACERECONGNITION_GROUP_INFO
    {
        DWORD        dwSize;
        NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info
    }NET_ADD_FACERECONGNITION_GROUP_INFO;
    
    // delete staff group info
    typedef struct tagNET_DELETE_FACERECONGNITION_GROUP_INFO
    {
        DWORD        dwSize;
        char        szGroupId[DH_COMMON_STRING_64];// staff group ID??SN staff
    }NET_DELETE_FACERECONGNITION_GROUP_INFO;
    
    // modify staff group info
    typedef struct tagNET_MODIFY_FACERECONGNITION_GROUP_INFO
    {
        DWORD        dwSize;
        NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info
    }NET_MODIFY_FACERECONGNITION_GROUP_INFO;
    
    // CLIENT_OperateFaceRecognitionGroup port input parameter
    typedef struct tagNET_IN_OPERATE_FACERECONGNITION_GROUP
    {
        DWORD        dwSize;
        EM_OPERATE_FACERECONGNITION_GROUP_TYPE emOperateType; // operation type
        void        *pOPerateInfo;         // operation info
    }NET_IN_OPERATE_FACERECONGNITION_GROUP;
    
    // CLIENT_OperateFaceRecognitionGroup port output parameter
    typedef struct tagNET_OUT_OPERATE_FACERECONGNITION_GROUP
    {
        DWORD        dwSize;
        char        szGroupId[DH_COMMON_STRING_64]; // new record staff group ID??SN staff
    }NET_OUT_OPERATE_FACERECONGNITION_GROUP;
    
    // CLIENT_FindGroupInfo port input parameter
    typedef struct tagNET_IN_FIND_GROUP_INFO
    {
        DWORD        dwSize;
        char        szGroupId[DH_COMMON_STRING_64];// staff ID??SN staff, as null means search all staff group info
    }NET_IN_FIND_GROUP_INFO;
    
    // CLIENT_FindGroupInfo port output parameter
    typedef struct tagNET_OUT_FIND_GROUP_INFO
    {
        DWORD        dwSize;
        NET_FACERECONGNITION_GROUP_INFO *pGroupInfos;   // staff group info ??apply space by user
        int         nMaxGroupNum;         //  current applied group size
        int         nRetGroupNum;         // device returned staff group number
    }NET_OUT_FIND_GROUP_INFO;
    
    
    // CLIENT_SetGroupInfoForChannel port input parameter
    typedef struct tagNET_IN_SET_GROUPINFO_FOR_CHANNEL
    {
        DWORD        dwSize;
        int         nChannelID;          // channel no.
        int         nGroupIdNum;          // staff group
        char        szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID
    }NET_IN_SET_GROUPINFO_FOR_CHANNEL;
    // CLIENT_SetGroupInfoForChannel port output parameter
    typedef struct tagNET_OUT_SET_GROUPINFO_FOR_CHANNEL
    {
        DWORD        dwSize;
    }NET_OUT_SET_GROUPINFO_FOR_CHANNEL;
    
    // CLIENT_FaceRecognitionSetSearchImageInfo
    typedef struct tagNET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
    {
        DWORD               dwSize;
        int                 nChannel;                           // Channel ID
        char                szFilePath[DH_COMMON_STRING_256];   // File path
    }NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;
    // CLIENT_FaceRecognitionSetSearchImageInfo
    typedef struct tagNET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
    {
        DWORD                dwSize;
    }NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;
    //////////////////////////////// burn the upload////////////////////////////////
    
    // fBurnCheckCallBack Parameter
    typedef struct tagNET_CB_BURN_CHECK_STATE
    {
        DWORD		        dwSize;
        const char*         szType;							// Message Type
        // "Checking": Check in
        // "CheckResult": CheckResult
        BOOL				bCheckResult;					// Calibration results for "CheckResult", TRUE-success, FALSE-failure
        BYTE				byProgress;						// Calibration schedule for "Checking", the percentage of 0 to 100
        BYTE				reserved[3];
    } NET_CB_BURN_CHECK_STATE;
    
    // Burn verification callback function prototype, lAttachHandle return value is CLIENT_AttachBurnCheckState
    typedef void (CALLBACK *fBurnCheckCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURN_CHECK_STATE* pstState, void* reserved, LDWORD dwUser);
    
    // CLIENT_AttachBurnCheckState Input parameter interface (monitor burn parity status)
    typedef struct tagNET_IN_ATTACH_BURN_CHECK
    {
        DWORD				dwSize;
        fBurnCheckCallBack  cbBurnCheck;					// Burn verification callback
        LDWORD              dwUser;							// User data
    } NET_IN_ATTACH_BURN_CHECK;
    
    // CLIENT_AttachBurnCheckState Output parameters of the interface (listening burning parity status)
    typedef struct tagNET_OUT_ATTACH_BURN_CHECK
    {
        DWORD            dwSize;
    } NET_OUT_ATTACH_BURN_CHECK;
    
    ///////////////////////////////// logical device /////////////////////////////////
    
    typedef struct tagNET_CB_CAMERASTATE
    {
        DWORD		        dwSize;
        int                 nChannel;             // channel
        CONNECT_STATE       emConnectState;       // state of connect
    }NET_CB_CAMERASTATE;
    
    // CLIENT_AttachCameraState()callback function, pBuf->dwSize == nBufLen
    typedef void (CALLBACK *fCameraStateCallBack) (LLONG lLoginID, LLONG lAttachHandle, const NET_CB_CAMERASTATE *pBuf, int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttachCameraState()input param
    typedef struct tagNET_IN_CAMERASTATE
    {
        DWORD		        dwSize;
        int *               pChannels;             // observation of the channel, if the value = -1,is boservate all channel
        int                 nChannels;             // length of pChannels pointer
        fCameraStateCallBack cbCamera;             // state of callback function
        LDWORD				dwUser;                // user's data
    }NET_IN_CAMERASTATE;
    typedef struct tagNET_OUT_CAMERASTATE
    {
        DWORD		        dwSize;
    }NET_OUT_CAMERASTATE;
    
    ////////////////////////////////Special version/////////////////////////////////
    
    // Activate device to snapshot overlay card number information
    typedef struct __NET_SNAP_COMMANDINFO
    {
        char				szCardInfo[16];			// Card information
        char				reserved[64];			// Reserved
    } NET_SNAP_COMMANDINFO, LPNET_SNAP_COMMANDINFO;
    
    typedef struct
    {
        int					nChannelNum;			// Channel number
        char				szUseType[32];			// Channel type
        DWORD				dwStreamSize;			// Stream size(Unit:kb/s)
        char				reserved[32];			// Reserved
    } DHDEV_USE_CHANNEL_STATE;
    
    typedef struct
    {
        char				szUserName[32];			// User name
        char				szUserGroup[32];		// User group
        NET_TIME			time;					// Log in time
        int					nOpenedChannelNum;		// Enabled channel amount
        DHDEV_USE_CHANNEL_STATE	channelInfo[DH_MAX_CHANNUM];
        char                szIpAddress[DH_MAX_IPADDR_LEN_EX];  // ip
        char                reserved[24];
    } DHDEV_USER_NET_INFO;
    
    // Network running status information
    typedef	struct
    {
        int					nUserCount;				// User amount
        DHDEV_USER_NET_INFO	stuUserInfo[32];
        char				reserved[256];
    }DHDEV_TOTAL_NET_STATE;
    
    typedef struct
    {
        char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
        char                szUserGroup[32];                 // User Group
        char                szUserName[32];                  // User Name
        char                reserved[64];
    }DHDEV_USER_REJECT_INFO;
    
    // Reject User
    typedef struct
    {
        int                       nUserCount;				// User Account
        DHDEV_USER_REJECT_INFO    stuUserInfo[10];
        char				      reserved[256];
    }DHDEV_REJECT_USER;
    
    typedef struct
    {
        char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
        char                szUserGroup[32];                 // User Group
        char                szUserName[32];                  // User Name
        int                 nForbiddenTime;                  // Forbidden Time
        char                reserved[64];
    }DHDEV_USER_SHIELD_INFO;
    
    // Shield User
    typedef struct
    {
        int                       nUserCount;          // User Account
        DHDEV_USER_SHIELD_INFO    stuUserInfo[10];
        char				      reserved[256];
    }DHDEV_SHIELD_USER;
    
    // longitude latitude
    typedef struct
    {//  longitude first,then latitude
        char                chPreLogi;        // preflag of longitude:N(north),S(south),W(west),E(east)
        char                chPreLati;        // preflag of latitude:N(north),S(south),W(west),E(east)
        BYTE                reserved[6];      //
        double              dbLongitude;      // longitude
        double              dbLatitude;       // latitude
    }DHDEV_LONGI_LATI;
    
    // NAVIGATION OR SMS
    typedef struct
    {
        char                szPhoneNum[DH_MAX_PHONE_NO_LEN];    // phone no
        NET_TIME            stMsgTime;                          // time of sending message
        char                szMsgType[DH_MAX_MSGTYPE_LEN];      // type:Navigation message-Navigation,short message--SMS
        char                szSmsContext[DH_MAX_MSG_LEN];       // message to send
        
        DHDEV_LONGI_LATI    stLogiLati;                         // longitude
        unsigned int        uFlag;                              // 01:marking true longitude
        char                szNavigationType[16];               // TNC,TXZ
        char                szAddress[32];                      // address
        char                szNavigationMode[32];               // mode
        DHDEV_LONGI_LATI    stPassLogiLati[5];                  // passing
        DHDEV_LONGI_LATI    stNoPassLogiLati[5];                // no passing
        BYTE				reserved[256];
    }DHDEV_NAVIGATION_SMSS;
    
    // Image watermark setup
    typedef struct __DHDEV_WATERMAKE_CFG
    {
        DWORD				dwSize;
        int					nEnable;				// Enable
        int					nStream;				// Bit stream(1~n)0- All bit streams
        int					nKey;					// Data type(1- text,2- image )
        char				szLetterData[DH_MAX_WATERMAKE_LETTER];	// text
        char				szData[DH_MAX_WATERMAKE_DATA]; // Image data
        BYTE				bReserved[512];			// Reserved
    } DHDEV_WATERMAKE_CFG;
    
    // Storage position set structure.  Each channel set separately.Each channel can set several storage types including local,portableand remote storage.
    typedef struct
    {
        DWORD				dwSize;
        DWORD				dwLocalMask;			// Local storage mask. Use bit to represent.
        // The first bit:system pre-record. The second bit:scheduled record. The third bit:motion detection record.
        // The fourth bit:alarm record. The fifth bit:card record. The sixth bit:manual record.
        DWORD				dwMobileMask;			// Moving storage mask. Storage mask such as local storage mask.
        int					RemoteType;				// Remote storage type 0: Ftp  1: Smb
        DWORD				dwRemoteMask;			// Remote storage mask.  Storage mask such as local storage mask.
        DWORD				dwRemoteSecondSelLocal;	// Local storage mask when remote is abnormal
        DWORD				dwRemoteSecondSelMobile;// Moving storage mask when remote is abnormal.
        char				SubRemotePath[MAX_PATH_STOR]; // Remote path. Its length is 240
        DWORD				dwFunctionMask;			// Function shield bit. Use bit to represent bit0 = 1:Shield sanpshot event activate storage position function.
        DWORD				dwAutoSyncMask;			// If synchronous mask; after remote storage network recovery, the local storage data will automatically synchronized to the remote storage.
        BYTE				bAutoSyncRange;			// the time for synchronous from the network synchronous time. In hour. 0:all data  1:data in one hour n:data in n hours
        char				reserved[119];
    } DH_STORAGE_STATION_CFG;
    
#define MAX_ALARM_DECODER_NUM 16
    typedef struct
    {
        DWORD				dwAlarmDecoder;			// Now it supports max 8 alarm input ports. Reserved 8 bits for future development.
        BYTE				bDecoderIndex;			// It means it is from which alarm decoder.
        BYTE				bReserved[3];
    } ALARM_DECODER;
    
    // Alarm decoder alarm
    typedef struct
    {
        int					nAlarmDecoderNum;
        ALARM_DECODER		stuAlarmDecoder[MAX_ALARM_DECODER_NUM];
        BYTE				bReserved[32];
    } ALARM_DECODER_ALARM;
    
    //DSP alarm
    typedef struct
    {
        BOOL				bError;			//0,DSP normal 1,DSP abnormal
        DWORD				dwErrorMask;	//Bit shows,Nor 0 shows havening this error,0 shows no.(Now alarm has only 1 bit valid)
        //bit		DSP alarm
        //1			DSP downloading failure
        //2			DSP error
        //3			Format not correct
        //4			Resolution not support
        //5			Data format not support
        //6			Can't find I frame
        DWORD               dwDecChnnelMask;//Bit shows,alarm decoding channel number,dwErrorMask is DSP fault,incorrect format,incorrect resolution,data format not support
        DWORD               dwDecChnnelMask1;//Bit shows,33-64 is alarm of decoding channel, dwErrorMask is DSP mistake,format is wrong, effective when not support resolution or data format
        BYTE				bReserved[24];
    } DSP_ALARM;
    
    // Fiber-optic alarm
    typedef struct
    {
        int		nFDDINum;
        BYTE	bAlarm[256];
    } ALARM_FDDI_ALARM;
    
#define ALARM_PTZ_LOCATION_INFO DH_PTZ_LOCATION_INFO
    
    // New audio detection alarm setup
    typedef struct
    {
        BOOL				bEnable;				// Enable alarm input
        int					Volume_min;				// Min volume
        int					Volume_max;				// Max volume
        char				reserved[128];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
        DH_MSG_HANDLE		struHandle;				// Process way
    } DH_AUDIO_DETECT_INFO;
    
    typedef struct
    {
        DWORD				dwSize;
        int					AlarmNum;
        DH_AUDIO_DETECT_INFO AudioDetectAlarm[DH_MAX_AUDIO_IN_NUM];
        char				reserved[256];
    } DH_AUDIO_DETECT_CFG;
    
    typedef struct
    {
        BOOL				bTourEnable;			// Enable tour
        int					nTourPeriod;			// Tour interval. Unit is second. The value ranges from 5 to 300
        DWORD				dwChannelMask;			// Tour channel. Use mas bit to represent.
        char				reserved[64];
    }DH_VIDEOGROUP_CFG;
    
    // Local matrix control strategy setup
    typedef struct
    {
        DWORD				dwSize;
        int					nMatrixNum;				// Matrix amount(Read only )
        DH_VIDEOGROUP_CFG	struVideoGroup[DH_MATRIX_MAXOUT];
        char				reserved[32];
    } DHDEV_VIDEO_MATRIX_CFG;
    
    // WEB path setup
    typedef struct
    {
        DWORD				dwSize;
        BOOL				bSnapEnable;					// Snapshot or not
        int					iSnapInterval;					// Snapshot interval
        char				szHostIp[DH_MAX_IPADDR_LEN];	// HTTP host IP
        WORD				wHostPort;
        int					iMsgInterval;					// Message sending out interval
        char				szUrlState[DH_MAX_URL_LEN];		// Status message upload URL
        char				szUrlImage[DH_MAX_URL_LEN];		// Image upload Url
        char				szDevId[DH_MAX_DEV_ID_LEN];		// Device web serial number
        BYTE				byReserved[2];
    } DHDEV_URL_CFG;
    
    // OEM search
    typedef struct
    {
        char				szVendor[DH_MAX_STRING_LEN];
        char				szType[DH_MAX_STRING_LEN];
        char				reserved[128];
    } DHDEV_OEM_INFO;
    
    
    //Video OSD
    typedef struct
    {
        DWORD	rgbaFrontground;		// Object front view. Use bit to represent:red,green, blue and transparency.
        DWORD	rgbaBackground;			// Object background. Use bit to represent:red,green, blue and transparency
        RECT	rcRelativePos;			// Position. The proportion of border distance and whole length *8191
        BOOL	bPreviewBlend;			// Enable preview overlay
        BOOL	bEncodeBlend;			// Enable encode overlay
        BYTE    bReserved[4];           // Reserved
    } DH_DVR_VIDEO_WIDGET;
    
    typedef struct
    {
        DH_DVR_VIDEO_WIDGET	StOSD_POS; 								// OSD position and background color.
        char 				SzOSD_Name[DH_VIDEO_OSD_NAME_NUM]; 		// OSD name
    }DH_DVR_VIDEOITEM;
    
    // OSD information in each channel
    typedef struct
    {
        DWORD 				dwSize;
        DH_DVR_VIDEOITEM 	StOSDTitleOpt [DH_VIDEO_CUSTOM_OSD_NUM];// Each channel OSD information
        BYTE    			bReserved[16];							// Reserved
    } DH_DVR_VIDEOOSD_CFG;
    
    // CDMA/GPRS Configuration
    // Time structure
    typedef struct
    {
        BYTE				bEnable;					// Time period enable,1 shows this time period valid,0 shows invalid.
        BYTE				bBeginHour;
        BYTE				bBeginMin;
        BYTE				bBeginSec;
        BYTE				bEndHour;
        BYTE				bEndMin;
        BYTE				bEndSec;
        BYTE    			bReserved;					//Reserved
    } DH_3G_TIMESECT, *LPDH_3G_TIMESECT;
    
    typedef struct
    {
        DWORD 				dwSize;
        BOOL				bEnable;					// Wireless module enable
        DWORD               dwTypeMask;                 // Network type mask;Use bit to represent,The first bit:Automatic selection
        // The second bit:TD-SCDMA network;The third bit:WCDMA network;
        // The fourth bit:CDMA 1.x network;The fifth bit:GPRS network;The sixth bit:EVDO network
        // The seventh bit:EVDO network;The eighth bit:WIFI network;
        DWORD               dwNetType;                  // Types of wireless networks,EM_GPRSCDMA_NETWORK_TYPE
        char				szAPN[128];					// Access Point Name
        char				szDialNum[128];				// Dial-up number
        char				szUserName[128];			// Dial-up user name
        char				szPWD[128];					// Dial-up Password
        
        /* Read-only part */
        BOOL				iAccessStat;				// Wireless network registration status
        char				szDevIP[16];				// dial-up IP of Front-end equipment
        char				szSubNetMask [16];			// Dial-up mask of Front-end equipment
        char				szGateWay[16];				// Dial-up Gateway of Front-end equipment
        
        int                 iKeepLive;					// Keep-alive time
        DH_3G_TIMESECT		stSect[DH_N_WEEKS][DH_N_TSECT];// 3G dial period,valid time period,start dialing;beyond this period,shut the dial.
        BYTE                byActivate;                  //Whether need to be active by voice or message
        
        BYTE                bySimStat;                    //SIM(UIM) State: 1, 0 (read-only data) be occupied the 1 byte
        char                szIdentify[128];               // identify mode
        bool                bPPPEnable;                    // PPP Dial-up,0- cut down ppp connect,1-ppp dial-up
        BYTE                bPPPState;                     // PPP Dial-up statr(real only),see EM_MOBILE_PPP_STATE
        BYTE                bNetCardState;                 // net card state(read only),see EM_3GMOBILE_STATE
        char				szPhyCardNo[32];			  // physics card no.
        char				Reserved[4];				   // reserved
        BYTE				byPinShow;					// PIN show or not(read only), 0-don't support 1-show, 2-don't show
        BYTE				byPinEnable;				// PIN setting enable(read only), 0-disable, 1-enable
        BYTE				byPinCount;					// the rest of pin setting number(read only), 0~3
        //-------------------------------the following fields in setting up effective after dwSize------------------------------------
        char				szPinNo[16];				// value of PIN, a combination of letters or numbers
    } DHDEV_CDMAGPRS_CFG;
    
    // The length of the video package configuration
    typedef struct
    {
        DWORD 				dwSize;
        int					nType;						// 0:by time,1:by size
        int					nValue;						// nType = 0:(minutes),nType = 1:(KB)
        char				Reserved[128];				// Reserved
    } DHDEV_RECORD_PACKET_CFG;
    
    // (Directional)register the server information
    typedef struct __DEV_AUTOREGISTER_INFO
    {
        LONG			lConnectionID;					// Connection ID
        char			szServerIp[DH_MAX_IPADDR_LEN];	// Server IP
        int				nPort;							// Port:0- 65535
        int             nState;                         // Server status:0-Registration failure;1-Registration success; 2-Connection failed
        char			reserved[16];
    } DEV_AUTOREGISTER_INFO;
    
    typedef struct __DEV_SERVER_AUTOREGISTER
    {
        DWORD					dwSize;
        int						nRegisterSeverCount;									// Number of registered servers
        DEV_AUTOREGISTER_INFO	stuDevRegisterSeverInfo[DH_CONTROL_AUTO_REGISTER_NUM];	// Server information
        char					reserved[256];
    } DEV_SERVER_AUTOREGISTER, *LPDEV_SERVER_AUTOREGISTER;
    
    // Upload burning annex
    typedef struct
    {
        DWORD				dwSize;
        char				szSourFile[MAX_PATH_STOR];	// Source file path
        int					nFileSize;					// Source file size,If less than or equal to 0, sdk to calculate file size.
        char				szBurnFile[MAX_PATH_STOR];	// After burning the file name
        BYTE				bReserved[64];
    } DHDEV_BURNFILE_TRANS_CFG;
    
    // Update file upload
    typedef struct
    {
        char                 szFile[MAX_PATH_STOR];      // Update file path
        int                  nFileSize;                  // Update file size
        BYTE                 byChannelId;                // Channel No.
        BYTE                 byManufactryType;           // Manufacturer type    Please refer to EM_IPC_TYPE
        
        BYTE                 byReserved[126];            // Reserved
    }DHDEV_UPGRADE_FILE_INFO;
    
    // upload black-white list
    typedef struct
    {
        char                 szFile[MAX_PATH_STOR];     // path of file
        int                  nFileSize;                 // size of upgrade file
        BYTE                 byFileType;                // type of file.0-black list,1-white list
        BYTE                 byAction;                  // action,0-overload,1-additional
        
        BYTE                 byReserved[126];           // reserved
    }DHDEV_BLACKWHITE_LIST_INFO;
    
    // download black-white list
    typedef struct
    {
        char                 szFile[MAX_PATH_STOR];     // path of file
        BYTE                 byFileType;                // type of file,0-black list,1-white of list
        BYTE                 byReserved[127];           // reserved
    }DHDEV_LOAD_BLACKWHITE_LIST_INFO;
    // Zhengzhou EC_U video data overlay enabling configuration
    typedef struct
    {
        BOOL				bEnable;					// Enable
        int					nPort;						// Port
        BYTE				bReserved[64];
    }DHDEV_OSD_ENABLE_CFG;
    
    // about vehicle configuration
    typedef struct
    {
        BOOL				bAutoBootEnable;				//auto boot enable
        DWORD				dwAutoBootTime;					//auto boot time, Unit is second. The value ranges from 0 to 82800.
        BOOL				bAutoShutDownEnable;			//auto shut down enable
        DWORD				dwAutoShutDownTime;				//auto shut down time ,  Unit is second. The value ranges from 0 to 82800.
        DWORD				dwShutDownDelayTime;			//shut down delay time, Unit is second.
        BYTE				bEventNoDisk;					//1,(Ignore); 2,(Reboot)
        BYTE				bWifiEnable;					//If support car wifi module.
        BYTE				bUpperSpeedEnable;				//if use over speed verdict
        BYTE				bLowerSpeedEnable;				//if use low speed verdict
        DWORD				dwUpperSpeedValue;				//Over speed area(1,1000).km/hour.
        DWORD               dwLowerSpeedValue;              //Low speed area(1,1000).km/hour.
        DWORD               dwUpperSpeedDelayTime;          //Upper Speed Delay Time
        DWORD               dwLowerSpeedDelayTime;          //Lower Speed Delay Time
        DWORD               dwAlarmMaskEnable;              //Search/set OSD alarm information enable, every bit present one external alarm channel, 0:close;1:open
        BOOL                bSpeedOverAlarmRecordEnable;    // Over Speed Alarm Record Enable
        BOOL                bSpeedLowAlarmRecordEnable;     // Low Speed Alarm Record Enable
        BYTE				bReserved[480];					//reserved byte.
    } DHDEV_ABOUT_VEHICLE_CFG;
    
    // atm: query overlay ability information
    typedef struct
    {
        DWORD				dwDataSource;					//1:Network, 2:Comm, 3:Network&Comm
        char				szProtocol[32][33];				//protocol name
        BYTE				bReserved[256];
    } DHDEV_ATM_OVERLAY_GENERAL;
    
    // atm: overlay configuration
    typedef struct
    {
        DWORD				dwDataSource;					// 1:Network, 2:Comm
        char				szProtocol[33];					// protocol name, from DHDEV_ATM_OVERLAY_GENERAL
        BYTE				bReserved_1[3];
        DWORD				dwChannelMask;					// channel mask
        BYTE				bMode;							// 1:Preview, 2:Encode, 3:Preview&Encode
        BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom, 3:RightTop, 4:RightBottom
        BYTE                bReserved_3[2];
        int                 nLatchTime;                     // display latch time on overlay, instruct the video's close latch time, 0~65535
        BYTE                bReserved_4[3];
        BYTE                bRecordSrcKeyNum;               // key number
        int                 nRecordSrcKey[32];              // key of channels
        BYTE				bReserved_2[120];
    } DHDEV_ATM_OVERLAY_CONFIG;
    
    // atm:overlay set configuration
    typedef struct
    {
        DWORD               dwSize;                         // size
        DWORD				dwDataSource;					// 1:Net, 2:Com, 3:Com422
        char				szProtocol[33];					// protocol name
        BYTE				bReserved_1[3];
        DWORD				dwChannelMask[8];				// overlay channel,the mask means: dwChannelMask[0] is channel 1,so on
        BYTE				bMode;							// 1:Preview(preview), 2:Encode(encode), 3:Preview&Encode(preview and encode)
        BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom , 3:RightTop , 4:RightBottom
        BYTE                bReserved_3[2];
        int                 nLatchTime;                     // latch time,0~65535s
        BYTE                bReserved_4[3];
        BYTE                bRecordSrcKeyNum;               // number of key word
        int                 nRecordSrcKey[256];             // key word
    } DHDEV_ATM_OVERLAY_CONFIG_EX;
#define DH_MAX_BACKUPDEV_NUM			16
#define DH_MAX_BACKUP_NAME				32
    
    // backup device list
    typedef struct
    {
        int					nBackupDevNum;												// number of backup devices
        char				szBackupDevNames[DH_MAX_BACKUPDEV_NUM][DH_MAX_BACKUP_NAME]; // backup device name
    } DHDEV_BACKUP_LIST, *LPDHDEV_BACKUP_LIST;
    
    // backup device type
    typedef enum __BACKUP_TYPE
    {
        BT_DHFS = 0,							// dvr file system
        BT_DISK,								// floating disk
        BT_CDRW									// CD
    } DHDEV_BACKUP_TYPE;
    
    // backup device interface
    typedef enum __BACKUP_BUS
    {
        BB_USB = 0,								// usb
        BB_1394,								// 1394
        BB_IDE,									// ide
        BB_ESATA,								// esata
    } DHDEV_BACKUP_BUS;
    
    typedef struct
    {
        char				szName[32];						// name
        BYTE				byType;							// see BACKUP_TYPE
        BYTE				byBus;							// see BACKUP_BUS
        UINT				nCapability;					// total capability(kBytes)
        UINT				nRemain;						// remain capability(kBytes)
        char				szDirectory[128];				// Remote Directory
    } DHDEV_BACKUP_INFO, *LPDHDEV_BACKUP_INFO;
    
    typedef struct
    {
        char				szName[32];						// name
        UINT				nCapability;					// total capability(kBytes)
        UINT				nRemain;						// remain capability(kBytes)
    } DHDEV_BACKUP_FEEDBACK, *LPDHDEV_BACKUP_FEEDBACK;
    
#define  DH_MAX_BACKUPRECORD_NUM 1024
    
    typedef struct
    {
        char				szDeviceName[DH_MAX_BACKUP_NAME];			//name
        int					nRecordNum;									//number of records
        NET_RECORDFILE_INFO	stuRecordInfo[DH_MAX_BACKUPRECORD_NUM];		//record information
    } BACKUP_RECORD, *LPBACKUP_RECORD;
    
    // multiplay input param
    typedef struct
    {
        int                 iChannelID;      // channel id
        DH_RealPlayType     realplayType;    // real play type
        char                reserve[32];
    }DHDEV_IN_MULTIPLAY_PARAM;
    
    // multiplay output param
    typedef struct
    {
        int                 iChannelID;      // channel id
        LLONG                lRealHandle;     // real play handle
        char                reserve[32];
    }DHDEV_OUT_MULTIPLAY_PARAM;
    /////////////////////////////////Embedded platform/////////////////////////////////
    
    // Platform embedded setup - U China Network Communication(CNC)
    typedef struct
    {
        BOOL				bChnEn;
        char				szChnId[DH_INTERVIDEO_UCOM_CHANID];
    } DH_INTERVIDEO_UCOM_CHN_CFG;
    
    typedef struct
    {
        DWORD				dwSize;
        BOOL				bFuncEnable;			// Enable connection
        BOOL				bAliveEnable;			// Enable alive
        DWORD				dwAlivePeriod;			// Alive period. Unit is second. The value ranges from 0 to 3600.
        char				szServerIp[DH_MAX_IPADDR_LEN];			// CMS IP
        WORD				wServerPort;							// CMS Port
        char				szRegPwd[DH_INTERVIDEO_UCOM_REGPSW];	// Registration password
        char				szDeviceId[DH_INTERVIDEO_UCOM_DEVID];	// Device id
        char				szUserName[DH_INTERVIDEO_UCOM_USERNAME];
        char				szPassWord[DH_INTERVIDEO_UCOM_USERPSW];
        DH_INTERVIDEO_UCOM_CHN_CFG  struChnInfo[DH_MAX_CHANNUM];	// Channel id,en
    } DHDEV_INTERVIDEO_UCOM_CFG;
    
    //  Platform embedded setup - Alcatel
    typedef struct
    {
        DWORD				dwSize;
        unsigned short		usCompanyID[2];			// Company ID,Value. the different three party service company. Now use the first array considering the four bytes in line.
        char				szDeviceNO[32];			// Strings including '\0' are 32 bytes.
        char				szVSName[32];			// Front-end device name. Strings including '\0' are 16 bytes.
        char				szVapPath[32];			// VAP path
        unsigned short		usTcpPort;				// TCP port,value:value ranges from 1 to 65535
        unsigned short		usUdpPort;				// UDP port,Value:Value ranges from 1 to 65535
        bool				bCsEnable[4];			// Enable central server symbol. Value:true=enable,false=disable.Now only use the first array considering the four bytes in line.
        char				szCsIP[16];				// Central server IP address.Strings including '\0' are 16 bytes.
        unsigned short		usCsPort[2];			// Central server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line.
        bool				bHsEnable[4];			// Enable pulse server symbol. Value:true-enable,false=disable.Now only use the first array considering the four bytes in line.
        char				szHsIP[16];				// Pulse server IP address. Strings including '\0' are 16 bytes.
        unsigned short		usHsPort[2];			// Pulse server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line
        int					iHsIntervalTime;		// Pulse server interval. Value(unit is second)
        bool				bRsEnable[4];			// Enable registration server symbol. Value:,true=enable,false=disable.Now only use the first array considering the four bytes in line.
        char				szRsIP[16];				// Registration server IP address. Strings including '\0' are 16 bytes.
        unsigned short		usRsPort[2];			// Registration server port. Value. The value ranges from 1 to 65535.Now use the first array considering the four bytes in line
        int					iRsAgedTime;			// Registration server valid duration. Value(unit is hour)
        char				szAuthorizeServerIp[16];// IP Authorization server IP
        unsigned short		usAuthorizePort[2];		// Authorization server port. Now only use the first array considering the four bytes in line
        char				szAuthorizeUsername[32];// Authorization server account
        char				szAuthorizePassword[36];// Authorization server password
        
        char				szIpACS[16];			// ACS( auto registration server) IP
        unsigned short		usPortACS[2];			// ACS Port,Now only use the first array considering the four bytes in line.
        char				szUsernameACS[32];		// ACS user name
        char				szPasswordACS[36];		// ACS password
        bool				bVideoMonitorEnabled[4];// DVS regularly uploads front-end video monitor message or not.Value:true=enable,false=disable
        int					iVideoMonitorInterval;	// Upload interval(minute)
        
        char				szCoordinateGPS[64];	// GPS coordinates
        char				szPosition[32];			// Device position
        char				szConnPass[36];			// Device connection bit
    } DHDEV_INTERVIDEO_BELL_CFG;
    
    //  Platform embedded setup - ZTE Netview
    typedef struct
    {
        DWORD				dwSize;
        unsigned short		nSevPort;								// Server port. Value. The value ranges from 1 to 65535
        char				szSevIp[DH_INTERVIDEO_NSS_IP];			// Server IP address,string,including '\0' end symbol, there are total 32byte.
        char				szDevSerial[DH_INTERVIDEO_NSS_SERIAL];	// Front-end device serial number, string including '\0' end symbol, there are total 32byte.
        char				szUserName[DH_INTERVIDEO_NSS_USER];
        char				szPwd[DH_INTERVIDEO_NSS_PWD];
    } DHDEV_INTERVIDEO_NSS_CFG;
    
    // Platform embedded setup - AMP
    typedef struct
    {
        char               szDevSerial[DH_INTERVIDEO_AMP_DEVICESERIAL];                  // Front Device Serial num(encoder serial num), read only
        char               szDevName[DH_INTERVIDEO_AMP_DEVICENAME];                      // Front Device Name(encoder name), read only
        char               szRegUserName[DH_INTERVIDEO_AMP_USER];                        // Server Name
        char               szRegPwd[DH_INTERVIDEO_AMP_PWD];                              // Server Password
        BYTE			   bReserved[128];
    } DHDEV_INTERVIDEO_AMP_CFG;
    ////////////////////////////////HDVR special use//////////////////////////////////
    // Alarm relay structure
    typedef struct
    {
        /* Message triggered methods,multiple methods,including
         * 0x00000001 - alarm upload
         * 0x00000002 - triggering recording
         * 0x00000004 - PTZ movement
         * 0x00000008 - sending email
         * 0x00000010 - local tour
         * 0x00000020 - local tips
         * 0x00000040 - alarm output
         * 0x00000080 - ftp upload
         * 0x00000100 - buzzer
         * 0x00000200 - voice tips
         * 0x00000400 - snapshot
         */
        
        /* Current alarm supporting methods, shown by bit mask */
        DWORD				dwActionMask;
        
        /* Triggering action,shown by bit mask,concrete action parameter is shows in the configuration */
        DWORD				dwActionFlag;
        
        /* Triggering alarm output channel,1 means triggering this output */
        BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
        DWORD				dwDuration;				/* Alarm lasting period */
        
        /* Triggering recording */
        BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM_EX]; /* Record channel triggered by alarm,1 means triggering this channel */
        DWORD				dwRecLatch;				/* Recording period */
        
        /* Snapshot channel */
        BYTE				bySnap[DH_MAX_VIDEO_IN_NUM_EX];
        /* Tour channel */
        BYTE				byTour[DH_MAX_VIDEO_IN_NUM_EX];
        
        /* PTZ movement */
        DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM_EX];
        DWORD				dwEventLatch;			/* Event delay time, s for unit,range is 0~15,default is 0 */
        /* Alarm trigerring wireless output,alarm output,1 for trigerring output */
        BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
        BYTE				bMessageToNet;
        BYTE                bMMSEn;                /*Message triggering alarm enabling*/
        BYTE                bySnapshotTimes;       /* the number of sheets of drawings */
        BYTE				bMatrixEn;				/*!< Matrix output enable */
        DWORD				dwMatrix;				/*!< Matrix mask */
        BYTE				bLog;					/*!< Log enable,only used in WTN motion detection */
        BYTE				bSnapshotPeriod;		/*!<Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously.*/
        BYTE				byTour2[DH_MAX_VIDEO_IN_NUM_EX];/* Tour channel 32-63*/
        BYTE                byEmailType;             /*<0,picture,1,record>*/
        BYTE                byEmailMaxLength;        /*<max record length,unit:MB>*/
        BYTE                byEmailMaxTime;          /*<max time length, unit:second>*/
        BYTE				byReserved[475];
    } DH_MSG_HANDLE_EX;
    
    // External alarm expansion
    typedef struct
    {
        BYTE				byAlarmType;			// Alarm type,0:normal closed,1:normal open
        BYTE				byAlarmEn;				// Alarm enable
        BYTE				byReserved[2];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
        DH_MSG_HANDLE_EX	struHandle;				// Handle method
    } DH_ALARMIN_CFG_EX, *LPDHDEV_ALARMIN_CFG_EX;
    
    // Motion detection alarm
    typedef struct
    {
        BYTE				byMotionEn;				// Motion detection alarm enabling
        BYTE				byReserved;
        WORD				wSenseLevel;			// Sensitivity
        WORD				wMotionRow;				// Motion detection area rows
        WORD				wMotionCol;				// Motion detection area lines
        BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Motion detection area,most 32*32
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
        DH_MSG_HANDLE_EX		struHandle;				//Handle method
    } DH_MOTION_DETECT_CFG_EX;
    
    // fire alarm
    typedef struct
    {
        BOOL                byFireEn;              // enable
        DH_MSG_HANDLE_EX    struHandle;            // handler
        BYTE                byReserved[128];
    }DHDEV_FIRE_ALARM_CFG;
    
    // Static detection alarm
    
    typedef struct
    {
        BYTE				byStaticEn;				// Static detection alarm enabling
        BYTE				byLatch;                // detect delay (old struct)
        WORD				wSenseLevel;			// Sensitivity
        WORD				wStaticRow;				// Static detection area rows
        WORD				wStaticCol;				// Static detection area lines
        BYTE				byDetected[DH_STATIC_ROW][DH_STATIC_COL]; // Static detection area,most 32*32
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
        DH_MSG_HANDLE_EX		struHandle;				//Handle method
        int                 nLatch;                 // detect delay (new struct)
        BYTE                bReserved[64];          // reserved
    } DH_STATIC_DETECT_CFG_EX;
    
    // ACC power off configuration
    typedef struct _DHDEV_ACC_POWEROFF_CFG
    {
        BOOL                bEnable;               // ACC power off configuration enable
        int                 nDelayTime;            // ACC power off delay time(m)
        DH_MSG_HANDLE_EX    struHandle;            // handle method
        BYTE                Reserved[128];         // reserved
    }DHDEV_ACC_POWEROFF_CFG;
    
    // explosion proof alarm configuration
    typedef struct _DHDEV_EXPLOSION_PROOF_CFG
    {
        BOOL                bEnable;               // explosion proof alarm configuration enable
        DH_MSG_HANDLE_EX    struHandle;            // handle method
        BYTE                Reserved[128];         // reserved
    }DHDEV_EXPLOSION_PROOF_CFG;
    
    // Raid evnet config
    typedef struct _DHDEV_RAID_EVENT_CFG
    {
        BOOL                bEnable;               // enable
        DH_MSG_HANDLE_EX    struHandle;            // handle
        BYTE                Reserved[128];         //
    }DHDEV_RAID_EVENT_CFG;
    
    // Video loss alarm
    typedef struct
    {
        BYTE				byAlarmEn;				// Video loss alarm enabling
        BYTE				byReserved[3];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
        DH_MSG_HANDLE_EX	struHandle;				// Handle method
    } DH_VIDEO_LOST_CFG_EX;
    
    // Camera masking alarm
    typedef struct
    {
        BYTE				byBlindEnable;			// Enable
        BYTE				byBlindLevel;			// Sensitivity 1-6
        BYTE				byReserved[2];
        DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
        DH_MSG_HANDLE_EX	struHandle;				// Handle method
    } DH_BLIND_CFG_EX;
    
    // HDD info(alarm)
    typedef struct
    {
        BYTE				byNoDiskEn;				// No HDD alarm
        BYTE				byReserved_1[3];
        DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
        DH_MSG_HANDLE_EX	struNDHandle;			// Handle method
        
        BYTE				byLowCapEn;				// Low capacity alarm
        BYTE				byLowerLimit;			// Lower limit,0-99
        BYTE				byReserved_2[2];
        DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
        DH_MSG_HANDLE_EX	struLCHandle;			// Handle method
        
        BYTE				byDiskErrEn;			// HDD error alarm
        BYTE				bDiskNum;
        BYTE				byReserved_3[2];
        DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
        DH_MSG_HANDLE_EX	struEDHandle;			// Handle method
    } DH_DISK_ALARM_CFG_EX;
    
    typedef struct
    {
        BYTE				byEnable;
        BYTE				byReserved[3];
        DH_MSG_HANDLE_EX	struHandle;
    } DH_NETBROKEN_ALARM_CFG_EX;
    
    // Front encoder configuration parameter
    typedef struct __DEV_ENCODER_CFG
    {
        int					nChannels;				// Digital channel number
        DEV_ENCODER_INFO	stuDevInfo[32];			// Digital channel info
        BYTE				byHDAbility;			// The max high definition video amount the digital channel supported. (0 means it does not support high definition setup.)
        // If it supports high definition setup, the high definition channel ranges from 0 to N-1. If your high definition channel number is more than N, the save operation may fail.
        BYTE				bTVAdjust;				// TV adjust. 0:not support, 1:support.
        BYTE				bDecodeTour;			// Decode tour. 0:not support, greater than zero: it means the maximal number supported.
        BYTE				bRemotePTZCtl;			// Remote PTZ control. 0:not support, 1:support.
        char				reserved[12];
    } DEV_ENCODER_CFG, *LPDEV_ENCODER_CFG;
    
    // front end access configuratiion parameter expansion
    typedef struct __DEV_ENCODER_CFG_EX
    {
        int					nChannels;				// number of channel
        DEV_ENCODER_INFO	stuDevInfo[128];	    // the front end of the every digital channel encoder information
        BYTE				byHDAbility;			// maximum number of hd video(0 means not support)
        
        BYTE				bTVAdjust;				// support TV adjust,0:not support,1:support.
        BYTE				bDecodeTour;			// support tour or not, 0:not support, >0:the current number of device support
        BYTE				bRemotePTZCtl;			// support remote PTZ control
        char				reserved[256];
    } DEV_ENCODER_CFG_EX, *LPDEV_ENCODER_CFG_EX;
    // Controller
    typedef struct tagDHCONFIG_CONTROLER{
        DH_COMM_PROP        struComm;	                     // Com attribution
        BYTE                bLightGroup[DH_MAX_LIGHT_NUM];   // Controlled light group,light number start from 1,such as[1,3,8,0?-0]present control light number 1,3,8 light
        BYTE	            bDeviceAddr;	                 // Controller address
        BYTE                bComPortType;                    // Com Type 0:485 COM, 1:232 COM
        BYTE                bReserved[6];		             // Reserved
    } DH_CONFIG_CONTROLER;
    
    // Light control config
    typedef struct __DHDEV_LIGHTCONTROL_CFG
    {
        DH_CONFIG_CONTROLER    struControlers[DH_MAX_CONTROLER_NUM]; // Control config
        BYTE                   bControlerNum;                        // Effective controller number
        BYTE                   bReserved[1023];                      // Reserved
    } DHDEV_LIGHTCONTROL_CFG, *LPDHDEV_LIGHTCONTROL_CFG;
    
    // 3G Flow info config
    typedef struct
    {
        int                 nStrategy;       // strategy, 0: charged by flow every month 1:charged by time every month
        int                 nUpLimit;        // up limit, by flow: MB, by time: h
        int                 nreserved[22];   // reserved
    }DHDEV_3GFLOW_INFO_CFG;
    
    // IPv6 config
    typedef struct
    {
        char               szLinkAddr[44];	 // link address: string length = 44;(every host has an exclusive link address, read only)
        char               szHostIP[40]; 	 // host IP
        DWORD              dwPreFix;		 // net prefix, 1-128
        char               szGateWay[40];	 // gateway
        BOOL               bAutoGet;		 // enable of auto get ip
        char               szPrimaryDns[40]; // primary DNS
        char               szSecondDns[40];	 // second DNS
        char               cReserved[256];   // reserved
    }DHDEV_IPV6_CFG;
    
    //Emergency storage configuration
    typedef struct __DEV_URGENCY_RECORD_CFG
    {
        DWORD dwSize;           // Structure body size
        BOOL bEnable;           // Enable or not. 1=enable.0=disable
        UINT nMaxRecordTime;    // Max record time. Unit is second.
    }DHDEV_URGENCY_RECORD_CFG;
    
    // Lift running parameter configuration
    typedef struct __DEV_ELEVATOR_ATTRI_CFG
    {
        DWORD dwSize;           // Structure body size
        UINT   nMAXFloorNum;     //Max floor. Min is 2.
        UINT   nFloorDelayTime;  //Stay verification time ranges from 5-60. It regards as stop current floor if keep this time period.
        UINT   nIntervalTime;    //The max time for the lift to go up/down a floor. It regars the lift is malfunction if the time is out of the threshold. The lift stopsa between two floors.
    }DHDEV_ELEVATOR_ATTRI_CFG;
    
    // Virtual camera status search
    typedef struct tagDHDEV_VIRTUALCAMERA_STATE_INFO
    {
        DWORD              nStructSize;                  // Structure body size
        int                nChannelID;                   // Channel No.
        CONNECT_STATE      emConnectState;               // Connection status
        UINT               uiPOEPort;                    // The PoE port the virtual camera connected to. 0=It is not a PoE connection.
        char               szDeviceName[64];             // Device name
        char               szDeviceType[128];            // Device type
        char               szSystemType[128];            // system type
        char               szSerialNo[DH_SERIALNO_LEN];  // serial no
        int                nVideoInput;                  // video input number
        int                nAudioInput;                  // audio input number
        int                nAlarmOutput;                 // alarm output number
    }DHDEV_VIRTUALCAMERA_STATE_INFO;
    
    // Device working video/loop mode status info and etc search
    typedef struct tagDHDEV_TRAFFICWORKSTATE_INFO
    {
        DWORD                nStructSize;      // Structure body size
        int                  nChannelID;       // Channel No.
        DH_TRAFFIC_SNAP_MODE emSnapMode;       // Snap mode
    }DHDEV_TRAFFICWORKSTATE_INFO;
    
    /////////////////////////////////ITS picture subscription interface parameter/////////////////////////////////
    typedef struct RESERVED_DATA_INTEL_BOX
    {
        DWORD  dwEventCount;	 //Event count
        DWORD* dwPtrEventType;	 //Point to continuous value of event type, user should request and fr
        DWORD  dwInternalTime;      // picture upload interval time??unit??s
        BYTE   bReserved[1020];	 //Reserved
    }ReservedDataIntelBox;
    
#define RESERVED_TYPE_FOR_INTEL_BOX 0x00000001
    typedef struct RESERVED_PARA
    {
        DWORD 	dwType;	//pData's type
        //when [dwType] is RESERVED_TYPE_FOR_INTEL_BOX, pData is address of type ReservedDataIntelBox
        //when [dwType] is ...,[pData] is ...
        void*	pData;	//data
    }ReservedPara;
#define RESERVED_TYPE_FOR_COMMON   0x00000010
    typedef struct tagNET_RESERVED_COMMON
    {
        DWORD            dwStructSize;
        ReservedDataIntelBox* pIntelBox;    // include RESERVED_TYPE_FOR_INTEL_BOX
        DWORD            dwSnapFlagMask;	// snap flags(by bit),0bit:"*",1bit:"Timing",2bit:"Manual",3bit:"Marked",4bit:"Event",5bit:"Mosaic",6bit:"Cutout"
    }NET_RESERVED_COMMON;
    
#define RESERVED_TYPE_FOR_PATH  0x00000100
    // picture path type
    typedef enum tagNET_PICTURE_PATH_TYPE
    {
        NET_PATH_LOCAL_PATH     ,   // writing path for loacl disk or sd card
        NET_PATH_FTP_PATH       ,   // ftp path
        NET_PATH_VIDEO_PATH     ,   // ftp path for assocated video
    }NET_PICTURE_PATH_TYPE;
    
#define MAX_PIC_PATH_NUM        16
    typedef struct tagNET_RESERVED_PATH
    {
        int                     nMaxPathNum;                        //picture path count, device will use default path if 0
        NET_PICTURE_PATH_TYPE   emPictruePaths[MAX_PIC_PATH_NUM];   //picture path type
    }NET_RESERVED_PATH;
    
    /////////////////////////////////Intelligent speed dome control interface parameter/////////////////////////////////
    // Scene structure info
    typedef struct
    {
        DWORD       dwSize;
        int         nScene;			//Scene SN
    }DHDEV_INTELLI_SCENE_INFO;
    
    // Scene margin limit position info
    typedef struct
    {
        DWORD       dwSize;
        int         nScene;			//Scene SN
        int         nType;			//0:Top margin limit;1:Bottom margin limit;2:Left margin;3:Right margin
    }DHDEV_INTELLI_SCENELIMIT_INFO;
    
    // Manually track object structure body info
    typedef struct
    {
        DWORD       dwSize;
        int         nObjectID;		// Object ID -1 = Set the intelligent frame upload the position of any object out of the frame in the Web >=0: select the intelligent frame to send the object in the frame.
        RECT        stuBound;		// Rectangle range. The coordinates of the point is within [0,8192].
    }DHDEV_INTELLI_TRACKOBJECT_INFO;
    
    typedef enum __TRACKCONTROL_TYPE
    {
        DH_TRACK_MARKSCENE,				// Specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
        DH_TRACK_GOTOSCENE,			// Go to scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
        DH_TRACK_MARKSCENELIMIT,	// The margin limit position of the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
        DH_TRACK_GOTOSCENELIMIT,	// Go to the marin limit position of the scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
        DH_TRACK_MARKSCENEMAXZOOM,	// The max track rate in the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
        DH_TRACK_OBJECT,			// The tracking object in the selected scene. Corresponding to the structure body of the DHDEV_INTELLI_TRACKOBJECT_INFO
        DH_TRACK_START,				// Begin intelligent track. No need to specify parameter information.
        DH_TRACK_STOP,				// Stop intelligent track. No need to specify parameter information.
        DH_TRACK_TYPE_NUM,
    }DH_TRACKCONTROL_TYPE;
    
    //Intelligent speed dome control input parameter
    typedef struct tagNET_IN_CONTROL_INTELLITRACKER
    {
        DWORD       dwSize;
        int         nChannelID;            // Channel ID
        DH_TRACKCONTROL_TYPE emCtrlType;   // Control type
        void*       pCtrlInfo;             // The corresponding inform structure pointer of the control type. Please refer to DH_TRACKCONTROL_TYPE for definition.
        int         nMaxLen;               // Structure body size of the control information
        int         nWaittime;             // Wait time out time
    }NET_IN_CONTROL_INTELLITRACKER;
    
    //Intelligent speed dome control output parameter
    typedef struct tagNET_OUT_CONTROL_INTELLITRACKER
    {
        DWORD       dwSize;
    }NET_OUT_CONTROL_INTELLITRACKER;
    
    /////////////////////////////////Video Analysis Interface Parameters//////////////////////////////
#define MAX_TEMPLATEIMAGE_NUM               32                      // Limitation of valid images quantities.
    
    //Get the inputs of video analyses target
    typedef struct tagNET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE
    {
        DWORD               dwSize;
        int                 nChannelID;                                 // channel ID
        char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
    }NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE;
    
    //Get the outputs of video analyses target
    typedef struct tagNET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE
    {
        DWORD               dwSize;
        unsigned int        nImageNum;                                  // The number of valid images
        DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
        char*               pBuffer;                                    //The pointer of image buffer, applied by users
        int                 nBufLen;                                    // The size of image buffer, filled in by users
        int                 nRetLen;                                    // Get the length of the image data, no need to fill in by user, which can be used to decide whether the buffer is enough.
        
    }NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE;
    
    //Setup the input parameters of video analyses target
    typedef struct tagNET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE
    {
        DWORD               dwSize;
        int                 nChannelID;                                 // Channel ID
        char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
        unsigned int        nImageNum;                                  // The number of valid images
        
        DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
        char*               pBuffer;                                    // The pointer of image buffer
        int                 nBufLen;                                    // Image buffer size
    }NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE;
    
    //Setup the output parameters of video analyses target
    typedef struct tagNET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE
    {
        DWORD       dwSize;
    }NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE;
    
    /////////////////////////////////Abandoned Type/////////////////////////////////
    
    // Search device working status channel information. Corresponding interfaces have been abandoned. Do not user.
    typedef struct
    {
        BYTE				byRecordStatic;			// Channel is recording or not. ;0: does not record,1: manual record,2:auto record
        BYTE				bySignalStatic;			// Connected signal status ;0:normal,1:signal loss
        BYTE				byHardwareStatic;		// Channel hardware status;0:normal ,1:abnormal such as DSP is down ,
        char				reserve;
        DWORD				dwBitRate;				// Actual bit rate
        DWORD				dwLinkNum;				// The client-end connected amount
        DWORD				dwClientIP[DH_MAX_LINK];// Client-end IP address
    } NET_DEV_CHANNELSTATE, *LPNET_DEV_CHANNELSTATE;
    
    // Search device working status. The corresponding interfaces have been abandoned. Please do not use
    typedef struct
    {
        DWORD				dwDeviceStatic;			// Device status;0x00:normal ,0x01:CPU occupation is too high ,0x02:hardware error
        NET_DEV_DISKSTATE	stHardDiskStatic[DH_MAX_DISKNUM];
        NET_DEV_CHANNELSTATE stChanStatic[DH_MAX_CHANNUM];	// Channel status
        BYTE				byAlarmInStatic[DH_MAX_ALARMIN];// Alarm port status;0:no alarm,1: alarm
        BYTE				byAlarmOutStatic[DH_MAX_ALARMOUT]; // Alarm output port status;0:no alarm,1:alarm
        DWORD				dwLocalDisplay;			// Local display status  ;0:normal,1:abnormal
    } NET_DEV_WORKSTATE, *LPNET_DEV_WORKSTATE;
    
    // Protocol information
    typedef struct
    {
        char				protocolname[12];		// Protocol name
        unsigned int		baudbase;				// Baud rate
        unsigned char		databits;				// Data bit
        unsigned char		stopbits;				// Stop bit
        unsigned char		parity;					// Pairty bit
        unsigned char		reserve;
    } PROTOCOL_INFO, *LPPROTOCOL_INFO;
    
    // Audio talk parameter setup
    typedef struct
    {
        // Audio input parameter
        BYTE				byInFormatTag;			// Encode type such as PCM
        BYTE				byInChannels;			// Track amount
        WORD				wInBitsPerSample;		// Sampling depth
        DWORD				dwInSamplesPerSec;		// Sampling rate
        
        // Audio output parameter
        BYTE				byOutFormatTag;			// Encode type such as PCM
        BYTE				byOutChannels;			// Track amount
        WORD				wOutBitsPerSample;		// Sampling depth
        DWORD				dwOutSamplesPerSec;		// Sampling rate
    } DHDEV_TALK_CFG, *LPDHDEV_TALK_CFG;
    
    /////////////////////////////////// Matrix ///////////////////////////////////////
    
#define DH_MATRIX_INTERFACE_LEN		16		// Signal interface name length
#define DH_MATRIX_MAX_CARDS			128		// Matrix sub card max amount
#define DH_SPLIT_PIP_BASE			1000	// The basic value of the PIP split mode
#define	DH_MAX_SPLIT_MODE_NUM		64		// Max split matrix amount
#define DH_MATRIX_MAX_CHANNEL_IN	1500	// Matrix max input channel amount
#define DH_MATRIX_MAX_CHANNEL_OUT	256		// Matrix max output channel amount
#define DH_DEVICE_NAME_LEN			64		// Device name length
#define DH_MAX_CPU_NUM				16		// Max CPU amount
#define DH_MAX_FAN_NUM				16		// Max fan amount
#define DH_MAX_POWER_NUM			16		// Max power amount
#define DH_MAX_BATTERY_NUM          16      // Max battery quantity
#define DH_MAX_TEMPERATURE_NUM		32		// Max temperature sensor amount
#define DH_MAX_ISCSI_NAME_LEN		128		// ISCSI Name length
#define DH_VERSION_LEN				64		// Version info length
#define DH_MAX_STORAGE_PARTITION_NUM 32		//  Storage partition max number
#define DH_STORAGE_MOUNT_LEN		64		// Mount length
#define DH_STORAGE_FILE_SYSTEM_LEN	16		// File system name length
#define DH_MAX_MEMBER_PER_RAID		32		// RAID max members
#define DH_DEV_ID_LEN_EX			128		// Device ID max length
#define DH_MAX_BLOCK_NUM			32		// max number of block
#define DH_MAX_SPLIT_WINDOW			128		// max number of split window
#define DH_FILE_TYPE_LEN			64		// length of file type
#define DH_DEV_ID_LEN				128		// length of device ID
#define DH_DEV_NAME_LEN				128		// max length of device name
#define DH_TSCHE_DAY_NUM			8		// schedule the first dimension size, means days
#define DH_TSCHE_SEC_NUM			6		// schedule the second dimension size, means time
#define    DH_SPLIT_INPUT_NUM           256         // Judicial device level 2 switch level 1 split supported input channel
    
#define DH_DEVICE_ID_LOCAL		"Local"		// local device ID
#define DH_DEVICE_ID_REMOTE		"Remote"	// remote device ID
#define DH_DEVICE_ID_UNIQUE		"Unique"	// unique ID
    
    // Split mode
    typedef enum tagDH_SPLIT_MODE
    {
        DH_SPLIT_1 = 1,							// 1-window
        DH_SPLIT_2 = 2, 						// 2-window
        DH_SPLIT_4 = 4, 						// 4-window
        DH_SPLIT_6 = 6, 						// 6-window
        DH_SPLIT_8 = 8, 						// 8-window
        DH_SPLIT_9 = 9, 						// 9-window
        DH_SPLIT_12 = 12, 						// 12-window
        DH_SPLIT_16 = 16, 						// 16-window
        DH_SPLIT_20 = 20, 						// 20-window
        DH_SPLIT_25 = 25, 						// 25-window
        DH_SPLIT_36 = 36, 						// 36-window
        DH_SPLIT_64 = 64, 						// 64-window
        DH_SPLIT_144 = 144, 					// 144-window
        DH_PIP_1 = DH_SPLIT_PIP_BASE + 1,		// PIP mode.1-full screen+1-small window
        DH_PIP_3 = DH_SPLIT_PIP_BASE + 3,		// PIP mode.1-full screen+3-small window
        DH_SPLIT_FREE = DH_SPLIT_PIP_BASE * 2,	// free open window mode,are free to create,close, window position related to the z axis
        DH_COMPOSITE_SPLIT_1 = DH_SPLIT_PIP_BASE * 3 + 1,	// integration of a split screen
        DH_COMPOSITE_SPLIT_4 = DH_SPLIT_PIP_BASE * 3 + 4,	// fusion of four split screen
    } DH_SPLIT_MODE;
    
#define DH_PROTOCOL_DAHUA2 DH_PROTOCOL_PRIVATE2
#define DH_PROTOCOL_DAHUA3 DH_PROTOCOL_PRIVATE3
    
    // Device protocol type
    typedef enum tagDH_DEVICE_PROTOCOL
    {
        DH_PROTOCOL_PRIVATE2,						// private 2nd protocol
        DH_PROTOCOL_PRIVATE3,						// private 3rd protocol
        DH_PROTOCOL_ONVIF,						// Onvif
        DH_PROTOCOL_VNC,						// virtual network computer
        DH_PROTOCOL_TS,                         // Standard TS
        
        DH_PROTOCOL_PRIVATE = 100,              // private protocol of private
        DH_PROTOCOL_AEBELL,                     // aebell
        DH_PROTOCOL_PANASONIC,                  // panasonic
        DH_PROTOCOL_SONY,                       // sony
        DH_PROTOCOL_DYNACOLOR,                  // Dynacolor
        DH_PROTOCOL_TCWS,						// tcsw
        DH_PROTOCOL_SAMSUNG,                    // sansung
        DH_PROTOCOL_YOKO,                       // YOKO
        DH_PROTOCOL_AXIS,                       // axis
        DH_PROTOCOL_SANYO,						// sanyo
        DH_PROTOCOL_BOSH,						// Bosch
        DH_PROTOCOL_PECLO,						// Peclo
        DH_PROTOCOL_PROVIDEO,					// Provideo
        DH_PROTOCOL_ACTI,						// ACTi
        DH_PROTOCOL_VIVOTEK,					// Vivotek
        DH_PROTOCOL_ARECONT,					// Arecont
        DH_PROTOCOL_PRIVATEEH,			        // PrivateEH
        DH_PROTOCOL_IMATEK,					    // IMatek
        DH_PROTOCOL_SHANY,                      // Shany
        DH_PROTOCOL_VIDEOTREC,                  // videotrec
        DH_PROTOCOL_URA,						// Ura
        DH_PROTOCOL_BITICINO,                   // Bticino
        DH_PROTOCOL_ONVIF2,                     // Onvif's protocol type, same to DH_PROTOCOL_ONVIF
        DH_PROTOCOL_SHEPHERD,                   // shepherd
        DH_PROTOCOL_YAAN,                       // yaan
        DH_PROTOCOL_AIRPOINT,					// Airpop
        DH_PROTOCOL_TYCO,                       // TYCO
        DH_PROTOCOL_XUNMEI,                     // xunmei
        DH_PROTOCOL_HIKVISION,                  // hikvision
        DH_PROTOCOL_LG,                         // LG
        DH_PROTOCOL_AOQIMAN,					// aoqiman
        DH_PROTOCOL_BAOKANG,                    // baokang
        DH_PROTOCOL_WATCHNET,                   // Watchnet
        DH_PROTOCOL_XVISION,                    // Xvision
        DH_PROTOCOL_FUSITSU,                    // fusitsu
        DH_PROTOCOL_CANON,						// Canon
        DH_PROTOCOL_GE,							// GE
        DH_PROTOCOL_Basler,						// basler
        DH_PROTOCOL_Patro,						// patro
        DH_PROTOCOL_CPKNC,						// CPPLUS K series
        DH_PROTOCOL_CPRNC,						// CPPLUS R series
        DH_PROTOCOL_CPUNC,						// CPPLUS U series
        DH_PROTOCOL_CPPLUS,						// CPPLUS IPC
        DH_PROTOCOL_XunmeiS,					// xunmeis,protocal is Onvif
        DH_PROTOCOL_GDDW,						// GDDW
        DH_PROTOCOL_PSIA,                       // PSIA
        DH_PROTOCOL_GB2818,                     // GB2818
        DH_PROTOCOL_GDYX,                       // GDYX
        DH_PROTOCOL_OTHER,                      // others
    } DH_DEVICE_PROTOCOL;
    
    // Split mode info
    typedef struct tagDH_SPLIT_MODE_INFO
    {
        DWORD				dwSize;
        DH_SPLIT_MODE		emSplitMode;			// Split mode
        int					nGroupID;				// Group SN
        DWORD               dwDisplayType;          // display type??seeDH_SPLIT_DISPLAY_TYPE?¡§under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule?¡§as depending on DisChntext??. Compatible??no this item??default is normal display type as"General"??
    } DH_SPLIT_MODE_INFO;
    
    // Split capability
    typedef struct tagDH_SPLIT_CAPS
    {
        DWORD				dwSize;
        int					nModeCount;				// The split amount supported
        DH_SPLIT_MODE		emSplitMode[DH_MAX_SPLIT_MODE_NUM];	// The split mode supported
        int				    nMaxSourceCount;		// Max display source allocation amount
        int					nFreeWindowCount;		// count of free window support
        BOOL				bCollectionSupported;	// support collection
        DWORD               dwDisplayType;                          // mask means multiple display types??see DH_SPLIT_DISPLAY_TYPE?¡§under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule?¡§as depending on DisChntext??Compatible??no this item??default is normal display type as"General"??
        int                 nPIPModeCount;                          // PIP support split mode quantity
        DH_SPLIT_MODE       emPIPSplitMode[DH_MAX_SPLIT_MODE_NUM];  // PIP supported split mode
        int                 nInputChannels[DH_SPLIT_INPUT_NUM];     // supported input channel
        int                 nInputChannelCount;                     // supported input channel quantity, 0 means no input channel limit
        int                 nBootModeCount;                         // enable split mode quantity
        DH_SPLIT_MODE       emBootMode[DH_MAX_SPLIT_MODE_NUM];      // support enable default video split mode
    } DH_SPLIT_CAPS;
    
    // even the authentication information
    typedef struct tagDH_CASCADE_AUTHENTICATOR
    {
        DWORD				dwSize;
        char				szUser[DH_NEW_USER_NAME_LENGTH];		// user name
        char				szPwd[DH_NEW_USER_PSW_LENGTH];			// passwd
        char				szSerialNo[DH_SERIALNO_LEN];			// serial no.
    } DH_CASCADE_AUTHENTICATOR;
    // Display source
    typedef struct tagDH_SPLIT_SOURCE
    {
        DWORD				dwSize;
        BOOL			    bEnable;						    // Enable
        char			    szIp[DH_MAX_IPADDR_LEN];		    // IP, null means there is no setup.
        char			    szUser[DH_USER_NAME_LENGTH];	    // User name
        char			    szPwd[DH_USER_PSW_LENGTH];	    	// Password
        int			    	nPort;							    // Port
        int				    nChannelID;						    // Channel No.
        int				    nStreamType;					    // Video bit stream. -1-auto, 0-main stream, 1-extra stream 1, 2-extra stream 2, 3-extra stream 3
        int				    nDefinition;					    // Definition, 0-standard definition, 1-high definition
        DH_DEVICE_PROTOCOL  emProtocol;							// Protocol type
        char			    szDevName[DH_DEVICE_NAME_LEN];		// Device name
        int					nVideoChannel;						// Video input channel amount
        int					nAudioChannel;						// Audio input channel amount
        // For decoder only
        BOOL				bDecoder;							// Decoder or not.
        BYTE				byConnType;							// 0:TCP;1:UDP;2:multicast
        BYTE				byWorkMode;							// 0:connect directly; 1:transfer
        WORD				wListenPort;						// isten port, valid with transfer; when byConnType is multicast, it is multiport
        char				szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extension, front DVR Ip address (enter domain name)
        BYTE				bySnapMode;                         //  snapshot mode (valid when nStreamType==4) 0: request for single frame, 1: sechdule sending request
        BYTE				byManuFactory;						// Target device manufacturer. Refer to EM_IPC_TYPE for detailed information.
        BYTE				byDeviceType;                       //  target device type, 0:IPC
        BYTE				byDecodePolicy;                     // target device decode policy, 0:compatible with previous
        // 1:real time level high 2: real time level medium
        // 3: real time level low 4: default level
        // 5: fluency level high 6: fluency level medium
        // 7: fluency level low
        DWORD				dwHttpPort;                         // Http port number, 0-65535
        DWORD				dwRtspPort;                         // Rtsp port number, 0-65535
        char				szChnName[DH_DEVICE_NAME_LEN];		// Remote channel name, modifiable only when name read is not vacant
        char				szMcastIP[DH_MAX_IPADDR_LEN];       // Multicast IP address. Valid only when byConnType is multicast
        char				szDeviceID[DH_DEV_ID_LEN_EX];		// device ID, ""-null, "Local"  "Remote"
        BOOL				bRemoteChannel;						// is remote channel or not(read only)
        unsigned int		nRemoteChannelID;					// remote channel ID (read only), effective when bRemoteChannel=TRUE
        char				szDevClass[DH_DEV_TYPE_LEN];		// type of device, such as IPC, DVR, NVR and so on
        char				szDevType[DH_DEV_TYPE_LEN];			// device specific type, such as IPC-HF3300
        char				szMainStreamUrl[MAX_PATH];			// main stream url, effective when byManuFactory =D H_IPC_OTHER
        char				szExtraStreamUrl[MAX_PATH];			// extra stream url, effective when byManuFactory =D H_IPC_OTHER
        int					nUniqueChannel;						// unique channel ID, read only
        DH_CASCADE_AUTHENTICATOR stuCascadeAuth;				// ssascade authemyication, effective when device ID = "Local/Cascade/SerialNo",  SerialNo is device seral no.
        int                 nHint;                              // 0-normal video source, 1- alarm video source
        int                 nOptionalMainUrlCount;              // back main stream address quantity
        char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup main stream address list
        int                 nOptionalExtraUrlCount;             // backup sub stream address quantity
        char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup sub stream address list
        //--------------------------------------------------------------------------------------
        //protocol follow-up add field
        int                 nInterval;                          // tour time intertval	unit??second
        char                szUserEx[DH_NEW_USER_NAME_LENGTH];  // user name
        char                szPwdEx[DH_NEW_USER_PSW_LENGTH];    // password
    } DH_SPLIT_SOURCE;
    
    // Video output capability set
    typedef struct tagDH_VIDEO_OUT_CAPS
    {
        DWORD				dwSize;
        BOOL				bColor;							// Support color output setup or not
        BOOL				bMargin;						// Support margin setup or not
        int					nLayers;						// The max layers supported at the same time
        BOOL				bPowerMode;						// Support power control or not.
        int					bSplitMode;						// The video split mode supported. 0-1-window. 1-'#' mode(inclduing 1-window).2-Any mode
        unsigned int        nBackground;                    // support background mode, by bit, 0-color, 1-picture
        BOOL                bBindOutput;                    // If support output screen resoluton binding setup
        BOOL                bAudioSupport;                          // Support audio output or not
        DWORD               dwAudioMode;                            // The support audio mode, by bit, bit0-main controller output, bit1-daughter card output
    } DH_VIDEO_OUT_CAPS;
    
    // Color BCSH
    typedef struct tagDH_COLOR_BCSH
    {
        int					nBirghtness;					// Brightness
        int					nContrast;						// Contrast
        int			        nSaturation;					// Saturation
        int					nHue;						    // Hue
    } DH_COLOR_BCSH;
    
    // Dimensions
    typedef struct tagDH_SIZE
    {
        int					nWidth;							// Width
        int					nHeight;						// Height
    } DH_SIZE;
    
    // mode of hot plug
    typedef struct tagDH_HOT_PLUG_MODE
    {
        DWORD				dwSize;
        int					nMode;							// mode of hot plug, 0-hot plug, 1-force output mode
    } DH_HOT_PLUG_MODE;
    // Video output option
    typedef struct tagDH_VIDEO_OUT_OPT
    {
        DWORD				dwSize;
        DH_RECT*			pstuMargin;						// Margin range
        DH_COLOR_BCSH*		pstuColor;						// Output color
        DH_COLOR_RGBA*		pstuBackground;					// Background color
        DH_SIZE*			pstuSize;						// Output dimensions
        DH_HOT_PLUG_MODE*	pstuHotPlugMode;				// mode of hot plug
    } DH_VIDEO_OUT_OPT;
    
    // Production definition
    typedef struct tagDH_PRODUCTION_DEFNITION
    {
        DWORD				dwSize;
        int					nVideoInChannel;				// Video input channel amount
        int					nVideoOutChannel;				// Video output channel amount
        int					nRemoteDecChannel;				// Remote decode channel amount
        char				szDevType[DH_DEV_TYPE_LEN];		// Device type
        char				szVendor[DH_MAX_NAME_LEN];		// OEM customer
        int					nOEMVersion;					// OEM version
        int					nMajorVerion;					// Main version No.
        int					nMinorVersion;					// SUb version No.
        int					nRevision;						// Revision version
        char				szWebVerion[DH_MAX_NAME_LEN];	// Web version
        char				szDefLanguage[DH_MAX_NAME_LEN];	// Default setup
        NET_TIME			stuBuildDateTime;				// Release time. Unit is second.
        int					nAudioInChannel;				// Audio input channel amount
        int					nAudioOutChannel;				// Audio output channel amount
        BOOL				bGeneralRecord;					// Support schedule storage or not.
        BOOL				bLocalStore;					// Support local storage or not.
        BOOL				bRemoteStore;					// Support network storage or not.
        BOOL				bLocalurgentStore;				// Support emergency local storage or not.
        BOOL				bRealtimeCompress;				// Support real-time compression storage or not.
        DWORD				dwVideoStandards;				// The video format supported. bit0-PAL, bit1-NTSC
        int					nDefVideoStandard;				// Default video format, 0-PAL, 1-NTSC
        int					nMaxExtraStream;				// Max extra stream channel amount
        int					nRemoteRecordChannel;			// Remote record channel amount
        int					nRemoteSnapChannel;				// Remote snap channel amount
        int					nRemoteVideoAnalyseChannel;		// Remote video analysis channel amount
        int					nRemoteTransmitChannel;			// Remote real-time stream transmit max channel amount
        int					nRemoteTransmitFileChannel;		// Remote transmit file channel amount
        int					nStreamTransmitChannel;			// Max network transmit channel amount
        int					nStreamReadChannel;				// Max read file channel amount
        int					nMaxStreamSendBitrate;			// Max bit stream network send capability, kbps
        int					nMaxStreamRecvBitrate;			// Max bit stream network interface capability, kbps
        BOOL				bCompressOldFile;				// Old compression file or not. Delete P frame and save I frame.
        BOOL				bRaid;							// Support RAID or not.
        int					nMaxPreRecordTime;				// Max pre-record time.Unit is second.
        BOOL				bPtzAlarm;						// Support PTZ alarm or not.
        BOOL				bPtz;							// Support PTZ or not.
        BOOL				bATM;							// Support corresponding function of the ATM or not.
        BOOL				b3G;							// Support 3G module or not.
        BOOL				bNumericKey;					// With number button or not.
        BOOL				bShiftKey;						// With Shift button or not.
        BOOL				bCorrectKeyMap;					// Number character map sheet is right or not.
        BOOL				bNewATM;						// The new 2nd ATM front panel.
        BOOL				bDecoder;						// Decoder or not
        DEV_DECODER_INFO	stuDecoderInfo;					// Decoder info. Valid when bDecoder=true.bDecoder=true
        int					nVideoOutputCompositeChannels;	// integration ceiling screen output channel
        BOOL                bSupportedWPS;                  // support WPS or not
        int					nVGAVideoOutputChannels;		// VGA video output channel number
        int					nTVVideoOutputChannels;			// TV video output channel number
        int					nMaxRemoteInputChannels;			// max number of remote channels
        int					nMaxMatrixInputChannels;			// max number of matrix channels
        int                 nMaxRoadWays;                   // max counts of road ways 1~6
        int                 nMaxParkingSpaceScreen;         // max counts of screen when docking with the camera 0~20
        
        int					nPtzHorizontalAngleMin;			// PTZ'horizontal minimum Angle, [0-360]
        int					nPtzHorizontalAngleMax;			// PTZ'horizontal maximum Angle, [0-360]
        int					nPtzVerticalAngleMin;			// PTZ'vertical  minimum Angle, [-90,90]
        int					nPtzVerticalAngleMax;			// PTZ'vertical  maximum Angle, [-90,90]
        BOOL				bPtzFunctionMenu;				// Whether to support PTZ's function menu
        BOOL				bLightingControl;				// Whether to support lighting control
        DWORD				dwLightingControlMode;			// Manual lighting control mode,bitwise,see NET_LIGHTING_CTRL_ON_OFF
        int					nNearLightNumber;				// dipped headlight group number, 0 means no support
        int					nFarLightNumber;				// High beam group number, 0 means no support
        BOOL				bFocus;							// Whether to support control focus
        BOOL				bIris;							// Whether to support control aperture
        char				szPtzProtocolList[DH_COMMON_STRING_1024];	// PTZ support agreement list, can be more, each with '; 'delimited
        BOOL				bRainBrushControl;				// Whether to support wiper control
        int					nBrushNumber;					// Number of wiper, 0 means no support
        int					nLowerMatrixInputChannels[DH_MAX_LOWER_MITRIX_NUM];	// inferior video matrix input channel, the subscript corresponding matrix number
        int					nLowerMatrixOutputChannels[DH_MAX_LOWER_MITRIX_NUM];	// inferior video matrix output channel, the subscript corresponding matrix number
        BOOL                bSupportVideoAnalyse;           // support intelligent analuysis or not
        BOOL                bSupportIntelliTracker;         // support intelligen tracking or not
        DWORD               nSupportBreaking;               //device supported violation type mask(by bit Get )
        //0-run the red light 1-cross line  2-retrogradation  3-under speed 4-over speed 5-car in lane 6-yellow plate in lane 7-violation driving?¡§left, right, u-turn??
        //8-violation enter waiting zone 9-illegal parking 10-Traffic jam 11-driving not by lane 12-illegal lane change 13-cross yellow line 14-should driving
        //15-manual snapshot 16-illegal retention 17-crosswalk pedestration first 18-over flow 19-under flow 20-illegal in lane 21-illegal back car
        //22-cross stop line 23-run yellow light 24-yellow grid line parking 25-car in parking 26-car not in parking 27-car in parking cross line  28-limited plate
        //29-no pass 30-unfasten seat belt 31-drvier smoking
        DWORD               nSupportBreaking1;              //0-driver call
    } DH_PRODUCTION_DEFNITION;
    
    // Manual lighting control mode
#define NET_LIGHTING_CTRL_ON_OFF				0x01	// Direct switch mode
#define NET_LIGHTING_CTRL_ADJUST_BRIGHTNESS		0x02	// Manually adjust brightness mode
#define NET_LIGHTING_CTRL_ZOOM_PRIO				0x04	// Ratio prefer
    
    
    // Matrix sub card type. Various setups.
#define DH_MATRIX_CARD_MAIN				0x10000000		// main card
#define DH_MATRIX_CARD_INPUT			0x00000001		// input card
#define DH_MATRIX_CARD_OUTPUT			0x00000002		// output card
#define DH_MATRIX_CARD_ENCODE			0x00000004		// encode card
#define DH_MATRIX_CARD_DECODE			0x00000008		// decode card
#define DH_MATRIX_CARD_CASCADE			0x00000010		// cascade card
#define DH_MATRIX_CARD_INTELLIGENT		0x00000020		// intelligent card
#define DH_MATRIX_CARD_ALARM            0x00000040      // alarm card
#define DH_MATRIX_CARD_RAID             0x00000080      // Hdd Raid Card
    // Matrix sub card info
    typedef struct tagDH_MATRIX_CARD
    {
        DWORD				dwSize;
        BOOL				bEnable;					// Valid or not
        DWORD				dwCardType;					// Sub card type
        char		    	szInterface[DH_MATRIX_INTERFACE_LEN];	// Signal interface type, "CVBS", "VGA", "DVI"...
        char		    	szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// Device IP or domain name. The sub card that has no network conneciton can be null.
        int			    	nPort;						// Port No. The sub card that has no network conneciton can be 0.
        int					nDefinition;				// Definition. 0=standard definition. 1=High definition
        int					nVideoInChn;				// Video input channel amount
        int					nAudioInChn;				// Audio input channel amount
        int					nVideoOutChn;				// Video output channel amount
        int				    nAudioOutChn;				// Audio output channel amount
        int			    	nVideoEncChn;				// Video encode channel amount
        int				    nAudioEncChn;				// Audio encode channel amount
        int			    	nVideoDecChn;				// Video decode channel amount
        int			    	nAudioDecChn;				// Audio decode channel amount
        int					nStauts;					// Status: 0-OK, 1-no respond, 2-network disconnection, 3-conflict, 4-upgrading now
        int					nCommPorts;					// COM amount
        int					nVideoInChnMin;				// Video input channel min value
        int					nVideoInChnMax;				// Video input channel max value
        int					nAudioInChnMin;				// Audio input channel min value
        int					nAudioInChnMax;				// Audio input channel max value
        int					nVideoOutChnMin;			// Video output channel min value
        int					nVideoOutChnMax;			// Video output channel max value
        int					nAudioOutChnMin;			// Audio output channel min value
        int					nAudioOutChnMax;			// Audio output channel max value
        int					nVideoEncChnMin;			// Video encode channel min value
        int					nVideoEncChnMax;			// Video encode channel max value
        int					nAudioEncChnMin;			// Audio encode channel min value
        int					nAudioEncChnMax;			// Audio encode channel max value
        int					nVideoDecChnMin;			// Video decode channel min value
        int					nVideoDecChnMax;			// Video decode channel max value
        int					nAudioDecChnMin;			// Audio decode channel min value
        int					nAudioDecChnMax;			// Audio decode channel max value
        int					nCascadeChannels;			// number of cascade channel
        int					nCascadeChannelBitrate;		// cascade channel bitrate (Mbps)
        int					nAlarmInChnCount;			// Alarm input channel number
        int					nAlarmInChnMin;				// Alarm input channel number minimum value
        int					nAlarmInChnMax;				// Alarm input channel number maximum value
        int					nAlarmOutChnCount;			// Alarm output channel number
        int					nAlarmOutChnMin;			// Alarm output channel number minimum value
        int					nAlarmOutChnMax;			// Alarm output channel number maximum value
        int					nVideoAnalyseChnCount;		// Intelligent analysis of channel number
        int					nVideoAnalyseChnMin;		// Intelligent analysis of channel number minimum value
        int					nVideoAnalyseChnMax;		// Intelligent analysis of channel number maximum value
        int					nCommPortMin;				// minimum value of serial port number
        int					nCommPortMax;				// maximum value of serial port number
        char                szVersion[DH_COMMON_STRING_32];         // Version info
        NET_TIME            stuBuildTime;                           // compile time
    } DH_MATRIX_CARD;
    
    // Matrix sub card list
    typedef struct tagDH_MATRIX_CARD_LIST
    {
        DWORD				dwSize;
        int					nCount;							// sub card  amount
        DH_MATRIX_CARD		stuCards[DH_MATRIX_MAX_CARDS];	// Sub card list
    } DH_MATRIX_CARD_LIST;
    
    // Video output window
    typedef struct tagDH_VIDEO_OUT_WINDOW
    {
        DWORD				dwSize;
        int					nBackboardID;				// Backboard ID
        int					nScreenID;					// Screen ID
        int					nWindowID;					// Window ID
    } DH_VIDEO_OUT_WINDOW;
    
    // CLIENT_GetISCSITargets
    typedef struct tagDH_IN_ISCSI_TARGETS
    {
        DWORD				dwSize;
        const char*			pszAddress;					// Server address
        int					nPort;						// port
        const char*			pszUser;					// Username
        const char*			pszPwd;						// Password
    } DH_IN_ISCSI_TARGETS;
    
    // ISCSI Target Info
    typedef struct tagDH_ISCSI_TARGET
    {
        DWORD				dwSize;
        char				szName[DH_MAX_ISCSI_NAME_LEN];	// Name
        char				szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// service address
        char				szUser[DH_NEW_USER_NAME_LENGTH];// user name
        int					nPort;							// port
        UINT				nStatus;						// status, 0- unknow, 1-connected, 2-un connected, 3-connect failed, 4-authentication failed, 5-connect time out
    } DH_ISCSI_TARGET;
    
    // CLIENT_GetISCSITargets Interface output parameter
    typedef struct tagDH_OUT_ISCSI_TARGETS
    {
        DWORD				dwSize;
        DH_ISCSI_TARGET*	pstuTargets;				// iscsi array
        int					nMaxCount;					// iscsi group size
        int					nRetCount;					// Received iscSi amount
    } DH_OUT_ISCSI_TARGETS;
    
    typedef enum tagDH_BITMAP_ACCURACY
    {
        BA_DAY ,            //day
        BA_HOUR ,           //day
        BA_5MIN ,           //5 miuntes
    }DH_BITMAP_ACCURACY;
    
#define DH_MAX_BITMAPS        256                        // Bitmap bytes??DH_MAX_BITMAPS*8-bit
#define DH_MAX_CHN_NUM        256                        // The maximum channel number
    //CLIENT_GetBitmap Interface input parameters
    typedef struct tagDH_IN_BITMAP
    {
        DWORD               dwSize;
        NET_TIME            stuStartTime;                   // start time, accurate to seconds
        NET_TIME            stuEndTime;                     // Over time, accurate to seconds
        int                 nChnList[DH_MAX_CHN_NUM];       // [1, ??, 10]	Channel number list ,-1 means all channels ,0 means channels end
        DH_BITMAP_ACCURACY  emAccuracy;                     // Precision of the bitmap
    }DH_IN_BITMAP;
    
    typedef struct tagDH_BITMAP_INFO
    {
        DWORD               dwSize;
        int                 nChnID;                         //Channel number??Channel number is 0??means the end of the list
        BYTE                bBitmap[DH_MAX_BITMAPS];        //Bitmap (each bit means a query scale, from low to high filling)
        //support DH_MAX_BITMAPS * 8 scale
        int                 nBitNum;                        //the digits of bitmap
    }DH_BITMAP_INFO;
    
    //CLIENT_GetBitmap  Interface output parameters
    typedef struct tagDH_OUT_BITMAP
    {
        DWORD               dwSize;
        DH_BITMAP_INFO      *pstBitmapInfos;
        int                 nGetBitmapInfo;
        int                 nMaxBitmapInfo;
    }DH_OUT_BITMAP;
    
    // Storage device name
    typedef struct tagDH_STORAGE_DEVICE_NAME
    {
        DWORD				dwSize;
        char				szName[DH_STORAGE_NAME_LEN];
    } DH_STORAGE_DEVICE_NAME;
    
    // RAID state
#define DH_RAID_STATE_ACTIVE		0x00000001
#define DH_RAID_STATE_INACTIVE		0x00000002
#define DH_RAID_STATE_CLEAN			0x00000004
#define DH_RAID_STATE_FAILED		0x00000008
#define DH_RAID_STATE_DEGRADED		0x00000010
#define DH_RAID_STATE_RECOVERING	0x00000020
#define DH_RAID_STATE_RESYNCING		0x00000040
#define DH_RAID_STATE_RESHAPING		0x00000080
#define DH_RAID_STATE_CHECKING		0x00000100
#define DH_RAID_STATE_NOTSTARTED	0x00000200
    
    // RAID member info
    typedef struct tagNET_RAID_MEMBER_INFO
    {
        DWORD               dwSize;
        DWORD               dwID;                                       // disk no., may use to describe disk cabinet slot
        BOOL                bSpare;                                     // partial hot device, true-partial hot device, false-RAID sub disk
    } NET_RAID_MEMBER_INFO;
    
    // RAID Info
    typedef struct tagDH_STORAGE_RAID
    {
        DWORD				dwSize;
        int					nLevel;										// level
        int					nState;										// RAID state combinationDH_RAID_STATE_ACTIVE | DH_RAID_STATE_DEGRADED
        int					nMemberNum;									// member amount
        char				szMembers[DH_MAX_MEMBER_PER_RAID][DH_STORAGE_NAME_LEN];	// RAID member
        float               fRecoverPercent;                            // Sync percentage, 0~100, RAID status has"Recovering" or "Resyncing" valid
        float               fRecoverMBps;                               // Sync speed, unit MBps, RAID status has"Recovering" or "Resyncing" valid
        float               fRecoverTimeRemain;                         // Sync remaining time, unit minute, RAID status has "Recovering" or "Resyncing" valid
        NET_RAID_MEMBER_INFO stuMemberInfos[DH_MAX_MEMBER_PER_RAID];    // RAID member info
    } DH_STORAGE_RAID;
    
    // Storage partition info
    typedef struct tagDH_STORAGE_PARTITION
    {
        DWORD				dwSize;
        char				szName[DH_STORAGE_NAME_LEN];				// Name
        INT64				nTotalSpace;   							    //Total space(MB)
        INT64				nFreeSpace;								    // free space(MB)
        char				szMountOn[DH_STORAGE_MOUNT_LEN];			// Mount point
        char				szFileSystem[DH_STORAGE_FILE_SYSTEM_LEN];	//File system
        int					nStatus;									// partition state, 0-LV not available, 1-LV available
    } DH_STORAGE_PARTITION;
    
    // storage tank info
    typedef struct tagDH_STORAGE_TANK
    {
        DWORD				dwSize;
        int					nLevel;										// level, the host is 0 level
        int					nTankNo;									// extend port number from 0
        int                 nSlot;                                      // Corresponding cabinet board card no., start from 0
    } DH_STORAGE_TANK;
    
    // storage device status
#define NET_STORAGE_DEV_OFFLINE                 0                   // physical disk offline status
#define NET_STORAGE_DEV_RUNNING                 1                   // physicali disk running ststus
#define NET_STORAGE_DEV_ACTIVE                  2                   // RAID activity
#define NET_STORAGE_DEV_SYNC                    3                   // RAID sync
#define NET_STORAGE_DEV_SPARE                   4                   // RAID hotdevice(partial)
#define NET_STORAGE_DEV_FAULTY                  5                   // RAID invalid
#define NET_STORAGE_DEV_REBUILDING              6                   // RAID re-build
#define NET_STORAGE_DEV_REMOVED                 7                   // RAID remove
#define NET_STORAGE_DEV_WRITE_ERROR             8                   // RAID error
#define NET_STORAGE_DEV_WANT_REPLACEMENT        9                   // RAID need to be replaced
#define NET_STORAGE_DEV_REPLACEMENT             10                  // RAID is replacement
#define NET_STORAGE_DEV_GLOBAL_SPARE            11                  // Global hotdevice
#define NET_STORAGE_DEV_ERROR                   12                  // Error, partial available
#define NET_STORAGE_DEV_RAIDSUB                 13                  // The disk is single, originally is Raid sub disk, may auto add Raid after reboot
    
    // Storage device info
    typedef struct tagDH_STORAGE_DEVICE
    {
        DWORD				dwSize;
        char				szName[DH_STORAGE_NAME_LEN];				// name
        INT64				nTotalSpace;								// Total space (MB)
        INT64				nFreeSpace;									// free space (MB)
        BYTE				byMedia;									// Media, 0-DISK, 1-CDROM, 2-FLASH medium,
        BYTE				byBUS;										// BUS, 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI main line 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI
        BYTE				byVolume;									// volume type, 0-physics, 1-Raid, 2- VG virtual
        BYTE				byState;									// Physics disk state, 0-physics disk offline state 1-physics disk  2- RAID activity 3- RAID sync 4-RAID hotspare 5-RAID invalidation 6- RAID re-creation  7- RAID delete
        int					nPhysicNo;									// storage interface of devices of same type logic number
        int					nLogicNo;									// storage interface of devices of same type physics number
        char				szParent[DH_STORAGE_NAME_LEN];				// superior storage group name
        char				szModule[DH_STORAGE_NAME_LEN];				// device module
        char				szSerial[DH_SERIALNO_LEN];					// device serial number
        char				szFirmware[DH_VERSION_LEN];					// Firmware version
        int					nPartitionNum;								//partition number
        DH_STORAGE_PARTITION stuPartitions[DH_MAX_STORAGE_PARTITION_NUM];// partition info
        DH_STORAGE_RAID		stuRaid;									// Raid info, for RAID use only(byVolume == 1)
        DH_ISCSI_TARGET		stuISCSI;									// Iscsi info, for iscsi use only (byVolume == 2)
        BOOL				abTank;										// tank enable
        DH_STORAGE_TANK		stuTank;									// tank info, effectice when abTank = TRUE
    } DH_STORAGE_DEVICE;
    
    // OSD channel info
    typedef struct tagNET_SPLIT_OSD
    {
        DWORD               dwSize;
        BOOL                bEnable;                    // enable
        DH_COLOR_RGBA       stuFrontColor;              // The foreground color
        DH_COLOR_RGBA       stuBackColor;               // The background color
        DH_RECT             stuFrontRect;               // Foreground area
        DH_RECT             stuBackRect;                // Background region
        BOOL                bRoll;                      // Whether the scroll display, applies to the text only
        BYTE                byRollMode;                 // Scroll mode, applies only to text, 0 -from left to right,1-from right to left
        BYTE                byRoolSpeed;                // Rolling speed, applies to text  only , 0 ~ 4, the greater the value the faster the scrolling
        BYTE                byFontSize;                 // The font size, applies to the text only
        BYTE                byTextAlign;                // Alignment, 0 - left, 1 - centered, 2 - right
        BYTE                byType;                     // OSD type, 0 - text, 1 - icon
        BYTE                Reserved[3];                // retain byte
        char                szContent[MAX_PATH];        // OSD content, if the type is icon, the content is the name of the icon
        float               fPitch;                     // field interval, 0.0 ~ 5.0
        char                szFontType[DH_COMMON_STRING_64]; // font type
    } NET_SPLIT_OSD;
    
    // CLIENT_GetSplitOSD's interface input param(get split window input OSD info)
    typedef struct tagDH_IN_SPLIT_GET_OSD
    {
        DWORD					dwSize;
        int						nChannel;				// channel no.
        int						nWindow;				// window no.
    } DH_IN_SPLIT_GET_OSD;
    
    // CLIENT_GetSplitOSD's interface input param(get split window output OSD info)
    typedef struct tagDH_OUT_SPLIT_GET_OSD
    {
        DWORD					dwSize;
        int                 nOSDNum;                            // OSD number
        NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
    } DH_OUT_SPLIT_GET_OSD;
    
    // CLIENT_SetSplitOSD's interface input param(setting split window input OSD info)
    typedef struct tagDH_IN_SPLIT_SET_OSD
    {
        DWORD					dwSize;
        int						nChannel;				// channel no.
        int						nWindow;				// window no.
        int                 nOSDNum;                            // OSD number
        NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
    } DH_IN_SPLIT_SET_OSD;
    
    // CLIENT_SetSplitOSD's interface input param(setting split window output OSD info)
    typedef struct tagDH_OUT_SPLIT_SET_OSD
    {
        DWORD					dwSize;
    } DH_OUT_SPLIT_SET_OSD;
    
    // Video output control method
    typedef enum
    {
        EM_VIDEO_OUT_CTRL_CHANNEL,              // Logical channel number control mode,effective for physical screen and splicing screen
        EM_VIDEO_OUT_CTRL_COMPOSITE_ID,         // Splice screen ID control mode, applies to splice screen only
    } EM_VIDEO_OUT_CTRL_TYPE;
    
    // CLIENT_SetSplitSourceEx  The input parameters of the interface
    typedef struct tagNET_IN_SET_SPLIT_SOURCE
    {
        DWORD                   dwSize;
        EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method
        int                     nChannel;           // Video output logical channel number,when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
        const char*             pszCompositeID;     // Splicing screen ID, when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
        int                     nWindow;            // winder number, -1 means all windows of the current segmentation mode
        DH_SPLIT_SOURCE*        pstuSources;        // Video source information, when nWindow=-1, Video source is an array, and the number and the window number
        int                     nSourceCount;       // Video source number
    } NET_IN_SET_SPLIT_SOURCE;
    
    // Set the return result of video source
    typedef struct tagNET_SET_SPLIT_SOURCE_RESULT
    {
        DWORD                   dwSize;
        int                     nPushPort;          // Monitor Port Number of Push Flow Pattern Equipment
    } NET_SET_SPLIT_SOURCE_RESULT;
    
    // CLIENT_SetSplitSourceEx output parameters of the interface
    typedef struct tagNET_OUT_SET_SPLIT_SOURCE
    {
        DWORD                   dwSize;
        NET_SET_SPLIT_SOURCE_RESULT* pstuResults;   // returned value after successful setting , corresponding the window array in NET_IN_SET_SPLIT_SOURCE, user allocates memory , If don't need can be NULL
        int                     nMaxResultCount;    // The size of the pstuResults array
        int                     nRetCount;          // The Number Of Return
    } NET_OUT_SET_SPLIT_SOURCE;
    
    //volume type enumeration
    typedef enum tagNET_VOLUME_TYPE
    {
        VOLUME_TYPE_ALL = 0      ,      //all volume
        VOLUME_TYPE_PHYSICAL     ,      //physical volume
        VOLUME_TYPE_RAID         ,      //Raid volume
        VOLUME_TYPE_VOLUME_GROUP ,      //VG virtual volume
        VOLUME_TYPE_ISCSI        ,      //iSCSI volume
        VOLUME_TYPE_INVIDUAL_PHY ,      //independent physical volume?¡§this physical volume??is not added into?? RAID??virtual volume group??
        VOLUME_TYPE_GLOBAL_SPARE ,      //global hot spare volume
        VOLUME_TYPE_MAX          ,
    }NET_VOLUME_TYPE;
    
    
#define    MAX_DEVICE_VOLUME_NUMS        128                //volume type upper limit
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type port input parameter
    typedef struct tagNET_IN_STORAGE_DEV_NAMES
    {
        DWORD               dwSize;
        NET_VOLUME_TYPE     emVolumeType;       //volume type to get
    } NET_IN_STORAGE_DEV_NAMES;
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type volume output parameter
    typedef struct tagNET_OUT_STORAGE_DEV_NAMES
    {
        DWORD               dwSize;
        int                 nDevNamesNum;                       //got device storage module name quantity
        char                szStoregeDevNames[MAX_DEVICE_VOLUME_NUMS][DH_STORAGE_NAME_LEN]; //device name list
    }NET_OUT_STORAGE_DEV_NAMES;
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port input parameter
    typedef struct tagNET_IN_STORAGE_DEV_INFOS
    {
        DWORD               dwSize;
        NET_VOLUME_TYPE     emVolumeType;       //volume type to get
    } NET_IN_STORAGE_DEV_INFOS;
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port output parameter
    typedef struct tagNET_OUT_STORAGE_DEV_INFOS
    {
        DWORD               dwSize;
        int                 nDevInfosNum;                      //device storage moduleinfo list to get
        DH_STORAGE_DEVICE   stuStoregeDevInfos[MAX_DEVICE_VOLUME_NUMS]; //device info list,DH_STORAGE_DEVICE??dwsize need to assign value
    } NET_OUT_STORAGE_DEV_INFOS;
    
    typedef enum tagNET_RECENCY_CAR_INFO
    {
        RECENCY_CAR_INFO_UNKNOW = 0 ,
        RECENCY_CAR_INFOO_NEWEST    ,      //newest
        RECENCY_CAR_INFO_ODLEST     ,      //oldest
        RECENCY_CAR_INFO_MAX        ,
    }NET_RECENCY_CAR_INFO;
    
    //CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port input parameter
    typedef struct tagNET_IN_GET_RECENCY_JUNCTION_CAR_INFO
    {
        DWORD                   dwSize;
        int                     nChannel;       //snapshot channel no.
        NET_RECENCY_CAR_INFO    emRecencyType;  //get vehicle info type??newest or latest
        DWORD                   nIndex;         //no. vehicle info, from 1??if it is 0, it alsomeans no. 1
    }NET_IN_GET_RECENCY_JUNCTION_CAR_INFO;
    
    //CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port output parameter
    typedef struct tagNET_OUT_GET_RECENCY_JUNCTION_CAR_INFO
    {
        DWORD           dwSize;
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;        // traffic vehicle info
    }NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO;
    
    //
#define NET_MAX_FISHEYE_WINDOW_NUM        8     // Max fish eye window number
    
    // window position info
    typedef struct tagNET_FISHEYE_WINDOW_INFO
    {
        DWORD       dwSize;
        DWORD       dwWindowID;            // window ID
        int        nFocusX;              // EPtz?¡§E-PTZ ??focus horizontal coordinate
        int        nFocusY;              // EPtz (E-PTZ ??focus vertical coordinate
        int        nHorizontalAngle;         // EPtz horizontal degree
        int        nVerticalAngle;          // EPtz vertical degree
    }NET_FISHEYE_WINDOW_INFO;
    
    // corresponding to CLIENT_QueryDevInfo port??NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info input parameter
    typedef struct tagNET_IN_FISHEYE_WININFO
    {
        DWORD        dwSize;
        int         nChannelId;           // channel no.
        int         nWindowNum;           // search window number
        int         nWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // window id??cannot repeat
    }NET_IN_FISHEYE_WININFO;
    
    // corresponding to CLIENT_QueryDevInfo port??NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info output parameter
    typedef struct tagNET_OUT_FISHEYE_WININFO
    {
        DWORD        dwSize;
        int         nWindowNum;           //window number
        NET_FISHEYE_WINDOW_INFO stuWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // windowdetail info
    }NET_OUT_FISHEYE_WININFO;
    
    //CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port input parameter
    typedef struct tagNET_IN_GET_LANES_STATE
    {
        DWORD          dwSize;
        int           nLaneNumber; //-1 represents search all lane,>=0 means search specify lane
    }NET_IN_GET_LANES_STATE;
    
    //signal light indicator status
    typedef enum tagNET_TRAFFIC_LIGHT_STATUS
    {
        LIGHT_STATUS_UNKNOWN = 0  ,  // unknown
        LIGHT_STATUS_RED      ,  //red
        LIGHT_STATUS_GREEN     ,  //green
        LIGHT_STATUS_YELLOW     ,  //yellow
    }NET_TRAFFIC_LIGHT_STATUS;
    
    //signal light indicator info
    typedef struct tatNET_TRAFFIC_LIGHT_INFO
    {
        DWORD            dwSize;
        NET_TRAFFIC_LIGHT_STATUS  emStraightLightInfo;  //straight light status
        NET_TRAFFIC_LIGHT_STATUS  emLeftLightInfo;    //left light status
        NET_TRAFFIC_LIGHT_STATUS  emRightLightInfo;    //right light status
        NET_TRAFFIC_LIGHT_STATUS  emUTurnLightInfo;    //u-turn light status
    }NET_TRAFFIC_LIGHT_INFO;
    
    //lane direction
    typedef enum tagNET_TRAFFIC_DIRECTION
    {
        DIRECTION_UNKNOW  = 0 ,  // unknown
        DIRECTION_STRAIGHT   ,  //straight
        DIRECTION_LEFT     ,  //left
        DIRECTION_RIGHT     ,  //right
        DIRECTION_UTURN     ,  //u-turn
    }NET_TRAFFIC_DIRECTION;
    
    //lane info
    typedef struct tagNET_TRAFFIC_LANE_INFO
    {
        DWORD          dwSize;
        UINT          nLaneNumber;                  //lane no.,0 start
        UINT          nSupportDirectionNum;              //lane can drive direction number
        NET_TRAFFIC_DIRECTION  emTrafficDirections[MAX_LANE_DIRECTION_NUM];  //lane direction, means this lane can drive in all directions
        NET_TRAFFIC_JAM_STATUS emJamState;                   //road jam status
        //flow info
        UINT          nLargeVehicleNum;                //large car quantity
        UINT          nMediumVehicleNum;               //medium car quantity
        UINT          nSmallVehicleNum;                //small car quantity
        UINT          nMotoNum;                    //motor quantity
    }NET_TRAFFIC_LANE_INFO;
    
    //CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port output parameter
    typedef struct tagNET_OUT_GET_LANES_STATE
    {
        DWORD          dwSize;
        int           nGetLaneInfoNum;          // Get lane info quantity
        NET_TRAFFIC_LANE_INFO  stLaneInfos[MAX_LANE_INFO_NUM];   // Get lane info
        NET_TRAFFIC_LIGHT_INFO stLightInfo;            //signal light indicator status
    }NET_OUT_GET_LANES_STATE;
    
    //CLIENT_QueryDevInfo , input param
    typedef struct tagNET_IN_SYSTEM_INFO
    {
        DWORD               dwSize;
    } NET_IN_SYSTEM_INFO;
    
    //CLIENT_QueryDevInfo , output param
    typedef struct tagNET_OUT_SYSTEM_INFO
    {
        DWORD               dwSize;
        BOOL                bHasRTC;                       // whether system has RTC(for recording system time),TRUE:Yes,FALSE:No
    }NET_OUT_SYSTEM_INFO;
    
    
    // port  CLIENT_AttachLanesState input parameter
    typedef NET_OUT_GET_LANES_STATE NET_CB_LANES_STATE;
    
    // port  CLIENT_AttachLanesState call function
    typedef void (CALLBACK *fNotifyLanesState)(LLONG lLanesStateHandle, NET_CB_LANES_STATE* pLanesStateInfo, LDWORD dwUser, void *reserved);
    
    // port  CLIENT_AttachLanesState input parameter
    typedef struct tagNET_IN_ATTACH_LANES_STATE
    {
        DWORD        dwSize;             // this structure size
        int         nChannelID;           // channel no.
        int         nLaneNumber;          // -1order all lanes??>=0 means order specific lane
        
        fNotifyLanesState  cbNotifyLanesState;       // call function
        LDWORD        dwUser;             // user custom parameter
    } NET_IN_ATTACH_LANES_STATE;
    
    // port  CLIENT_AttachLanesState output parameter
    typedef struct tagNET_OUT_ATTACH_LANES_STATE
    {
        DWORD        dwSize;             // this structure size
    } NET_OUT_ATTACH_LANES_STATE;
    
    
    // CLIENT_MatrixSwitch The input parameters
    typedef struct tagNET_IN_MATRIX_SWITCH
    {
        DWORD           dwSize;
        DH_SPLIT_MODE   emSplitMode;                // Segmentation Model
        int*            pnOutputChannels;           // Output channel, can specify multiple output channel switch together at the same time, the content is consistent
        int             nOutputChannelCount;        // Output channel number
        int*            pnInputChannels;            // Input channel, each split window corresponding to one input channel
        int             nInputChannelCount;         // Input channel number
    } NET_IN_MATRIX_SWITCH;
    
    // CLIENT_MatrixSwitch Output Parameters
    
    typedef struct tagNET_OUT_MATRIX_SWITCH
    {
        DWORD            dwSize;
    } NET_OUT_MATRIX_SWITCH;
    
    // CLIENT_SplitSetMultiSource The Input Parameters of the Interface
    typedef struct tagNET_IN_SPLIT_SET_MULTI_SOURCE
    {
        DWORD                   dwSize;
        EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method
        int                     nChannel;           // Video output logical channel number,Effective When emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL
        const char*             pszCompositeID;     // Splicing screen ID,When emCtrlType is EM_VIDEO_OUT_CTRL_COMPOSITE_ID
        BOOL                    bSplitModeEnable;   // Whether to change segmentation model
        DH_SPLIT_MODE           emSplitMode;        // Segmentation model,Enable when bSplitModeEnable=TRUE
        int                     nGroupID;           // Segmentation group number,Effective when bSplitModeEnable=TRUE
        int*                    pnWindows;          // Window Number Array
        int                     nWindowCount;       // Window Number
        DH_SPLIT_SOURCE*        pstuSources;        // Video source information, corresponding to each window, the number with the number of window
    } NET_IN_SPLIT_SET_MULTI_SOURCE;
    
    // CLIENT_SplitSetMultiSource The output parameters of the interface
    typedef struct tagNET_OUT_SPLIT_SET_MULTI_SOURCE
    {
        DWORD                   dwSize;
    } NET_OUT_SPLIT_SET_MULTI_SOURCE;
    
    // Video split operation type
    typedef enum tagNET_SPLIT_OPERATE_TYPE
    {
        NET_SPLIT_OPERATE_SET_BACKGROUND,            // Set background, corresponding NET_IN_SPLIT_SET_BACKGROUND  and NET_OUT_SPLIT_SET_BACKBROUND
        NET_SPLIT_OPERATE_GET_BACKGROUND,            // get background, corresponding NET_IN_SPLIT_GET_BACKGROUND  and NET_OUT_SPLIT_GET_BACKGROUND
        NET_SPLIT_OPERATE_SET_PREPULLSRC,            // set pre stream srouce, corresponding to NET_IN_SPLIT_SET_PREPULLSRC and NET_OUT_SPLIT_SET_PREPULLSRC
        NET_SPLIT_OPERATE_SET_HIGHLIGHT,             // set source frame brightness switch, corresponding to NET_IN_SPLIT_SET_HIGHLIGHT and NET_OUT_SPLIT_SET_HIGHLIGHT
        NET_SPLIT_OPERATE_SET_ZORDER,                // adjust window Z order, corresponding to NET_IN_SPLIT_SET_ZORDER  and  NET_OUT_SPLIT_SET_ZORDER
        NET_SPLIT_OPERATE_SET_TOUR,                  // window tour control, corresponding to NET_IN_SPLIT_SET_TOUR  and  NET_OUT_SPLIT_SET_TOUR
        NET_SPLIT_OPERATE_GET_TOUR_STATUS,           // Get window tour status , corresponding to NET_IN_SPLIT_GET_TOUR_STATUS  and  NET_OUT_SPLIT_GET_TOUR_STATUS
        NET_SPLIT_OPERATE_GET_SCENE,                 // Get screen window info , corresponding to NET_IN_SPLIT_GET_SCENE  and  NET_OUT_SPLIT_GET_SCENE
        NET_SPLIT_OPERATE_OPEN_WINDOWS,              // batch window, corresponding to NET_IN_SPLIT_OPEN_WINDOWS  and  NET_OUT_SPLIT_OPEN_WINDOWS
        NET_SPLIT_OPERATE_SET_WORK_MODE,             // set work mode , corresponding to NET_IN_SPLIT_SET_WORK_MODE  and  NET_OUT_SPLIT_SET_WORK_MODE
        NET_SPLIT_OPERATE_GET_PLAYER,                // Get player example??corresponding to NET_IN_SPLIT_GET_PLAYER  and  NET_OUT_SPLIT_GET_PLAYER
        NET_WM_OPERATE_SET_WORK_MODE,               // Set window working mode??corresponding  NET_IN_WM_SET_WORK_MODE and NET_OUT_WM_SET_WORK_MODE
        NET_WM_OPERATE_GET_WORK_MODE,               // Get window working mode??corresponding  NET_IN_WM_GET_WORK_MODE and NET_OUT_WM_GET_WORK_MODE
        NET_SPLIT_OPERATE_CLOSE_WINDOWS,            // close batch windows NET_IN_SPLIT_CLOSE_WINDOWS ?? NET_OUT_SPLIT_CLOSE_WINDOWS
    } NET_SPLIT_OPERATE_TYPE;
    
    // Set source frame brightness switch input parameter
    typedef struct tagNET_IN_SPLIT_SET_HIGHLIGHT
    {
        DWORD           dwSize;
        int             nChannel;                   // video output channel
        int             nWindow;                    // window no.
        BOOL            bHighLightEn;               // frame brightness,TRUE-high brightness
        DH_COLOR_RGBA   stuColor;                   // frame color
    }NET_IN_SPLIT_SET_HIGHLIGHT;
    
    // set frame brightness enable switch output parameter
    typedef struct tagNET_OUT_SPLIT_SET_HIGHLIGHT
    {
        DWORD           dwSize;
    }NET_OUT_SPLIT_SET_HIGHLIGHT;
    
    // Set pre stream input parameter
    typedef struct tagNET_IN_SPLIT_SET_PREPULLSRC
    {
        DWORD           dwSize;
        int             nChannel;                   // video output channel
        int             nWindow;                    // window no.
        int             nSrcCount;                  // pre stream source quantity
        DH_SPLIT_SOURCE* pSources;                  // re stream source info
    } NET_IN_SPLIT_SET_PREPULLSRC;
    
    // Set pre stream source return result
    typedef struct tagNET_SPLIT_SET_PREPULLSRC_RESULT
    {
        DWORD           dwSize;
        BOOL            bResult;                    // set result, TRUE-successful, FALSE-failed
        DWORD           dwErrorCode;                // Error code
    } NET_SPLIT_SET_PREPULLSRC_RESULT;
    
    // Set pre source output parameter
    typedef struct tagNET_OUT_SPLIT_SET_PREPULLSRC
    {
        DWORD           dwSize;
        int             nResultCount;               // result quantity, same with pre source    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
        NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
    } NET_OUT_SPLIT_SET_PREPULLSRC;
    
    // Set video output background input parameter
    typedef struct tagNET_IN_SPLIT_SET_BACKGROUND
    {
        DWORD            dwSize;
        int              nChannel;                   // Video output channel no.
        BOOL             bEnable;                    // enable
        const char*      pszFileName;                // background name
    } NET_IN_SPLIT_SET_BACKGROUND;
    
    // Set video output background parameter
    typedef struct tagNET_OUT_SPLIT_SET_BACKGROUND
    {
        DWORD            dwSize;
    } NET_OUT_SPLIT_SET_BACKGROUND;
    
    // get video output background input parameter
    typedef struct tagNET_IN_SPLIT_GET_BACKGROUND
    {
        DWORD            dwSize;
        int              nChannel;                   // video output channel o.
    } NET_IN_SPLIT_GET_BACKGROUND;
    
    // get video output background output parameter
    typedef struct tagNET_OUT_SPLIT_GET_BACKGROUND
    {
        DWORD            dwSize;
        BOOL            bEnable;                            // enable
        char            szFileName[DH_COMMON_STRING_256];   // background name
    } NET_OUT_SPLIT_GET_BACKGROUND;
    
    // window Z sequence
    typedef enum tagNET_WINDOW_ZORDER
    {
        NET_WINDOW_ZORDER_TOP,               // top
        NET_WINDOW_ZORDER_BOTTOM,              // bottom
        NET_WINDOW_ZORDER_UP,                // up
        NET_WINDOW_ZORDER_DOWN,               // down
    } NET_WINDOW_ZORDER;
    
    // window layer order
    typedef struct tagDH_WND_ZORDER
    {
        DWORD        dwSize;
        unsigned int    nWindowID;           // window no.
        unsigned int    nZOrder;            // Z order
    } DH_WND_ZORDER;
    
    // set window Z order input parameter
    typedef struct tagNET_IN_SPLIT_SET_ZORDER
    {
        DWORD        dwSize;
        int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*     pszCompositeID;         // cubeless video wall ID
        int         nWindow;            // window no.
        NET_WINDOW_ZORDER  emZOrder;            // adjust Z order
    } NET_IN_SPLIT_SET_ZORDER;
    
    // set window Z order output parameter, adjust one window Z order will affect all windows,  return adjusted all windows?? Z order
    typedef struct tagNET_OUT_SPLIT_SET_ZORDER
    {
        DWORD        dwSize;
        DH_WND_ZORDER*   pZOders;            // window order group, user allocate memory
        int         nMaxWndCount;          // window order group size
        int         nWndCount;           // return window quantity
    } NET_OUT_SPLIT_SET_ZORDER;
    
    // window tour motion
    typedef enum tagEM_NET_WINDOW_TOUR_ACTION
    {
        EM_NET_WND_TOUR_ACTION_START,            //  start
        EM_NET_WND_TOUR_ACTION_STOP,            // stop
    } EM_NET_WINDOW_TOUR_ACTION;
    
    // window tour control input parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
    typedef struct tagNET_IN_SPLIT_SET_TOUR
    {
        DWORD        dwSize;
        int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*     pszCompositeID;         // cubeless video wall ID
        int         nWindow;            // window no.
        EM_NET_WINDOW_TOUR_ACTION emAction;         // tour motion
    } NET_IN_SPLIT_SET_TOUR;
    
    // window tour control output parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
    typedef struct tagNET_OUT_SPLIT_SET_TOUR
    {
        DWORD        dwSize;
    } NET_OUT_SPLIT_SET_TOUR;
    
    // Get window tour status input parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
    typedef struct tagNET_IN_SPLIT_GET_TOUR_STATUS
    {
        DWORD        dwSize;
        int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*     pszCompositeID;         //  cubeless video wall ID
        int         nWindow;            // window no., -1 means all window
    } NET_IN_SPLIT_GET_TOUR_STATUS;
    
    // tour status
    typedef enum tagNET_TOUR_STATUS
    {
        NET_TOUR_UNKNOWN,                // unknown
        NET_TOUR_START,                 // touring
        NET_TOUR_STOP,                 // tour stop
    }NET_TOUR_STATUS;
    
    // window tour status info
    typedef struct tagNET_WINDOW_TOUR_STATUS_INFO
    {
        DWORD        dwSize;
        int         nWindow;            // window no.
        NET_TOUR_STATUS   emStatus;            // status
    } NET_WINDOW_TOUR_STATUS_INFO;
    
    // Get window tour status output parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
    typedef struct tagNET_OUT_SPLIT_GET_TOUR_STATUS
    {
        DWORD        dwSize;
        NET_WINDOW_TOUR_STATUS_INFO* pstuStatus;      // status info indicator, user allocation memory. search window no. is -1 means multi-window info group.
        int         nMaxStatusCount;        // status info max quantity, user input
        int         nRetStatusCount;        // status info actual quantity, search to get
    } NET_OUT_SPLIT_GET_TOUR_STATUS;
    
    // batch window input parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
    typedef struct tagNET_IN_SPLIT_OPEN_WINDOWS
    {
        DWORD        dwSize;
        int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*     pszCompositeID;         //  cubeless video wall id
        int         nWindowNum;           // window quantity
        NET_RECT*      pstuWindowRects;        // window zone group
        BOOL        bDirectable;          // meet direct criteria
    } NET_IN_SPLIT_OPEN_WINDOWS;
    
    // window info
    typedef struct tagNET_SPLIT_WINDOW_INFO
    {
        DWORD        dwSize;
        int         nWindowID;           // window no.
        int         nZOrder;            // Z order
        char        szControlID[DH_DEV_ID_LEN];   // control no.
    } NET_SPLIT_WINDOW_INFO;
    
    // batch window output parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
    typedef struct tagNET_OUT_SPLIT_OPEN_WINDOWS
    {
        DWORD        dwSize;
        NET_SPLIT_WINDOW_INFO* pstuWindows;        // window info , user allocation memory
        int         nMaxWindowCount;        // window info max quantity, user input
        int         nRetWindowCount;        // window quantity
    } NET_OUT_SPLIT_OPEN_WINDOWS;
    
    // video split work mode
    typedef enum tagNET_SPLIT_WORK_MODE
    {
        NET_SPLIT_WORK_MODE_UNKNOWN,            // unknown
        NET_SPLIT_WORK_MODE_LOCAL,             // local normal mode
        NET_SPLIT_WORK_MODE_REPLAY,             // playback mode
    }NET_SPLIT_WORK_MODE;
    
    // setup work mode input parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
    typedef struct tagNET_IN_SPLIT_SET_WORK_MODE
    {
        DWORD        dwSize;
        int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*     pszCompositeID;         //  cubeless video wall ID
        NET_SPLIT_WORK_MODE emMode;             // work mode
    }NET_IN_SPLIT_SET_WORK_MODE;
    
    // setup work mode output parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
    typedef struct tagNET_OUT_SPLIT_SET_WORK_MODE
    {
        DWORD        dwSize;
    }NET_OUT_SPLIT_SET_WORK_MODE;
    
    // player type
    typedef enum tagNET_SPLIT_PLAYER_TYPE
    {
        NET_SPLIT_PLAYER_TYPE_UNKNOWN,            // unknown
        NET_SPLIT_PLAYER_TYPE_FILE_LIST,           // file list player
        NET_SPLIT_PLAYER_TYPE_FILE,             // file player
    }NET_SPLIT_PLAYER_TYPE;
    
    // Get player actual input parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
    typedef struct tagNET_IN_SPLIT_GET_PLAYER
    {
        DWORD         dwSize;
        int          nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid
        const char*      pszCompositeID;         //  cubeless video wall ID
        NET_SPLIT_PLAYER_TYPE emType;             // player type
        int          nWindow;            // player window no.
    }NET_IN_SPLIT_GET_PLAYER;
    
    // Get player actual output parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
    typedef struct tagNET_OUT_SPLIT_GET_PLAYER
    {
        DWORD         dwSize;
        LLONG         lPlayerID;           // player actual ID
    }NET_OUT_SPLIT_GET_PLAYER;
    
    // Window Working Mode
    typedef enum tagNET_WM_WORK_MODE
    {
        NET_WM_WORK_MODE_UNKNOWN,                             // Unknown
        NET_WM_WORK_MODE_DISPLAY,                             // Preview mode
        NET_WM_WORK_MODE_REPLAY,                              // Playback mode
    }NET_WM_WORK_MODE;
    
    // Set window working mode input parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
    typedef struct tagNET_IN_WM_SET_WORK_MODE
    {
        DWORD                 dwSize;
        int                   nChannel;                       // Output channel no. or cubeless video wall virtual channel no., when pszCompositeID is NULL. valid
        const char*           pszCompositeID;                 // Cubeless video wall ID
        int                   nWindow;                        // Window no.
        NET_WM_WORK_MODE      emMode;                         // Window working mode
    }NET_IN_WM_SET_WORK_MODE;
    
    //Set window working mode output parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
    typedef struct tagNET_OUT_WM_SET_WORK_MODE
    {
        DWORD                 dwSize;
    }NET_OUT_WM_SET_WORK_MODE;
    
    // Get window woking mode input parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
    typedef struct tagNET_IN_WM_GET_WORK_MODE
    {
        DWORD                 dwSize;
        int                   nChannel;                       // Output channel no. or cubeless virtual channel no., when pszCompositeID is NULL, valid
        const char*           pszCompositeID;                 // Cubeless video wall ID
        int                   nWindow;                        // Window no.
    }NET_IN_WM_GET_WORK_MODE;
    
    //Get window working mode output parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
    typedef struct tagNET_OUT_WM_GET_WORK_MODE
    {
        DWORD                 dwSize;
        NET_WM_WORK_MODE      emMode;                         // Window working mode
    }NET_OUT_WM_GET_WORK_MODE;
    
    // The input for close batch windows,  corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
    typedef struct tagNET_IN_SPLIT_CLOSE_WINDOWS
    {
        DWORD               dwSize;
        int                 nChannel;                       // Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
        const char*         pszCompositeID;                 // Multi-screen display ID
        int*                pnWindows;                      // The pointer of windows index array
        int                 nWindowCount;                   // The number of windows
    } NET_IN_SPLIT_CLOSE_WINDOWS;
    
    // Close windows operation result
    typedef struct tagNET_SPLIT_CLOSE_WINDOW_RESULT
    {
        BOOL                bResult;                        // Result
        char                reserved[256];                  // Reserved bytes
    } NET_SPLIT_CLOSE_WINDOW_RESULT ;
    
    // The output parameters of Close batch windows, corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
    typedef struct tagNET_OUT_SPLIT_CLOSE_WINDOWS
    {
        DWORD               dwSize;
        NET_SPLIT_CLOSE_WINDOW_RESULT* pstuResults;         // Result array, memory assigned by users. Set to Null if no need the return
        int                 nMaxResultCount;                // The maximum of result array, filled in by user.
        int                 nRetResultCount;                // The number of return result
        
    } NET_OUT_SPLIT_CLOSE_WINDOWS;
    
    ////////////////////////////////// System status////////////////////////////////////////
    
    // CPU info
    typedef struct tagDH_CPU_INFO
    {
        DWORD				dwSize;
        int					nUsage;						// CPU usage
    } DH_CPU_INFO;
    
    // CPU status
    typedef struct tagDH_CPU_STATUS
    {
        DWORD				dwSize;
        BOOL				bEnable;					// Search succeeded or not
        int					nCount;						// CPU amount
        DH_CPU_INFO			stuCPUs[DH_MAX_CPU_NUM];	// CPU info
    } DH_CPU_STATUS;
    
    // Memory info
    typedef struct tagDH_MEMORY_INFO
    {
        DWORD				dwSize;
        DWORD				dwTotal;					// Total memory, M
        DWORD				dwFree;						// Free memory, M
    } DH_MEMORY_INFO;
    
    // Memory status
    typedef struct tagDH_MEMORY_STATUS
    {
        DWORD				dwSize;
        BOOL				bEnable;					// Search succeeded or not
        DH_MEMORY_INFO		stuMemory;					// Memory info
    } DH_MEMORY_STATUS;
    
    // Fan info
    typedef struct tagDH_FAN_INFO
    {
        DWORD				dwSize;
        char				szName[DH_DEVICE_NAME_LEN];	// Name
        DWORD				nSpeed;						// Speed
    } DH_FAN_INFO;
    
    // Fan status
    typedef struct tagDH_FAN_STATUS
    {
        DWORD				dwSize;
        BOOL				bEnable;					// Search succeeded or not
        int					nCount;						// Fan amount
        DH_FAN_INFO			stuFans[DH_MAX_FAN_NUM];	// Fan status
    } DH_FAN_STATUS;
    
    // power current status type
    typedef enum __EM_CURRENT_STATE_TYPE
    {
        EM_CURRENT_STATE_UNKNOWN = 0,
        EM_CURRENT_STATE_OVER_CURRENT,                      // current too high
        EM_CURRENT_STATE_NORMAL,                            // current normal
        EM_CURRENT_STATE_UNDER_CURRENT,                     // current too low
    }EM_CURRENT_STATE_TYPE;
    
    // Power info
    typedef struct tagDH_POWER_INFO
    {
        DWORD               dwSize;
        BOOL                bPowerOn;                       // Power is on or not
        EM_CURRENT_STATE_TYPE emCurrentState;               // power current status
    } DH_POWER_INFO;
    
    
    // battery in-place status
    typedef enum __EM_BATTERY_EXIST_STATE
    {
        EM_BATTERY_EXIST_STATE_UNKNOWN = 0,
        EM_BATTERY_EXIST_STATE_EXIST,                       // battery in-place
        EM_BATTERY_EXIST_STATE_MISSING,                     // battery lost
    }EM_BATTERY_EXIST_STATE;
    
    // battery status
    typedef enum __EM_BATTERY_STATE
    {
        EM_BATTERY_STATE_UNKNOWN = 0,
        EM_BATTERY_STATE_NORMAL,							// normal power
        EM_BATTERY_STATE_LOW,								// low power
    }EM_BATTERY_STATE;
    
    // Battery Information
    typedef struct tagDH_BATTERY_INFO
    {
        DWORD               dwSize;
        int                 nPercent;                       // Battery Capacity Percentage
        BOOL                bCharging;                      // Whether real charging
        EM_BATTERY_EXIST_STATE emExistState;                // battery in-place status
        EM_BATTERY_STATE	emState;						// battery power status
    } DH_BATTERY_INFO;
    
    // Power status
    typedef struct tagDH_POWER_STATUS
    {
        DWORD				dwSize;
        BOOL				bEnable;					//Search succeeded or not
        int					nCount;						// Power amount
        DH_POWER_INFO		stuPowers[DH_MAX_POWER_NUM];// Power status
        int                 nBatteryNum;                        // Battery Number
        DH_BATTERY_INFO     stuBatteries[DH_MAX_BATTERY_NUM];   // Battery Status
    } DH_POWER_STATUS;
    
    // Temperature info
    typedef struct tagDH_TEMPERATURE_INFO
    {
        DWORD				dwSize;
        char				szName[DH_DEVICE_NAME_LEN];	// Sensor name
        float				fTemperature;				// Temperature
    } DH_TEMPERATURE_INFO;
    
    //Temperature status
    typedef struct tagDH_TEMPERATURE_STATUS
    {
        DWORD				dwSize;
        BOOL				bEnable;							// Search succeeded or not
        int					nCount;								// Temperature  amount
        DH_TEMPERATURE_INFO	stuTemps[DH_MAX_TEMPERATURE_NUM];	// Temperature  info
    } DH_TEMPERATURE_STATUS;
    
    // System status
    typedef struct tagDH_SYSTEM_STATUS
    {
        DWORD				dwSize;
        DH_CPU_STATUS*		pstuCPU;					// CPU status
        DH_MEMORY_STATUS*	pstuMemory;					// Memory status
        DH_FAN_STATUS*		pstuFan;					// Fan status
        DH_POWER_STATUS*	pstuPower;					// Power status
        DH_TEMPERATURE_STATUS*	pstuTemp;				// Temperature  status
    } DH_SYSTEM_STATUS;
    
    // Corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE Command Parameter
    // For Alarm Channel Status
    typedef enum tagNET_ALARM_CHANNEL_TYPE
    {
        NET_ALARM_CHANNEL_TYPE_ALL,                             // All channels (including all of the following)
        NET_ALARM_CHANNEL_TYPE_ALARMIN,                         // Alarm input channel
        NET_ALARM_CHANNEL_TYPE_ALARMOUT,                        // Alarm output channel
        NET_ALARM_CHANNEL_TYPE_ALARMBELL,                       // Signal channel
        NET_ALARM_CHANNEL_TYPE_EXALARMIN,                       // Extension module alarm input channel
        NET_ALARM_CHANNEL_TYPE_EXALARMOUT,                      // Extension module and alarm output channel
    }NET_ALARM_CHANNEL_TYPE;
    
    typedef struct tagNET_CLIENT_ALARM_CHANNELS_STATE
    {
        DWORD                       dwSize;
        NET_ALARM_CHANNEL_TYPE      emType;                     // The type of query alarm channel
        int                         nAlarmInCount;              // Alarm input number, specified by the user
        int                         nAlarmInRetCount;           // The number of returned alarm input
        BOOL*                       pbAlarmInState;             // Alarm state of input arrays, memory allocated by the user, each element represents a channel status, TRUE for input, FALSE for no input
        int                         nAlarmOutCount;             // The number of alarm output,specified by the user
        int                         nAlarmOutRetCount;          // The number of alarm output
        BOOL*                       pbAlarmOutState;            // Alarm state of output arrays, memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output
        int                         nAlarmBellCount;            // Alarm Number,specified by the user
        int                         nAlarmBellRetCount;         // Returned Alarm Number
        BOOL*                       pbAlarmBellState;           // Alarm state array, allocate memory by the user, each element represents a channel status, TRUE for output, FALSE for no output
        int                         nExAlarmInCount;            // Extension module alarm input number, specified by the user
        int                         nExAlarmInRetCount;         // The number of returned extension module alarm input
        BOOL*                       pbExAlarmInState;           // Extension module alarm input state array??Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output
        int*                        pnExAlarmInDestionation;    // The location of the extension module alarm input effective channels
        int                         nExAlarmOutCount;           // Extension module alarm output number, specified by the user
        int                         nExAlarmOutRetCount;        // Extension module alarm output number
        BOOL*                       pbExAlarmOutState;          // Extension module alarm output state array??Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output
        int*                        pnExAlarmOutDestionation;   // The location of the extension module alarm output effective channels
    }NET_CLIENT_ALARM_CHANNELS_STATE;
    
    
    // the number of alarm keyboard connecting on a serial port
    typedef struct tagNET_ALARMKEYBOARD_COUNT
    {
        DWORD               dwSize;
        int                 nAlarmKeyboardCount;        // The number of alarm keyboard connected
    }NET_ALARMKEYBOARD_COUNT;
    
    ////////////////////////////////// screen control////////////////////////////////////////
    // CLIENT_OpenSplitWindow's interface input param(open window)
    typedef struct tagDH_IN_SPLIT_OPEN_WINDOW
    {
        DWORD				dwSize;
        int					nChannel;					// channel no.
        DH_RECT				stuRect;					// windon position, 0~8192
        BOOL				bDirectable;				// coordinate whether meet the confitions
    } DH_IN_SPLIT_OPEN_WINDOW;
    
    // CLIENT_OpenSplitWindow's interface output param(open window)
    typedef struct tagDH_OUT_SPLIT_OPEN_WINDOW
    {
        DWORD				dwSize;
        unsigned int		nWindowID;					// window ID
        unsigned int		nZOrder;					// window order
    } DH_OUT_SPLIT_OPEN_WINDOW;
    
    // CLIENT_CloseSplitWindow's interface input param(close window)
    typedef struct tagDH_IN_SPLIT_CLOSE_WINDOW
    {
        DWORD				dwSize;
        int					nChannel;					// channel ID
        UINT				nWindowID;					// window order
        const char*         pszCompositeID;             // multi-screen display ID
    } DH_IN_SPLIT_CLOSE_WINDOW;
    
    // CLIENT_CloseSplitWindow's interface output param(close window)
    typedef struct tagDH_OUT_SPLIT_CLOSE_WINDOW
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_CLOSE_WINDOW;
    
    // CLIENT_SetSplitWindowRect's interface input param(setting the window position)
    typedef struct tagDH_IN_SPLIT_SET_RECT
    {
        DWORD				dwSize;
        int					nChannel;					// channel ID
        UINT				nWindowID;					// window order
        DH_RECT				stuRect;					// window position, 0~8192
        BOOL				bDirectable;				//  coordinate whether meet the confitions
    } DH_IN_SPLIT_SET_RECT;
    
    // CLIENT_SetSplitWindowRect's interface output param(setting the window position)
    typedef struct tagDH_OUT_SPLIT_SET_RECT
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_SET_RECT;
    
    // CLIENT_GetSplitWindowRect's interface input param(get window position)
    typedef struct tagDH_IN_SPLIT_GET_RECT
    {
        DWORD				dwSize;
        int					nChannel;					// channel ID
        UINT				nWindowID;					// window ID
    } DH_IN_SPLIT_GET_RECT;
    
    // CLIENT_GetSplitWindowRect's interface output param(get window position)
    typedef struct tagDH_OUT_SPLIT_GET_RECT
    {
        DWORD				dwSize;
        DH_RECT				stuRect;					// window position, 0~8192
    } DH_OUT_SPLIT_GET_RECT;
    
    // CLIENT_SetSplitWindowLevels's interface input param(setting window order)
    typedef struct tagDH_IN_SPLIT_SET_TOP_WINDOW
    {
        DWORD				dwSize;
        int					nChannel;					// channel ID
        int					nWindowID;					// windown ID
    } DH_IN_SPLIT_SET_TOP_WINDOW;
    
    // CLIENT_SetSplitWindowLevels's interface output param(setting window order)
    typedef struct tagDH_OUT_SPLIT_SET_TOP_WINDOW
    {
        DWORD				dwSize;
        DH_WND_ZORDER*		pZOders;					// window order array
        int					nMaxWndCount;				// window order array size
        int					nWndCount;					// count of returned window
    } DH_OUT_SPLIT_SET_TOP_WINDOW;
    
    // CLIENT_SetDisplayMode's interface input param(monitor wall display mode settings)
    typedef struct tagDH_IN_WM_SET_DISPLAY_MODE
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszBlockID;					// block ID, NULL/""-all region
        int					nTVID;						// display unit ID, -1 means all unit
        UINT				nDisplayMode;				// display mode, 0-standard, 1-highlighting, 2-energy saving
    } DH_IN_WM_SET_DISPLAY_MODE;
    
    // CLIENT_SetDisplayMode's interface output param(monitor wall display mode settings)
    typedef struct tagDH_OUT_WM_SET_DISPLAY_MODE
    {
        DWORD				dwSize;
    } DH_OUT_WM_SET_DISPLAY_MODE;
    
    // all display unit in the area of the display mode
    typedef struct tagDH_BLOCK_DISPLAY_MODE
    {
        DWORD				dwSize;
        int*				pTVModes;					// TV display mode
        int					nMaxTVCount;				// max count of tV
        int					nRetTVCount;				// count of retTV
    } DH_BLOCK_DISPLAY_MODE;
    
    // CLIENT_GetDisplayMode's interface input param(get monitor wall display mode)
    typedef struct tagDH_IN_WM_GET_DISPLAY_MODE
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszBlockID;					// block ID, NULL/""-means all
        int					nTVID;						// TV ID, -1 means all
    } DH_IN_WM_GET_DISPLAY_MODE;
    
    // CLIENT_GetDisplayMode's interface output param(get monitor wall display mode)
    typedef struct tagDH_OUT_WM_GET_DISPLAY_MODE
    {
        DWORD				dwSize;
        DH_BLOCK_DISPLAY_MODE* pBlockModes;				// display mode
        int					nMaxBlockCount;				// count of array
        int					nRetBlockCount;				// count of ret
    } DH_OUT_WM_GET_DISPLAY_MODE;
    
    // CLIENT_PowerControl's interface input param(monitor wall power control)
    typedef struct tagDH_IN_WM_POWER_CTRL
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszBlockID;					// block ID, NULL/""- means all
        int					nTVID;						// TV ID, -1 means all
        BOOL				bPowerOn;					// power on or not
    } DH_IN_WM_POWER_CTRL;
    
    // CLIENT_PowerControl's interface input param(monitor wall power control)
    typedef struct tagDH_OUT_WM_POWER_CTRL
    {
        DWORD				dwSize;
    } DH_OUT_WM_POWER_CTRL;
    
    // CLIENT_LoadMonitorWallCollection's interface input param(load monitor wall plans)
    typedef struct tagDH_IN_WM_LOAD_COLLECTION
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszName;					// name of plan
    } DH_IN_WM_LOAD_COLLECTION;
    
    // CLIENT_LoadMonitorWallCollection's interface output param(load monitor wall plans)
    typedef struct tagDH_OUT_WM_LOAD_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_WM_LOAD_COLLECTION;
    
    // CLIENT_SaveMonitorWallCollection's interface input param(save monitor wall plans)
    typedef struct tagDH_IN_WM_SAVE_COLLECTION
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszName;					// name pf plan
        const char*         pszControlID;               // control id
    } DH_IN_WM_SAVE_COLLECTION;
    
    // CLIENT_SaveMonitorWallCollection's interface output param(load monitor wall plans)
    typedef struct tagDH_OUT_WM_SAVE_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_WM_SAVE_COLLECTION;
    
    // CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
    typedef struct tagDH_IN_WM_RENAME_COLLECTION
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
        const char*			pszOldName;					// old name
        const char*			pszNewName;					// new name
    } DH_IN_WM_RENAME_COLLECTION;
    
    // CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
    typedef struct tagDH_OUT_WM_RENAME_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_WM_RENAME_COLLECTION;
    
    // infomation window areas
    typedef struct tagDH_WINDOW_COLLECTION
    {
        DWORD				dwSize;
        int					nWindowID;					// window ID
        BOOL				bWndEnable;					// enable
        DH_RECT				stuRect;					// rect, effect when free split mode
        BOOL				bDirectable;				// coordinate whether meet the conditions
        int					nZOrder;					// z order
        BOOL				bSrcEnable;					// source enable
        char				szDeviceID[DH_DEV_ID_LEN_EX]; // device ID
        int					nVideoChannel;				// video channel
        int					nVideoStream;				// video stream type
        int					nAudioChannel;				// audio channel
        int					nAudioStream;				// audio stream type
        int					nUniqueChannel;				// unique channel
    } DH_WINDOW_COLLECTION;
    
    // areas collection
    typedef struct tagDH_BLOCK_COLLECTION
    {
        DWORD				dwSize;
        DH_SPLIT_MODE		emSplitMode;				// split mode
        DH_WINDOW_COLLECTION stuWnds[DH_MAX_SPLIT_WINDOW];// window info array
        int					nWndsCount;					// count of window
        char				szName[DH_DEVICE_NAME_LEN];	// favorites name
        int                  nScreen;                       // The output channel number, including the splicing screen
        char                szCompositeID[DH_DEV_ID_LEN_EX]; //  splicing video wall ID
        DH_WINDOW_COLLECTION* pstuWndsEx;                   // Windows information array pointer, the memory assigned by user. Use when the size of stuWnds array is not enough.
        int                  nMaxWndsCountEx;               // The maximum number of windows, filled by user. pstuWndsEx the muber of the array element.
        int                  nRetWndsCountEx;               // The number of return windows.
    } DH_BLOCK_COLLECTION;
    
    // TV wall display unit
    typedef struct tagDH_MONITORWALL_OUTPUT
    {
        DWORD       dwSize;
        char        szDeviceID[DH_DEV_ID_LEN];     // device ID, local time is""
        int         nChannel;              // channel no.
        char        szName[DH_DEV_NAME_LEN];      // screen name
    } DH_MONITORWALL_OUTPUT;
    
    // TV wall display block
    typedef struct tagDH_MONITORWALL_BLOCK
    {
        DWORD          dwSize;
        char          szName[DH_DEV_NAME_LEN];    // block name
        char          szCompositeID[DH_DEV_ID_LEN];  //  splicing video wall ID
        char          szControlID[DH_DEV_ID_LEN];   // control ID
        int           nSingleOutputWidth;       // single display unit occupied grid column number
        int           nSingleOutputHeight;      // single display unit occupied grid row number
        DH_RECT         stuRect;            // zone coordinate
        DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // switch on time chart, first-dimension each element means sunday~saturday and holiday
        DH_MONITORWALL_OUTPUT* pstuOutputs;          // display unit data,  user allocation memory
        int           nMaxOutputCount;        // display unit group size,user fill in
        int           nRetOutputCount;        // return display unit quantity
    } DH_MONITORWALL_BLOCK;
    
    // tv wall config
    typedef struct tagDH_MONITORWALL
    {
        DWORD          dwSize;
        char          szName[DH_DEV_NAME_LEN];    // name
        int           nGridLine;           // grid row
        int           nGridColume;          // grid column
        DH_MONITORWALL_BLOCK*  pstuBlocks;           // display block group, user allocation nmemory
        int           nMaxBlockCount;         // display zone group size, user fill in
        int           nRetBlockCount;         // return display block quantity
        BOOL          bDisable;            // disable or not, 0-tv wall is valid , 1-tv wall is invalid
        char          szDesc[DH_COMMON_STRING_256];  // tv wall description info
    } DH_MONITORWALL;
    
    
    // plan of monitor wall
    typedef struct tagDH_MONITORWALL_COLLECTION
    {
        DWORD				dwSize;
        char				szName[DH_DEVICE_NAME_LEN];	// name
        DH_BLOCK_COLLECTION	stuBlocks[DH_MAX_BLOCK_NUM];// area array
        int					nBlocksCount;				// area count
        char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
        DH_MONITORWALL      stuMonitorWall;             // tv wall config
    } DH_MONITORWALL_COLLECTION;
    
    // CLIENT_GetMonitorWallCollections's interface input param(get plan infomation of monitor wall)
    typedef struct tagDH_IN_WM_GET_COLLECTIONS
    {
        DWORD				dwSize;
        int					nMonitorWallID;				// monitor wall ID
    } DH_IN_WM_GET_COLLECTIONS;
    
    // CLIENT_GetMonitorWallCollections's interface output param(get plan infomation of monitor wall)
    typedef struct tagDH_OUT_WM_GET_COLLECTIONS
    {
        DWORD				dwSize;
        DH_MONITORWALL_COLLECTION* pCollections;		// plan of monitor wall array
        int					nMaxCollectionsCount;		// array size
        int					nCollectionsCount;			// max count of plan
    } DH_OUT_WM_GET_COLLECTIONS;
    
    // CLIENT_GetSplitWindowsInfo's interface input param
    typedef struct tagDH_IN_SPLIT_GET_WINDOWS
    {
        DWORD				dwSize;
        int					nChannel;					// channel
    } DH_IN_SPLIT_GET_WINDOWS;
    
    // CLIENT_GetSplitWindowsInfo's interface output param
    typedef struct tagDH_OUT_SPLIT_GET_WINDOWS
    {
        DWORD				dwSize;
        DH_BLOCK_COLLECTION	stuWindows;					// channel
    } DH_OUT_SPLIT_GET_WINDOWS;
    
    // CLIENT_LoadSplitCollection's interface input param(load collection)
    typedef struct tagDH_IN_SPLIT_LOAD_COLLECTION
    {
        DWORD				dwSize;
        int					nChannel;					// channel
        const char*			pszName;					// name
    } DH_IN_SPLIT_LOAD_COLLECTION;
    
    // CLIENT_LoadSplitCollection's interface output param(load collection)
    typedef struct tagDH_OUT_SPLIT_LOAD_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_LOAD_COLLECTION;
    
    // CLIENT_SaveSplitCollection's interface input param(save collection)
    typedef struct tagDH_IN_SPLIT_SAVE_COLLECTION
    {
        DWORD				dwSize;
        int					nChannel;					// channle
        const char*			pszName;					// name
    } DH_IN_SPLIT_SAVE_COLLECTION;
    
    // CLIENT_SaveSplitCollection's interface input param(save collection)
    typedef struct tagDH_OUT_SPLIT_SAVE_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_SAVE_COLLECTION;
    
    // CLIENT_RenameSplitCollection's interface input param(collection rename)
    typedef struct tagDH_IN_SPLIT_RENAME_COLLECTION
    {
        DWORD				dwSize;
        int					nChannel;					// channel
        const char*			pszOldName;					// old name
        const char*			pszNewName;					// new name
    } DH_IN_SPLIT_RENAME_COLLECTION;
    
    // CLIENT_RenameSplitCollection's interface output param(collection rename)
    typedef struct tagDH_OUT_SPLIT_RENAME_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_RENAME_COLLECTION;
    
    // CLIENT_GetSplitCollections's interface input param(get infomation of favorites)
    typedef struct tagDH_IN_SPLIT_GET_COLLECTIONS
    {
        DWORD				dwSize;
        int					nChannel;					// channel
    } DH_IN_SPLIT_GET_COLLECTIONS;
    
    // CLIENT_GetSplitCollections's interface output param(get infomation of favorites)
    typedef struct tagDH_OUT_SPLIT_GET_COLLECTIONS
    {
        DWORD				dwSize;
        DH_BLOCK_COLLECTION* pCollections;				// array
        int					nMaxCollectionsCount;		// size
        int					nCollectionsCount;			// count
    } DH_OUT_SPLIT_GET_COLLECTIONS;
    
    // CLIENT_DeleteSplitCollection's interface input param(delete favorites)
    typedef struct tagDH_IN_SPLIT_DELETE_COLLECTION
    {
        DWORD				dwSize;
        int					nChannel;					// channel
        const char**		ppszNames;					// array of favorites name
        int					nNameCount;					// size of array
    } DH_IN_SPLIT_DELETE_COLLECTION;
    
    // CLIENT_DeleteSplitCollection's interface input param(delete favorites)
    typedef struct tagDH_OUT_SPLIT_DELETE_COLLECTION
    {
        DWORD				dwSize;
    } DH_OUT_SPLIT_DELETE_COLLECTION;
    
    // composite screen channel information
    typedef struct tagDH_COMPOSITE_CHANNEL
    {
        DWORD				dwSize;
        char				szMonitorWallName[DH_DEVICE_NAME_LEN];	// monitor wall name
        char				szCompositeID[DH_DEV_ID_LEN_EX];		// composite ID
        int					nVirtualChannel;						// virtual channel
    } DH_COMPOSITE_CHANNEL;
    
    // tour enable configuration
    typedef struct tagDHDEV_TOUR_ENABLE
    {
        DWORD				dwSize;
        BOOL				bEnable;					// enable
        BOOL				bStart;						// is touring or not(read only). bStart=FALSE when tour is able but doesn't set
    } DHDEV_TOUR_ENABLE_CFG;
    
    // CLIENT_SetDecodePolicy's interface input param(set the decoding policy)
    typedef struct tagDH_IN_SET_DEC_POLICY
    {
        DWORD				dwSize;
        int					nChannel;			// channel
        int					nWindow;			// window no., -1 means all
        int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
        // -2 real-time good, 2 fluency good, 0 default
    } DH_IN_SET_DEC_POLICY;
    
    // CLIENT_SetDecodePolicy's interface output param(set the decoding policy)
    typedef struct tagDH_OUT_SET_DEC_POLICY
    {
        DWORD				dwSize;
    } DH_OUT_SET_DEC_POLICY;
    
    // CLIENT_GetDecodePolicy's interface input param(get the decoding policy)
    typedef struct tagDH_IN_GET_DEC_POLICY
    {
        DWORD				dwSize;
        int					nChannel;			// channel
        int					nWindow;			// window ID, -1 means all
    } DH_IN_GET_DEC_POLICY;
    
    // CLIENT_GetDecodePolicy's interface output param(get the decoding policy)
    typedef struct tagDH_OUT_GET_DEC_POLICY
    {
        DWORD				dwSize;
        int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
        // -2 real-time good, 2 fluency good, 0 default
    } DH_OUT_GET_DEC_POLICY;
    
    // audio output mode
    typedef enum
    {
        DH_AUDIO_AUTO,							// automatic switch
        DH_AUDIO_DISABLE,						// all output disable
        DH_AUDIO_FORCE,							// mandatory audio output to the user to specify a window
        DH_AUDIO_ENABLE_ONE,                        // Open the audio of target window, multi-channel of audio output is available
        DH_AUDIO_DISABLE_ONE,                       //Close the audio of target window, multi-channel of audio output is available
        DH_AUDIO_MULTI,                             // Multi-channel of audio output, be used when inquire not setting
    } DH_AUDIO_OUTPUT_MODE;
    
    // CLIENT_SetSplitAudioOuput's interface input param(set mode of audio output)
    typedef struct tagDH_IN_SET_AUDIO_OUTPUT
    {
        DWORD				dwSize;
        int					nChannel;			// channel ID
        DH_AUDIO_OUTPUT_MODE emMode;			// mode
        int					nWindow;			// window no. , effect when emMode = DH_AUDIO_FORCE
    } DH_IN_SET_AUDIO_OUTPUT;
    
    // CLIENT_SetSplitAudioOuput's interface output param(set mode of audio output)
    typedef struct tagDH_OUT_SET_AUDIO_OUTPUT
    {
        DWORD				dwSize;
    } DH_OUT_SET_AUDIO_OUTPUT;
    
    // CLIENT_GetSplitAudioOuput's interface input param(get mode of audio output)
    typedef struct tagDH_IN_GET_AUDIO_OUTPUT
    {
        DWORD				dwSize;
        int					nChannel;			// channel ID
    } DH_IN_GET_AUDIO_OUTPUT;
    
    // CLIENT_GetSplitAudioOuput's interface output param(get mode of audio output)
    typedef struct tagDH_OUT_GET_AUDIO_OUTPUT
    {
        DWORD				dwSize;
        DH_AUDIO_OUTPUT_MODE emMode;			// mode of audio output
        int					nWindow;			// window no., effect when emMode = DH_AUDIO_FORCE
        int*                 pMultiWindows;         // The list of output windows number, valid when emMode = DH_AUDIO_MULTI, user assign the memory
        int                  nMaxMultiWindowCount;  // ouput the maximum number of window list, filled by user
        int                  nRetMultiWindowCount;  // Output the number of windows, effect  when  emMode=DH_AUDIO_MULTI
    } DH_OUT_GET_AUDIO_OUTPUT;
    
    // CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
    typedef struct tagDH_IN_GET_ENCODE_PLAN
    {
        DWORD				dwSize;
        unsigned int        nChannel;          // channel
        unsigned int        nExpectTime;       // expect time,int(min)
        unsigned int        nCapacity;         // capacity,int(M)
    }DH_IN_GET_ENCODE_PLAN;
    // CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
    typedef struct tagDH_OUT_GET_ENCODE_PLAN
    {
        DWORD				dwSize;
        int                 nResolutionType;    // emResolutionTypes counts
        CAPTURE_SIZE        emResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// the scope of video resolution
        CAPTURE_SIZE        emResolution;       // the recommended video resolution
        unsigned int        nBitRate;           // bit rate
    }DH_OUT_GET_ENCODE_PLAN;
    
    // organization directory logical objects
    typedef struct tagDH_ORGANIZATION_NODE_LOGIC_OBJECT
    {
        DWORD				dwSize;
        char				szName[DH_NODE_NAME_LEN];	// name
        char				szType[DH_DEV_TYPE_LEN];	// type
        char				szDevID[DH_DEV_ID_LEN_EX];	// deviceID
        char				szControlID[DH_DEV_ID_LEN_EX]; // control ID, read only
        int					nChannel;					// channel
    } DH_ORGANIZATION_NODE_LOGIC_OBJECT;
    
    // organization directory
    typedef struct tagDH_ORGANIZATION_NODE_DIRECTORY
    {
        DWORD				dwSize;
        char				szName[DH_NODE_NAME_LEN];		// name
        char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
    } DH_ORGANIZATION_NODE_DIRECTORY;
    
    // info of organization directory node
    typedef struct tagDH_ORGANIZATION_NODE
    {
        DWORD				dwSize;
        int					nNodeType;						// node type, 0-logical objects, 1-list
        DH_ORGANIZATION_NODE_LOGIC_OBJECT	stuLogicObject;	// logical object, effective when nNodeType==0
        DH_ORGANIZATION_NODE_DIRECTORY		stuDirectory;	// list,effective when nNodeType==1
    } DH_ORGANIZATION_NODE;
    
    // add node param
    typedef struct tagDH_ORGANIZATION_ADD_NODE_PARAM
    {
        DWORD				dwSize;
        int					nPosition;					// position, -1-start, -2-end, 0~n
        DH_ORGANIZATION_NODE stuNode;					// info of node
    } DH_ORGANIZATION_ADD_NODE_PARAM;
    
    // CLIENT_OrganizationAddNodes's interface input param(add node)
    typedef struct tagDH_IN_ORGANIZATION_ADD_NODES
    {
        DWORD				dwSize;
        char*				pszPath;					// path
        DH_ORGANIZATION_ADD_NODE_PARAM* pstuNodes;		// node pointer
        int					nNodeCount;					// count of node
    } DH_IN_ORGANIZATION_ADD_NODES;
    
    // result of added node
    typedef struct tagDH_ORGANIZATION_ADD_NODE_RESULT
    {
        DWORD				dwSize;
        BOOL				bResult;					// result
        char				szPath[MAX_PATH];			// path, return node path when succeed,return add node path when failed
    } DH_ORGANIZATION_ADD_NODE_RESULT;
    
    // CLIENT_OrganizationAddNodess interface output param(add node)
    typedef struct tagDH_OUT_ORGANIZATION_ADD_NODES
    {
        DWORD				dwSize;
        DH_ORGANIZATION_ADD_NODE_RESULT* pstuResults;	// result pointer
        int					nMaxResultCount;			// size of result
        int					nRetResultCount;			// count of result
    } DH_OUT_ORGANIZATION_ADD_NODES;
    
    // node path
    typedef struct tagDH_ORGANIZATION_NODE_PATH
    {
        DWORD				dwSize;
        char				szPath[MAX_PATH];			// path
    } DH_ORGANIZATION_NODE_PATH;
    
    // CLIENT_OrganizationDeleteNodes's interface input param(delete node)
    typedef struct tagDH_IN_ORGANIZATION_DELETE_NODES
    {
        DWORD				dwSize;
        DH_ORGANIZATION_NODE_PATH*	pstuPath;			// path array
        int					nPathCount;					// count
    } DH_IN_ORGANIZATION_DELETE_NODES;
    
    // CLIENT_OrganizationDeleteNodes's interface output param(delete node)
    typedef struct tagDH_OUT_ORGANIZATION_DELETE_NODES
    {
        DWORD				dwSize;
    } DH_OUT_ORGANIZATION_DELETE_NODES;
    
    // CLIENT_OrganizationGetNodes's interface input param(get node info)
    typedef struct tagDH_IN_ORGANIZATION_GET_NODES
    {
        DWORD				dwSize;
        char*				pszPath;					// path
        int					nLevel;						// level, 0-the level, 1-next level
    } DH_IN_ORGANIZATION_GET_NODES;
    
    // CLIENT_OrganizationGetNodes's interface output param(get node info)
    typedef struct tagDH_OUT_ORGANIZATION_GET_NODES
    {
        DWORD				dwSize;
        DH_ORGANIZATION_NODE*	pstuNodes;				// node array
        int					nMaxNodeCount;				// size of array
        int					nRetNodeCount;				// count of node count
    } DH_OUT_ORGANIZATION_GET_NODES;
    
    // CLIENT_OrganizationSetNode's interface input param(get node info)
    typedef struct tagDH_IN_ORGANIZATION_SET_NODE
    {
        DWORD				dwSize;
        char*				pszPath;					// path
        DH_ORGANIZATION_NODE stuNode;					// node info
    } DH_IN_ORGANIZATION_SET_NODE;
    
    // CLIENT_OrganizationSetNode's interface output param(set node)
    typedef struct tagDH_OUT_ORGANIZATION_SET_NODE
    {
        DWORD				dwSize;
    } DH_OUT_ORGANIZATION_SET_NODE;
    
    // channel info of video input
    typedef struct tagDH_VIDEO_INPUTS
    {
        DWORD				dwSize;
        char				szChnName[DH_DEVICE_NAME_LEN];		// channel name
        BOOL				bEnable;							// enable
        char				szControlID[DH_DEV_ID_LEN_EX];		// control ID
        char				szMainStreamUrl[MAX_PATH];			// main stream url
        char				szExtraStreamUrl[MAX_PATH];			// extra stream url
        int                 nOptionalMainUrlCount;              // spare main stream address quantity
        char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare main stream address list
        int                 nOptionalExtraUrlCount;             // spare sub stream address quantity
        char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare substream address list
    } DH_VIDEO_INPUTS;
    
    typedef struct tagDH_REMOTE_DEVICE
    {
        DWORD				dwSize;
        BOOL				bEnable;							// enable
        char			    szIp[DH_MAX_IPADDR_LEN];		    // IP
        char			    szUser[DH_USER_NAME_LENGTH];	    // username
        char			    szPwd[DH_USER_PSW_LENGTH];	    	// password
        int			    	nPort;							    // port
        int				    nDefinition;					    // definition. 0-standard definition, 1-high definition
        DH_DEVICE_PROTOCOL  emProtocol;							// protocol type
        char			    szDevName[DH_DEVICE_NAME_LEN];		// device name
        int					nVideoInputChannels;				// count channel of video input
        int					nAudioInputChannels;				// count channel of audio input
        char				szDevClass[DH_DEV_TYPE_LEN];		// device type, such as IPC, DVR, NVR
        char				szDevType[DH_DEV_TYPE_LEN];			// device type, such as IPC-HF3300
        int					nHttpPort;							// Http port
        int					nMaxVideoInputCount;				// max count of video input
        int					nRetVideoInputCount;				// return count
        DH_VIDEO_INPUTS*	pstuVideoInputs;					// max count of audion input
        char				szMachineAddress[DH_MAX_CARD_INFO_LEN];	// machine address
        char				szSerialNo[DH_SERIALNO_LEN];		// serial no.
        int                 nRtspPort;                          // Rtsp Port
    } DH_REMOTE_DEVICE;
    
    typedef enum tagNET_LOGIC_CHANNEL_TYPE
    {
        LOGIC_CHN_UNKNOWN,              // Unknow
        LOGIC_CHN_LOCAL,                // Local channel
        LOGIC_CHN_REMOTE,               // Remote access channel
        LOGIC_CHN_COMPOSE,              // Synthesis of channel, for the judicial equipment contains picture in picture channel and mixing channel
        LOGIC_CHN_MATRIX,               // matrix channel??including analog matrix and digital matrix
        LOGIC_CHN_CASCADE,              // cascading channel
    } NET_LOGIC_CHN_TYPE;
    
    // available according to the source of information
    typedef struct tagDH_MATRIX_CAMERA_INFO
    {
        DWORD				dwSize;
        char				szName[DH_DEV_ID_LEN_EX];		// name
        char				szDevID[DH_DEV_ID_LEN_EX];		// device ID
        char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
        int					nChannelID;						// channel ID, DeviceID is unique
        int					nUniqueChannel;					// unique channel
        BOOL				bRemoteDevice;					// support remote device or not
        DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
        NET_STREAM_TYPE     emStreamType;                   // stream type
        NET_LOGIC_CHN_TYPE  emChannelType;                      // Channel Types
    } DH_MATRIX_CAMERA_INFO;
    
    // CLIENT_MatrixGetCameras's interface input param
    typedef struct tagDH_IN_MATRIX_GET_CAMERAS
    {
        DWORD				dwSize;
    } DH_IN_MATRIX_GET_CAMERAS;
    
    // CLIENT_MatrixGetCameras's interface output param
    typedef struct tagDH_OUT_MATRIX_GET_CAMERAS
    {
        DWORD				dwSize;
        DH_MATRIX_CAMERA_INFO* pstuCameras;					// array
        int					nMaxCameraCount;				// size of source array
        int					nRetCameraCount;				// return count
    } DH_OUT_MATRIX_GET_CAMERAS;
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire  the input parameters of remote device information
    typedef struct tagNET_IN_GET_DEVICE_INFO
    {
        DWORD                       dwSize;                                         // when this structure be used??dwSize assigned to sizeof(NET_IN_GET_DEVICE_INFO)
        char                        szDevice[DH_DEV_ID_LEN_EX];                 // Device ID
        // Device attribute??when szDevice is null??the following do effect
        char                        szAttributeIP[DH_COMMON_STRING_32];             // device address
        int                         nAttributePort;                                 // device port
        char                        szAttributeUsername[DH_COMMON_STRING_128];      // user name
        char                        szAttributePassword[DH_COMMON_STRING_128];      // password
        char                        szAttributeManufacturer[DH_COMMON_STRING_128];  // manufacturer protocl
    }NET_IN_GET_DEVICE_INFO;
    
    //CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire the output parameter of remote device information
    typedef struct tagNET_OUT_GET_DEVICE_INFO
    {
        DWORD                       dwSize;         // When this structure is used, dwSize should be assigned to sizeof(NET_OUT_GET_DEVICE_INFO)
        DH_REMOTE_DEVICE            stuInfo;        // Device information, the member of this structur,  dwSize, should be assigned by user
    }NET_OUT_GET_DEVICE_INFO;
    
    // CLIENT_MatrixSetCameras's interface input param
    typedef struct tagDH_IN_MATRIX_SET_CAMERAS
    {
        DWORD				dwSize;
        DH_MATRIX_CAMERA_INFO* pstuCameras;					// array
        int					nCameraCount;				    // size of source array
    } DH_IN_MATRIX_SET_CAMERAS;
    
    // CLIENT_MatrixSetCameras's interface output param
    typedef struct tagDH_OUT_MATRIX_SET_CAMERAS
    {
        DWORD				dwSize;
    } DH_OUT_MATRIX_SET_CAMERAS;
    
    // source of window display info
    typedef struct tagDH_SPLIT_WND_SOURCE
    {
        DWORD				dwSize;
        BOOL				bEnable;						// enable
        char				szDeviceID[DH_DEV_ID_LEN];		// device ID
        char				szControlID[DH_DEV_ID_LEN];		// control ID
        int					nVideoChannel;					// video channel ID
        int					nVideoStream;					// video stream type
        int					nAudioChannel;					// audio channel ID
        int					nAudioStream;					// audio stream type
        int					nUniqueChannel;					// unique channel,read only
        BOOL				bRemoteDevice;					// support remote device
        DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
    } DH_SPLIT_WND_SOURCE;
    
    // info of split window
    typedef struct tagDH_SPLIT_WINDOW
    {
        DWORD				dwSize;
        BOOL				bEnable;						// enable
        int					nWindowID;						// window ID
        char				szControlID[DH_DEV_ID_LEN];		// control ID
        DH_RECT				stuRect;						// rect of window, effective when free split
        BOOL				bDirectable;					// coordinate whether meet the conditions
        int					nZOrder;						// Z order
        DH_SPLIT_WND_SOURCE stuSource;						// source info
    } DH_SPLIT_WINDOW;
    
    // split scene
    typedef struct tagDH_SPLIT_SCENE
    {
        DWORD				dwSize;
        char				szCompositeID[DH_DEV_ID_LEN];	// composite ID
        char				szControlID[DH_DEV_ID_LEN];		// control ID
        DH_SPLIT_MODE		emSplitMode;					// split mode
        DH_SPLIT_WINDOW*	pstuWnds;						// info of array
        int					nMaxWndCount;					// size of array
        int					nRetWndCount;					// return count
    } DH_SPLIT_SCENE;
    
    // monitor wall scene
    typedef struct tagDH_MONITORWALL_SCENE
    {
        DWORD				dwSize;
        char				szName[DH_DEV_NAME_LEN];		// name of plan
        char				szControlID[DH_DEV_ID_LEN];		// control ID
        DH_MONITORWALL		stuMonitorWall;					// monitor wall configuration
        DH_SPLIT_SCENE*		pstuSplitScene;					// array of split scene
        int					nMaxSplitSceneCount;			// size of array
        int					nRetSplitSceneCount;			// return count
    } DH_MONITORWALL_SCENE;
    
    // CLIENT_MonitorWallGetScene's interface input param(get monitor wall scene)
    typedef struct tagDH_IN_MONITORWALL_GET_SCENE
    {
        DWORD				dwSize;
        int					nMonitorWallID;					// monitor wall ID
    } DH_IN_MONITORWALL_GET_SCENE;
    
    // CLIENT_MonitorWallGetScene's interface output param(get monitor wall scene)
    typedef struct tagDH_OUT_MONITORWALL_GET_SCENE
    {
        DWORD				dwSize;
        char				szName[DH_DEV_NAME_LEN];		// name of plan, can be null
        DH_MONITORWALL_SCENE stuScene;						// minotor wall scene
    } DH_OUT_MONITORWALL_GET_SCENE;
    
    // CLIENT_MonitorWallSetScene's interface input param(set monitor wall scene)
    typedef struct tagDH_IN_MONITORWALL_SET_SCENE
    {
        DWORD				dwSize;
        int					nMonitorWallID;					// TV Wall No.
        DH_MONITORWALL_SCENE stuScene;						// TV Wall Scene
    } DH_IN_MONITORWALL_SET_SCENE;
    
    // CLIENT_MonitorWallSetScene's interface output param(set monitor wall scene)
    typedef struct tagDH_OUT_MONITORWALL_SET_SCENE
    {
        DWORD				dwSize;
    } DH_OUT_MONITORWALL_SET_SCENE;
    
    //CLIENT_QueryNetStat Port, input parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack)
    typedef struct tagNET_IN_NETAPP_NET_DATA_STAT
    {
        DWORD       dwSize;
        char        szEthName[DH_MAX_ETH_NAME];                // The network card name
    }NET_IN_NETAPP_NET_DATA_STAT;
    
    //Receive relevant statistics, same meaning with the ifconfig
    typedef struct tagNET_NETAPP_RECEIVE_STAT
    {
        DWORD        dwSize;
        DWORD        dwPackets;
        DWORD        dwBytes;
        DWORD        dwErrors;
        DWORD        dwDroped;
        DWORD        dwOverruns;
        DWORD        dwFrame;
    }NET_NETAPP_RECEIVE_STAT;
    
    //Transport statistics,same meaning with the ifconfig
    typedef struct tagNET_NETAPP_TRANSMIT_STAT
    {
        DWORD        dwSize;
        DWORD        dwPackets;
        DWORD        dwBytes;
        DWORD        dwErrors;
        DWORD        dwDroped;
        DWORD        dwOverruns;
        DWORD        dwCarrier;
        DWORD        dwCollisions;
        DWORD        dwTxQueue;
    }NET_NETAPP_TRANSMIT_STAT;
    
    //CLIENT_QueryNetStat Port, output parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack)
    typedef struct tagNET_OUT_NETAPP_NET_DATA_STAT
    {
        DWORD                        dwSize;
        NET_NETAPP_RECEIVE_STAT      stuReceiveStat;        // Receive relevant statistics,same meaning with the ifconfig
        NET_NETAPP_TRANSMIT_STAT     stuTransmitStat;       // Transport statistics,same meaning with the ifconfig
        int                          nSpeed;                // Network speed??unit is Mbps
    }NET_OUT_NETAPP_NET_DATA_STAT;
    
    //CLIENT_QueryNetStatPort, input parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
    typedef struct tagNET_IN_NETAPP_LINK_STATUS
    {
        DWORD       dwSize;
        char        szEthName[DH_MAX_ETH_NAME];             // Network Card Name
    }NET_IN_NETAPP_LINK_STATUS;
    
    //CLIENT_QueryNetStatPort, output parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
    typedef struct tagNET_OUT_NETAPP_LINK_STATUS
    {
        DWORD       dwSize;
        BOOL        bWorking;               // Whether working
        BOOL        bIPConflict;            // Whether IP conflict
    }NET_OUT_NETAPP_LINK_STATUS;
    
    // type of input signal
#define DH_VIDEO_SIGNAL_CVBS	0x0001
#define DH_VIDEO_SIGNAL_SDI		0x0002
#define DH_VIDEO_SIGNAL_VGA		0x0004
#define DH_VIDEO_SIGNAL_DVI		0x0008
#define DH_VIDEO_SIGNAL_HDMI	0x0010
#define DH_VIDEO_SIGNAL_YPBPR	0x0020
#define DH_VIDEO_SIGNAL_SFP		0x0040
#define DH_VIDEO_SIGNAL_HDCVI       0x0080
#define DH_VIDEO_SIGNAL_DUAL_LINK   0x0100
    
    // caps of video inpt
    typedef struct tagDH_VIDEO_IN_CAPS
    {
        DWORD					dwSize;
        DWORD					dwSignalType;				// type of signal in
        BOOL					bAutoFocusPeak;				// support auto focus peak or not
        BOOL					bElectricFocus;				// support electric focus or not
        BOOL					bSyncFocus;					// support sync focus
        BOOL                    bSetColor;                  // if support video color setup
        BOOL                    bGain;                      // support gain control or not
        BOOL                    bPhase;                     // support phase control or not
    } DH_VIDEO_IN_CAPS;
    
    // CLIENT_GetVideoInCaps's interface input param
    typedef struct tagDH_IN_GET_VIDEO_IN_CAPS
    {
        DWORD			dwSize;
        int				nChannel;							// channel ID of video in
    } DH_IN_GET_VIDEO_IN_CAPS;
    
    // CLIENT_GetVideoInCaps's interface output param
    typedef struct tagDH_OUT_GET_VIDEO_IN_CAPS
    {
        DWORD			dwSize;
        DH_VIDEO_IN_CAPS stuCaps;							// ability
    } DH_OUT_GET_VIDEO_IN_CAPS;
    
    // mode of video out
    typedef struct tagDH_VIDEO_OUT_MODE
    {
        DWORD			dwSize;
        int				nWidth;								// horizontal resolution
        int				nHeight;							// vertical resolution
        int				nBPP;								// color depth
        int				nFormat;							// format of signel out, 0-Auto, 1-TV, 2-VGA, 3-DVI
        int				nRefreshRate;						// refersh rate
        int				nPhysicalPort;						// physical port, VGA, TV, DVI independent number
        int              nScanFormat;                       // Scanning mode, 0 - line by line, 1 - interlaced
    } DH_VIDEO_OUT_MODE;
    
    // CLIENT_EnumVideoOutModes's interface input param
    typedef struct tagDH_IN_ENUM_VIDEO_OUT_MODES
    {
        DWORD			dwSize;
        int				nChannel;
    } DH_IN_ENUM_VIDEO_OUT_MODES;
    
    // CLIENT_EnumVideoOutModes's interface output param
    typedef struct tagDH_OUT_ENUM_VIDEO_OUT_MODES
    {
        DWORD			dwSize;
        DH_VIDEO_OUT_MODE* pstuModes;						// mode array
        int				nMaxModeCount;						// count of mode
        int				nRetModeCount;						// return count
    } DH_OUT_ENUM_VIDEO_OUT_MODES;
    
    // minotor wall attribute type
    typedef enum tagDH_OUTPUT_ATTRIBUTE_TYPE
    {
        DH_OUTPUT_ATTRIBUTE_VIDEO,
        DH_OUTPUT_ATTRIBUTE_YPBPR,
        DH_OUTPUT_ATTRIBUTE_VGA,
        DH_OUTPUT_ATTRIBUTE_DVI,
        DH_OUTPUT_ATTRIBUTE_MENU,
    } DH_OUTPUT_ATTRIBUTE_TYPE;
    
    // caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Video ability
#define	DH_ATTR_VIDEO_BRIGHTNESS	0X00000001
#define	DH_ATTR_VIDEO_CONTRAST		0X00000002
#define	DH_ATTR_VIDEO_SATURATION	0X00000004
#define	DH_ATTR_VIDEO_SHAPENESS		0X00000008
#define	DH_ATTR_VIDEO_DENOISE		0X00000010
    
    // caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) YPbPr ability
#define	DH_ATTR_YPBPR_BRIGHTNESS	0X00000001
#define	DH_ATTR_YPBPR_CONTRAST		0X00000002
#define	DH_ATTR_YPBPR_SATURATION	0X00000004
#define	DH_ATTR_YPBPR_SHAPENESS		0X00000008
#define	DH_ATTR_YPBPR_DENOISE		0X00000010
    
    // caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) VGA ability
#define	DH_ATTR_VGA_BRIGHTNESS		0X00000001
#define	DH_ATTR_VGA_CONTRAST		0X00000002
#define	DH_ATTR_VGA_HORPOSITION		0X00000004
#define	DH_ATTR_VGA_VERPOSITION		0X00000008
#define	DH_ATTR_VGA_CLOCK			0X00000010
    
    // caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) DVI ability
#define	DH_ATTR_DVI_BRIGHTNESS		0X00000001
#define	DH_ATTR_DVI_CONTRAST		0X00000002
#define	DH_ATTR_DVI_HORPOSITION		0X00000004
#define	DH_ATTR_DVI_VERPOSITION		0X00000008
#define	DH_ATTR_DVI_CLOCK			0X00000010
    
    // caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Menu ability
#define	DH_ATTR_MENU_MENU			0X00000001
#define	DH_ATTR_MENU_UP				0X00000002
#define	DH_ATTR_MENU_DOWN			0X00000004
#define	DH_ATTR_MENU_LEFT			0X00000008
#define	DH_ATTR_MENU_RIGHT			0X00000010
#define	DH_ATTR_MENU_FACTORYMENU	0X00000020
    
    // caps of monitor wall adjust
    typedef struct tagDH_OUTPUT_ATTRIBUTE_CAPS
    {
        DWORD			dwSize;
        BOOL			abVideo;			// Video enable
        DWORD			dwVideo;			// Video ability, by bite, specific to see DH_ATTR_VIDEO_BRIGHTNESS
        BOOL			abYPbPr;			// YPbPr enable
        DWORD			dwYPbPr;			// YPbPr ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
        BOOL			abVGA;				// VGA enable
        DWORD			dwVGA;				// VGA ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
        BOOL			abDVI;				// DVI enable
        DWORD			dwDVI;				// DVI ability, by bite, specific to see DH_ATTR_DVI_BRIGHTNESS
        BOOL			abMenu;				// Menu enable
        DWORD			dwMemu;				// Menu ability, by bite, specific to see DH_ATTR_MENU_MENU
    } DH_OUTPUT_ATTRIBUTE_CAPS;
    
    // CLIENT_MonitorWallGetAttributeCaps's interface input param
    typedef struct tagDH_IN_MONITORWALL_GET_ARRT_CAPS
    {
        DWORD			dwSize;
        int				nMonitorWallID;			// monitor wall ID
        const char*		pszCompositeID;			// composite ID
        int				nOutputID;				// output ID
    } DH_IN_MONITORWALL_GET_ARRT_CAPS;
    
    // CLIENT_MonitorWallGetAttributeCaps's interface output param
    typedef struct tagDH_OUT_MONITORWALL_GET_ARRT_CAPS
    {
        DWORD			dwSize;
        DH_OUTPUT_ATTRIBUTE_CAPS stuCaps;		// caps of attribute
    } DH_OUT_MONITORWALL_GET_ARRT_CAPS;
    
    
    // CLIENT_MonitorWallAutoAdjust's interface input param
    typedef struct tagDH_IN_MONITORWALL_AUTO_ADJUST
    {
        DWORD			dwSize;
        int				nMonitorWallID;			// monitor wall ID
        const char*		pszCompositeID;			// composite ID
        int*			pOutputs;				// array pointer
        int				nOutputCount;			// count of pOutputs
    } DH_IN_MONITORWALL_AUTO_ADJUST;
    
    // CLIENT_MonitorWallAutoAdjust's interface output param
    typedef struct tagDH_OUT_MONITORWALL_AUTO_ADJUST
    {
        DWORD			dwSize;
    } DH_OUT_MONITORWALL_AUTO_ADJUST;
    
    // display unit attribute key/value
    typedef struct tagDH_ATTR_PAIR
    {
        DWORD	dwKey;					// attribute key
        // dwKey = DH_OUTPUT_ATTRIBUTE_VIDEO , uses DH_ATTR_VIDEO_BRIGHTNESS
        // dwKey = DH_OUTPUT_ATTRIBUTE_YPBPR, usesDH_ATTR_YPBPR_BRIGHTNESS
        // so on
        int		nValue;					// value of attribute, 0-reduce 1-increase, 2-no change
    } DH_ATTR_PAIR;
    
    // CLIENT_MonitorWallSetAttribute's interface input param
    typedef struct tagDH_IN_MONITORWALL_SET_ATTR
    {
        DWORD					dwSize;
        int						nMonitorWallID;					// monitor wall ID
        const char*				pszCompositeID;					// composite ID
        int						nOutputID;						// output ID
        DH_OUTPUT_ATTRIBUTE_TYPE emAttrType;					// attribute, the differ type, the stuAttrs differ also
        DH_ATTR_PAIR			stuAttrs[DH_MAX_ATTR_NUM];		// value of attribute
    } DH_IN_MONITORWALL_SET_ATTR;
    
    // CLIENT_MonitorWallSetAttribute's interface output param
    typedef struct tagDH_OUT_MONITORWALL_SET_ATTR
    {
        DWORD			dwSize;
    } DH_OUT_MONITORWALL_SET_ATTR;
    
    // CLIENT_MonitorWallSetBackLight's interface input param
    typedef struct tagDH_IN_MONITORWALL_SET_BACK_LIGHT
    {
        DWORD					dwSize;
        int						nMonitorWallID;					// monitor wall ID
        const char*				pszCompositeID;					// omposite ID
        int						nOutputID;						// output ID
        int						nMode;							// backlight model, 0-circulation patterns,1-not circulation
    } DH_IN_MONITORWALL_SET_BACK_LIGHT;
    
    // CLIENT_MonitorWallSetBackLight's interface output param
    typedef struct tagDH_OUT_MONITORWALL_SET_BACK_LIGHT
    {
        DWORD			dwSize;
    } DH_OUT_MONITORWALL_SET_BACK_LIGHT;
    
    // CLIENT_MonitorWallGetPowerSchedule Interface Input Parameters
    typedef struct tagNET_IN_WM_GET_POWER_SCHEDULE
    {
        DWORD               dwSize;
        int                 nMonitorWallID;                     // TV Wall Serial Number
        const char*         pszCompositeID;                     // Splicing Screen ID
    } NET_IN_MW_GET_POWER_SCHEDULE;
    
    // CLIENT_MonitorWallGetPowerSchedule Interface Output Parameters
    typedef struct tagNET_OUT_MW_GET_POWER_SCHEDULE
    {
        DWORD               dwSize;
        DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays
    } NET_OUT_MW_GET_POWER_SCHEDULE;
    
    // CLIENT_MonitorWallSetPowerSchedule Interface Input Parameters
    typedef struct tagNET_IN_MW_SET_POWER_SCHEDULE
    {
        DWORD               dwSize;
        int                 nMonitorWallID;                     // TV wall serial number
        const char*         pszCompositeID;                     // Splicing Screen ID, NULL means all the screen
        DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays
    } NET_IN_MW_SET_POWER_SCHEDULE;
    
    // CLIENT_MonitorWallSetPowerSchedule Interface Output Parameters
    typedef struct tagNET_OUT_MW_SET_POWER_SCHEDULE
    {
        DWORD               dwSize;
    } NET_OUT_MW_SET_POWER_SCHEDULE;
    
    // CLIENT_MonitorWallGetScrnCtrlParam Interface Intput Parameters
    typedef struct tagNET_IN_MW_GET_SCRN_CTRL_PARAM
    {
        DWORD               dwSize;
        int                 nMonitorWallID;                     // TV wall Serial Number
        const char*         pszCompositeID;                     // Splicing Screen ID
    } NET_IN_MW_GET_SCRN_CTRL_PARAM;
    
#define DH_MAX_SCREEN_PORT_NUM        16                    // The biggest screen input port number
#define DH_MAX_COMPSITE_SCREEN_NUM    256                   // The biggest splicing screen number
    
    // Screen Input Port Information
    typedef struct tagNET_SCREEN_PORT_INFO
    {
        DWORD               dwSize;
        char                szType[DH_COMMON_STRING_16];        // Port type, "DVI", "VGA", "HDMI"Etc., Allow the same type of multiple ports
        char                szAddress[DH_COMMON_STRING_16];     // Port address
        char                szDeviceID[DH_DEV_ID_LEN_EX];       // The video output device of a binding
        int                 nOutputChannel;                     // Video output channel number
    } NET_SCREEN_PORT_INFO;
    
    
    typedef struct tagNET_SCREEN_PORT_GROUP
    {
        DWORD                dwSize;
        int                  nPortNum;                          // Port Number
        NET_SCREEN_PORT_INFO stuPorts[DH_MAX_SCREEN_PORT_NUM];  // Port Information
    } NET_SCREEN_PORT_GROUP;
    
    // TV wall screen control parameters
    typedef struct tagNET_WM_SCRN_CTRL_PARAM
    {
        DWORD                   dwSize;
        int                     nCommPort;                                  // Serial Number
        DH_COMM_PROP            stuCommProp;                                // Port Attributes
        char                    szProtocol[DH_COMMON_STRING_32];            // Port Protocol
        int                     nResolutionNum;                             // Resolution Number
        CAPTURE_SIZE            emResolutions[DH_MAX_CAPTURE_SIZE_NUM];     // Video Resolution List
        int                     nScreenCodeNum;                             // Screen Code Number
        char                    szScreenCode[DH_MAX_COMPSITE_SCREEN_NUM][DH_COMMON_STRING_16];    // Screen code, using for serial command addressing,this encoding configuration by the user, can be the same
        int                     nScreenPortsNum;                            // Number of screen input port information
        NET_SCREEN_PORT_GROUP   stuScreenPorts[DH_MAX_COMPSITE_SCREEN_NUM]; // Screen input port information
    } NET_WM_SCRN_CTRL_PARAM;
    
    // CLIENT_MonitorWallGetScrnCtrlParam Interface Input Parameters
    typedef struct tagNET_OUT_MW_GET_SCRN_CTRL_PARAM
    {
        DWORD                   dwSize;
        NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
    } NET_OUT_MW_GET_SCRN_CTRL_PARAM;
    
    // CLIENT_MonitorWallSetScrnCtrlParam Interface Input Parameters
    typedef struct tagNET_IN_MW_SET_SCRN_CTRL_PARAM
    {
        DWORD                   dwSize;
        int                     nMonitorWallID;             // TV Wall Serial Number
        const char*             pszCompositeID;             // Splicing Screen ID
        NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
    } NET_IN_MW_SET_SCRN_CTRL_PARAM;
    
    // CLIENT_MonitorWallSetScrnCtrlParam    Interface Output Parameters
    typedef struct tagNET_OUT_MW_SET_SCRN_CTRL_PARAM
    {
        DWORD           dwSize;
    } NET_OUT_MW_SET_SCRN_CTRL_PARAM;
    
    // CLIENT_MonitorWallGetBackgroudColor Interface Input Parameters
    typedef struct tagNET_IN_MW_GET_BACKGROUDND_COLOR
    {
        DWORD           dwSize;
        int             nMonitorWallID;             // TV Wall Serial Number
    } NET_IN_MW_GET_BACKGROUDND_COLOR;
    
    // CLIENT_MonitorWallGetBackgroudColor    Interface Output Parameters
    typedef struct tagNET_OUT_MW_GET_BACKGROUDND_COLOR
    {
        DWORD           dwSize;
        DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color
        DH_COLOR_RGBA   stuWindowColor;             // Window Background Color
    } NET_OUT_MW_GET_BACKGROUDND_COLOR;
    
    // CLIENT_MonitorWallSetBackgroudColor Interface Input Parameters
    typedef struct tagNET_IN_MW_SET_BACKGROUD_COLOR
    {
        DWORD           dwSize;
        int             nMonitorWallID;             // TV Wall Serial Number
        DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color
        DH_COLOR_RGBA   stuWindowColor;             // Window Background Color
    } NET_IN_MW_SET_BACKGROUD_COLOR;
    
    // CLIENT_MonitorWallSetBackgroudColor Interface Output Parameters
    typedef struct tagNET_OUT_MW_SET_BACKGROUD_COLOR
    {
        DWORD           dwSize;
    } NET_OUT_MW_SET_BACKGROUD_COLOR;
    
    // tv wall operation type
    typedef enum tagNET_MONITORWALL_OPERATE_TYPE
    {
        NET_MONITORWALL_OPERATE_ADD,            // add tv wall, corresponding to  NET_IN_MONITORWALL_ADD and NET_OUT_MONITORWALL_ADD
        NET_MONITORWALL_OPERATE_CTRL_TOUR,      // scheme tour control, corresponding to  NET_IN_CTRL_COLLECTIONTOUR and NET_OUT_CTRL_COLLECTIONTOUR
        NET_MONITORWALL_OPERATE_GET_STATUS,     // get matrix current status, corresponding to  NET_IN_MONITORWALL_GET_STATUS NET_OUT_MONITORWALL_GET_STATUS
        NET_MONITORWALL_OPERATE_SET_COLL_SCHD,  // set scheme time schedule, corresponding to  NET_IN_MONITORWALL_SET_COLL_SCHD NET_OUT_MONITORWALL_SET_COLL_SCHD
        NET_MONITORWALL_OPERATE_GET_COLL_SCHD,  // get scheme schedule, corresponding to  NET_IN_MONITORWALL_GET_COLL_SCHD and NET_OUT_MONITORWALL_GET_COLL_SCHD
        NET_MONITORWALL_OPERATE_REMOVE,         // delete tv wall, corresponding to NET_IN_MONITORWALL_REMOVE  and  NET_OUT_MONITORWALL_REMOVE
        NET_MONITORWALL_OPERATE_SET_ENABLE,     // setup enable, corresponding to NET_IN_MONITORWALL_SET_ENABLE  and  NET_OUT_MONITORWALL_SET_ENABLE
        NET_MONITORWALL_OPERATE_GET_ENABLE,     // Get  enable, corresponding to NET_IN_MONITORWALL_GET_ENABLE  and  NET_OUT_MONITORWALL_GET_ENABLE
        NET_MONITORWALL_OPERATE_NAME_EXIST,     // tv wall exists or not, corresponding to NET_IN_MONITORWALL_NAME_EXIST  and  NET_OUT_MONITORWALL_NAME_EXIST
    } NET_MONITORWALL_OPERATE_TYPE;
    
    // add tv wall input parameter
    typedef struct tagNET_IN_MONITORWALL_ADD
    {
        DWORD dwSize;
        DH_MONITORWALL stuMonitorWall; // tv wall info
    } NET_IN_MONITORWALL_ADD;
    
    // add tv wall output parameter
    typedef struct tagNET_OUT_MONITORWALL_ADD
    {
        DWORD dwSize;
        unsigned int nMonitorWallID; // tv wall ID
    } NET_OUT_MONITORWALL_ADD;
    
    // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
    typedef struct tagNET_IN_CTRL_COLLECTIONTOUR
    {
        DWORD              dwSize;
        int                nChannel;                       // channel no.
        int                nAction;                        // tour action, 0:ebd, 1:start
    } NET_IN_CTRL_COLLECTIONTOUR;
    
    // CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
    typedef struct tagNET_OUT_CTRL_COLLECTIONTOUR
    {
        DWORD                   dwSize;
    } NET_OUT_CTRL_COLLECTIONTOUR;
    
    // matrix operation status
    typedef enum tagNET_MATRIX_STATUS
    {
        MATRIX_STATUS_UNKNOWN,              // unknown
        MATRIX_STATUS_TOUR,                 // scheme tour
        MATRIX_STATUS_NORMAL,               // normal tour
    } NET_MATRIX_STATUS;
    
#define DH_MAX_COLLECTION_NUM   64      // max scheme
    // matrix status info
    typedef struct tagNET_MONITORWALL_STATUS_INFO
    {
        DWORD       dwSize;
        int         nInterval;                      // tour interval
        int         nCollectionNum;                 // scheme tour
        char        szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];         // scheme tour content
        char        szName[DH_DEVICE_NAME_LEN];     // current display scheme name
    } NET_MONITORWALL_STATUS_INFO;
    
    // // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
    typedef struct tagNET_IN_MONITORWALL_GET_STATUS
    {
        DWORD              dwSize;
        int                nChannel;                        //channel no.
    } NET_IN_MONITORWALL_GET_STATUS;
    
    // CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
    typedef struct tagNET_OUT_MONITORWALL_GET_STATUS
    {
        DWORD                           dwSize;
        NET_MATRIX_STATUS               emMatrixStatus;     // operation status
        NET_MONITORWALL_STATUS_INFO     stuStatusInfo;      // status info
    } NET_OUT_MONITORWALL_GET_STATUS;
    
    // tv wall scheme schedule
    typedef struct tagMONITORWALL_COLLECTION_SCHEDULE
    {
        DWORD               dwSize;
        char                szName[DH_DEVICE_NAME_LEN];     // schedule name
        DH_TSECT            stuSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];   // schedule, first each element means sunday~Saturday and holiday
    } MONITORWALL_COLLECTION_SCHEDULE;
    
    // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
    typedef struct tagNET_IN_MONITORWALL_SET_COLL_SCHD
    {
        DWORD               dwSize;
        int                 nCollectionNum;                 // scheme number
        MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
        int                 nMonitorWallID;                 // tv wall ID
    } NET_IN_MONITORWALL_SET_COLL_SCHD;
    
    // CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
    typedef struct tagNET_OUT_MONITORWALL_SET_COLL_SCHD
    {
        DWORD               dwSize;
    } NET_OUT_MONITORWALL_SET_COLL_SCHD;
    
    // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
    typedef struct tagNET_IN_MONITORWALL_GET_COLL_SCHD
    {
        DWORD               dwSize;
        BOOL                bAllCollections;                // TRUE-search all scheme, no need to appoint scheme name. FALSE-search name corresponding scheme
        int                 nCollectionNum;                 // scheme, bAllCollections is FALSE valid
        char                szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];   // scheme name
        int                 nMonitorWallID;                 // tv wall ID
    } NET_IN_MONITORWALL_GET_COLL_SCHD;
    
    // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
    typedef struct tagNET_OUT_MONITORWALL_GET_COLL_SCHD
    {
        DWORD               dwSize;
        int                 nCollectionNum;                 // scheme number
        MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
    } NET_OUT_MONITORWALL_GET_COLL_SCHD;
    
    // CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_REMOVE
    typedef struct tagNET_IN_MONITORWALL_REMOVE
    {
        DWORD       dwSize;
        int         nMonitorWallNum;        // tv wall quantity to delete
        char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name
    } NET_IN_MONITORWALL_REMOVE;
    
    // CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_REMOVE
    typedef struct tagNET_OUT_MONITORWALL_REMOVE
    {
        DWORD       dwSize;
    } NET_OUT_MONITORWALL_REMOVE;
    
    // tv wall enable info
    typedef struct tagNET_MONITORWALL_ENABLE_INFO
    {
        DWORD       dwSize;
        BOOL        bEanble;            // enable
        char        szName[DH_COMMON_STRING_128];  // tv wall  name
    } NET_MONITORWALL_ENABLE_INFO;
    
    // CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
    typedef struct tagNET_IN_MONITORWALL_SET_ENABLE
    {
        DWORD       dwSize;
        int         nMonitorWallNum;        // tv wall quantity to set
        NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable
    } NET_IN_MONITORWALL_SET_ENABLE;
    
    // CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
    typedef struct tagNET_OUT_MONITORWALL_SET_ENABLE
    {
        DWORD        dwSize;
    } NET_OUT_MONITORWALL_SET_ENABLE;
    
    // CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_GET_ENABLE
    typedef struct tagNET_IN_MONITORWALL_GET_ENABLE
    {
        DWORD       dwSize;
        int         nMonitorWallNum;        //tv wall quantity to search, -1 means search alltv wall
        char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name , nMonitorWallNum>0 is valid
    } NET_IN_MONITORWALL_GET_ENABLE;
    
    // CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
    typedef struct tagNET_OUT_MONITORWALL_GET_ENABLE
    {
        DWORD       dwSize;
        int         nMonitorWallNum;        // tv wall quantity
        NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable
    } NET_OUT_MONITORWALL_GET_ENABLE;
    
    // CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
    typedef struct tagNET_IN_MONITORWALL_NAME_EXIST
    {
        DWORD           dwSize;
        const char*     pszName;            // tv wall  name
    } NET_IN_MONITORWALL_NAME_EXIST;
    
    // CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
    typedef struct tagNET_OUT_MONITORWALL_NAME_EXIST
    {
        DWORD       dwSize;
        BOOL        bExist;            // tv wall exists or not
    } NET_OUT_MONITORWALL_NAME_EXIST;
    
    
    /************************************************************************
     *  U disk caught
     ************************************************************************/
    
    // CLIENT_StartSniffer's interface input param
    typedef struct tagDH_IN_START_SNIFFER
    {
        DWORD		dwSize;
        const char*	pszNetInterface;				// name of network card
        const char*	pszPath;						// path of caught file, it is means the default path when pszPath = NULL
        int			nSaveType;						// type of file, 0-Wireshark/Tcpdump
        const char*     pszFilter;                  // Filter Conditions ,Such as "host 172.9.88.200 and port 8080 and tcp"
    } DH_IN_START_SNIFFER;
    
    // CLIENT_StartSniffer's interface output param
    typedef struct tagDH_OUT_START_SNIFFER
    {
        DWORD		dwSize;
    } DH_OUT_START_SNIFFER;
    
    // grasp the package information
    typedef struct tagDH_SNIFFER_INFO
    {
        DWORD		dwSize;
        DWORD		nSnifferID;					// Sniffer ID
    } DH_SNIFFER_INFO;
    
    // CLIENT_GetSnifferInfo's interface input param
    typedef struct tagDH_IN_GET_SNIFFER_INFO
    {
        DWORD		dwSize;
        const char*	pszNetInterface;
    } DH_IN_GET_SNIFFER_INFO;
    
    // CLIENT_GetSnifferInfo's interface output param
    typedef struct tagDH_OUT_GET_SNIFFER_INFO
    {
        DWORD		dwSize;
        DH_SNIFFER_INFO	* pstuSniffers;			// array of Sniffer
        int			nMaxSnifferCount;			// size of array
        int			nRetSnifferCount;			// return count
    } DH_OUT_GET_SNIFFER_INFO;
    
    /************************************************************************
     *  manage file
     ************************************************************************/
    
    // format the partition information
    typedef struct tagDH_FORMAT_PATITION
    {
        DWORD			dwSize;
        const char*		pszStorageName;							// storage name
        const char*		pszPatitionName;						// partition name
    } DH_FORMAT_PATITION;
    
    // CLIENT_CreateRemoteFile's interface input param
    typedef struct tagDH_IN_CREATE_REMOTE_FILE
    {
        DWORD			dwSize;
        const char*		pszPath;								// path of file
        BOOL			bDirectory;								// is directory or not
    } DH_IN_CREATE_REMOTE_FILE;
    
    // CLIENT_CreateRemoteFile's interface output param
    typedef struct tagDH_OUT_CREATE_REMOTE_FILE
    {
        DWORD			dwSize;
    } DH_OUT_CREATE_REMOTE_FILE;
    
    // CLIENT_RemoveRemoteFiles's interface input param
    typedef struct tagDH_IN_REMOVE_REMOTE_FILES
    {
        DWORD			dwSize;
        const char**	pszPath;								// pointer of file path
        int				nFileCount;								// count of file
    } DH_IN_REMOVE_REMOTE_FILES;
    
    // CLIENT_RemoveRemoteFiles's interface output param
    typedef struct tagDH_OUT_REMOVE_REMOTE_FILES
    {
        DWORD		dwSize;
    } DH_OUT_REMOVE_REMOTE_FILES;
    
    // CLIENT_RenameRemoteFile's interface input param
    typedef struct tagDH_IN_RENAME_REMOTE_FILE
    {
        DWORD			dwSize;
        const char*		pszOldPath;								// old path
        const char*		pszNewPath;								// new path
    } DH_IN_RENAME_REMOTE_FILE;
    
    // CLIENT_RenameRemoteFile's interface output param
    typedef struct tagDH_OUT_RENAME_REMOTE_FILE
    {
        DWORD			dwSize;
    } DH_OUT_RENAME_REMOTE_FILE;
    
    // file/catalog info
    typedef struct tagDH_REMOTE_FILE_INFO
    {
        DWORD			dwSize;
        BOOL			bDirectory;								// is directory or not
        char			szPath[MAX_PATH];						// path
        NET_TIME		stuCreateTime;							// create time
        NET_TIME		stuModifyTime;							// modify time
        INT64			nFileSize;								// size of file
        char			szFileType[DH_FILE_TYPE_LEN];			// type of file
    } DH_REMOTE_FILE_INFO;
    
    // CLIENT_ListRemoteFile's interface input param
    typedef struct tagDH_IN_LIST_REMOTE_FILE
    {
        DWORD			dwSize;
        const char*		pszPath;								// path
        BOOL			bFileNameOnly;							// only for file name
    } DH_IN_LIST_REMOTE_FILE;
    
    // CLIENT_ListRemoteFile's interface output param
    typedef struct tagDH_OUT_LIST_REMOTE_FILE
    {
        DWORD			dwSize;
        DH_REMOTE_FILE_INFO*	pstuFiles;						// array of file
        int						nMaxFileCount;					// size of array
        int						nRetFileCount;					// return count
    } DH_OUT_LIST_REMOTE_FILE;
    
    // set file property??property name
    typedef enum tagNET_SET_FILEATTR_ACTION
    {
        EM_SET_FILEATTR_ACTION_UNKNOWN = 0,                 // unknown
        EM_SET_FILEATTR_ACTION_MARK,                        // file lock
    } NET_SET_FILEATTR_ACTION;
    
    // CLIENT_SetFileAttribute port input paramete
    typedef struct tagDH_IN_SET_FILEATTRIBUTE
    {
        DWORD                   dwSize;
        unsigned int            nDriveNo;                       // disk no.
        unsigned int            nPartition;                     // partition no.
        unsigned int            nCluster;                       // cluster no.
        NET_SET_FILEATTR_ACTION emAction;                       // each property corresponding to one key, set value depends on value
        // set key:Mark file lock ,corresponding to value, delay lock time(unit:day)
        char                    szValue[DH_COMMON_STRING_64];   // property valu
    } DH_IN_SET_FILEATTRIBUTE;
    
    // CLIENT_SetFileAttribute port output parameter
    typedef struct tagDH_OUT_SET_FILEATTRIBUTE
    {
        DWORD                   dwSize;
    } DH_OUT_SET_FILEATTRIBUTE;
    
    // manual pop-up storage device
    typedef struct tagDH_EJECT_STORAGE_DEVICE
    {
        DWORD				dwSize;
        const char*			pszStorageName;						// storage name
    } DH_EJECT_STORAGE_DEVICE;
    
    //  manual load storage device
    typedef struct tagDH_LOAD_STORAGE_DEVICE
    {
        DWORD				dwSize;
        const char*			pszStorageName;						// storage name
    } DH_LOAD_STORAGE_DEVICE;
    
    // CLIENT_UploadRemoteFile's interface input param(upload file to the device)
    typedef struct tagDH_IN_UPLOAD_REMOTE_FILE
    {
        DWORD               dwSize;
        const char*         pszFileSrc;			// path of source file
        const char*         pszFileDst;			// path of goal file
        const char*         pszFolderDst;       // target file path??may be NULL, NULL device use default path
        unsigned int        nPacketLen;         // file pack size(byte): 0 means not pack
    } DH_IN_UPLOAD_REMOTE_FILE;
    
    // CLIENT_UploadRemoteFile's interface output param(upload file to the device)
    typedef struct tagDH_OUT_UPLOAD_REMOTE_FILE
    {
        DWORD					dwSize;
    } DH_OUT_UPLOAD_REMOTE_FILE;
    
    // CLIENT_DownloadRemoteFile    Interface Input Parameters (the file download)
    typedef struct tagDH_IN_DOWNLOAD_REMOTE_FILE
    {
        DWORD               dwSize;
        const char*         pszFileName;                    // File Name Needs to Download
        const char*         pszFileDst;                     // File Path
    } DH_IN_DOWNLOAD_REMOTE_FILE;
    
    // CLIENT_DownloadRemoteFile Interface Output Parameters (the file download)
    typedef struct tagDH_OUT_DOWNLOAD_REMOTE_FILE
    {
        DWORD               dwSize;
    } DH_OUT_DOWNLOAD_REMOTE_FILE;
    
    /************************************************************************
     * cascade device
     ************************************************************************/
    // conditon of cascade device search
    typedef struct tagDH_IN_SEARCH_CONDITON
    {
        DWORD					dwSize;
        const char*				pMachineName;					// device name or no.
        const char*				pMachineAddr;					// machine address (XX.XX.XX)
        const char*				pSerialNo;						// serial no.
        const char*				pChannelName;					// channel name of video in
    } DH_MATRIX_SEARCH_CONDITON;
    
    // CLIENT_MatrixSearch's interface input param(search cascade device)
    typedef struct tagDH_IN_MATIRX_SEARCH
    {
        DWORD					dwSize;
        const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
        DH_MATRIX_SEARCH_CONDITON stuCondition;					// condition of search, can be for a single or combination
    } DH_IN_MATRIX_SEARCH;
    
    // CLIENT_MatrixSearch's interface output param(search cascade device)
    typedef struct tagDH_OUT_MATRIX_SEARCH
    {
        DWORD					dwSize;
        DH_REMOTE_DEVICE*		pstuRemoteDevices;				// devices list
        int						nMaxDeviceCount;				// max count of device
        int						nRetDeviceCount;				// return count
    } DH_OUT_MATRIX_SEARCH;
    
    // CLIENT_GetMatrixTree's interface input param
    typedef struct tagDH_IN_GET_MATRIX_TREE
    {
        DWORD					dwSize;
        const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
        int						nLevel;							// get device information,0-all, 1-Local, 2-Local+device under
        // 3-Local+device under+ the next next devuce
    } DH_IN_GET_MATRIX_TREE;
    
    // cascade device info
    typedef struct tagDH_CASCADE_DEVICE_INFO
    {
        DWORD					dwSize;
        int						nLevel;							// level
        char					szPath[MAX_PATH];				// set path,format:name1.name2.name3...
        DH_REMOTE_DEVICE		stuDeviceInfo;					// device info
    } DH_CASCADE_DEVICE_INFO;
    
    // CLIENT_GetMatrixTree's interface output param
    typedef struct tagDH_OUT_GET_MATRIX_TREE
    {
        DWORD					dwSize;
        DH_CASCADE_DEVICE_INFO*	pstuRemoteDevices;				// info of cascade device
        int						nMaxDeviceCount;				// max number of cascade device
        int						nRetDeviceCount;				// return count
    } DH_OUT_GET_MATRIX_TREE;
    
    // CLIENT_GetSuperiorMatrixList's interface input param
    typedef struct tagDH_IN_GET_SUPERIOR_MATRIX_LIST
    {
        DWORD					dwSize;
    } DH_IN_GET_SUPERIOR_MATRIX_LIST;
    
    // CLIENT_GetSuperiorMatrixList's interface output param
    typedef struct tagDH_OUT_GET_SUPERIOR_MATRIX_LIST
    {
        DWORD					dwSize;
        DH_REMOTE_DEVICE*		pstuRemoteDevices;				// device list
        int						nMaxDeviceCount;				// max count of device
        int						nRetDeviceCount;				// return count
    } DH_OUT_GET_SUPERIOR_MATRIX_LIST;
    
    ////////////////////////////////////record backup to restore//////////////////////////////////////
    
    // task of record backup to restore
    typedef struct tagDH_RECORD_BACKUP_RESTORE_TASK
    {
        DWORD				dwSize;
        unsigned int		nTaskID;                        // task ID
        char				szDeviceID[DH_DEV_ID_LEN_EX];   // device ID
        int			        nChannelID;                     // channek ID
        NET_TIME			stuStartTime;                   // start time
        NET_TIME			stuEndTime;                     // end time
        int			        nState;                         // state of backup, 0-wait, 1-working, 2-finish, 3-failed
    } DH_REC_BAK_RST_TASK;
    
    // CLIENT_AddRecordBackupRestoreTask's interface input param
    typedef struct tagDH_IN_ADD_RECORD_BACKUP_RESTORE_TASK
    {
        DWORD				dwSize;
        const char*			pszDeviceID;					// device ID
        int*		        pnChannels;						// array of channel
        int					nChannelCount;					// size of array
        NET_TIME			stuStartTime;					// start time
        NET_TIME			stuEndTime;						// end time
    } DH_IN_ADD_REC_BAK_RST_TASK;
    
    // CLIENT_RemoveRecordBackupRestoreTask's interface input param
    typedef struct tagDH_IN_REMOVE_RECORD_BACKUP_RESTORE_TASK
    {
        DWORD				dwSize;
        unsigned int*		pnTaskIDs;						// array of task ID
        int					nTaskCount;						// count of task
    } DH_IN_REMOVE_REC_BAK_RST_TASK;
    
    // CLIENT_QueryRecordBackupRestoreTask's interface input param
    typedef struct tagDH_IN_QUERY_RECORD_BACKUP_RESTORE_TASK
    {
        DWORD		        dwSize;
    } DH_IN_QUERY_REC_BAK_RST_TASK;
    
    // CLIENT_QueryRecordBackupRestoreTask's interface output param
    typedef struct tagDH_OUT_QUERY_RECORD_BACKUP_RESTORE_TASK
    {
        DWORD				 dwSize;
        DH_REC_BAK_RST_TASK* pTasks;						// array of task
        int					 nMaxCount;						// size of array
        int					 nReturnCount;					// return count
    } DH_OUT_QUERY_REC_BAK_RST_TASK;
    
    typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_PARAM
    {
        DWORD			dwSize;
        const char*		pszDeviceID;			// device ID
        int				nChannel;				// channel
    } DH_LOGIC_DEVICE_ADD_CAMERA_PARAM;
    
    typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_RESULT
    {
        DWORD			dwSize;
        char			szDeviceID[DH_DEV_ID_LEN];	// device ID
        int				nChannel;					// channel ID
        int				nUniqueChannel;				// uniform number
        int				nFailedCode;				// failure code, 0-succeed 1-Unique 2-have added
    } DH_LOGIC_DEVICE_ADD_CAMERA_RESULT;
    
    // CLIENT_AddLogicDeviceCamera's interface input param
    typedef struct tagDH_IN_ADD_LOGIC_DEVICE_CAMERA
    {
        DWORD			dwSize;
        DH_LOGIC_DEVICE_ADD_CAMERA_PARAM*	pCameras;	// array of source video
        int				nCameraCount;					// count of sourcevideo
    } DH_IN_ADD_LOGIC_DEVICE_CAMERA;
    
    // CLIENT_AddLogicDeviceCamera's interface output param
    typedef struct tagDH_OUT_ADD_LOGIC_DEVICE_CAMERA
    {
        DWORD			dwSize;
        DH_LOGIC_DEVICE_ADD_CAMERA_RESULT* pResults;	// result
        int				nMaxResultCount;				// size of array
        int				nRetResultCount;				// return count
    } DH_OUT_ADD_LOGIC_DEVICE_CAMERA;
    
    /************************************************************************/
    /*                         Database Records                               */
    /************************************************************************/
    typedef struct tagNET_AUTHORITY_TYPE
    {
        DWORD                       dwSize;
        EM_NET_AUTHORITY_TYPE       emAuthorityType;                          //Permission Types
        BOOL                        bAuthorityEnable;                         //Permission Enabled
    }NET_AUTHORITY_TYPE;
    
    // Information of recorded in transportation black and white list
    typedef struct tagNET_TRAFFIC_LIST_RECORD
    {
        DWORD                      dwSize;
        int                        nRecordNo;                                 // Queried Record Number
        char                       szMasterOfCar[DH_MAX_NAME_LEN];            // Car Owner's Name
        char                       szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];    // License Plate Number
        EM_NET_PLATE_TYPE          emPlateType;                               // License Plate Type
        EM_NET_PLATE_COLOR_TYPE    emPlateColor;                              // License Plate Color
        EM_NET_VEHICLE_TYPE        emVehicleType;                             // Vehicle Type
        EM_NET_VEHICLE_COLOR_TYPE  emVehicleColor;                            // Car Body Color
        NET_TIME                   stBeginTime;                               // Start Time
        NET_TIME                   stCancelTime;                              // Undo Time
        int                        nAuthrityNum;                              // Permission Number
        NET_AUTHORITY_TYPE         stAuthrityTypes[DH_MAX_AUTHORITY_LIST_NUM];// Permissions List, White List Only
        EM_NET_TRAFFIC_CAR_CONTROL_TYPE emControlType;                        // Monitor Type, Black List Only
    }NET_TRAFFIC_LIST_RECORD;
    
    // Query Conditions Of Traffic Black And White List Account Records
    typedef struct
    {
        DWORD                    dwSize;
        char                     szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];      // License Plate Number
        char                     szPlateNumberVague[DH_MAX_PLATE_NUMBER_LEN]; // License Plate Number Fuzzy Query
        int                      nQueryResultBegin;                           // Offset in the query results of first results returned
        BOOL                     bRapidQuery;                                 // Whether support the quick query, TRUE: for quick, quick query time don't wait for all add, delete, change operation is completed. The default is non-quick query
    }FIND_RECORD_TRAFFICREDLIST_CONDITION;
    
    // ??????????¡À¡§????, ?????????¨¤?? DH_ALARM_TRAFFIC_SUSPICIOUSCAR
    typedef struct tagALARM_TRAFFIC_SUSPICIOUSCAR_INFO
    {
        DWORD                   dwSize;
        int                     nAction;                        // ??????¡Á¡Â, -1:????,0:Start, 1:Stop, 2:Pulse
        DH_MSG_OBJECT           stuVehicle;                     // ???¨ª????
        NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // ????????????????
        EVENT_COMM_INFO         stCommInfo;                     // ????????
    }ALARM_TRAFFIC_SUSPICIOUSCAR_INFO;
    
    //Record Case Record Query Conditions
    typedef struct
    {
        DWORD                    dwSize;
        NET_TIME                 stuStartTime;                      // Start Time
        NET_TIME                 stuEndTime;                        // End Time
    }FIND_RECORD_BURN_CASE_CONDITION;
    
    
    // Entrance Card Record Query Conditions
    typedef struct tagFIND_RECORD_ACCESSCTLCARD_CONDITION
    {
        DWORD                    dwSize;
        char                     szCardNo[DH_MAX_CARDNO_LEN];      // Card Number
        char                     szUserID[DH_MAX_USERID_LEN];      // User ID
        BOOL                     bIsValid;                         // Whether effective, TRUE: effective, FALSE: invalid
        BOOL                     abCardNo;                         // Card inquire condition effects or not, for member szCardNo
        BOOL                     abUserID;                         // User ID inquire condition effects or not, for member  szUserID
        BOOL                     abIsValid;                        // IsValid inquire condition effects or not??for member  bIsValid
    }FIND_RECORD_ACCESSCTLCARD_CONDITION;
    
    // Access password record query conditions
    typedef struct tagFIND_RECORD_ACCESSCTLPWD_CONDITION
    {
        DWORD                     dwSize;
        char                      szUserID[DH_MAX_USERID_LEN];      // User ID
    }FIND_RECORD_ACCESSCTLPWD_CONDITION;
    
    // Entrance guard access records query conditions
    typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION
    {
        DWORD                     dwSize;
        char                      szCardNo[DH_MAX_CARDNO_LEN];      // User ID
        NET_TIME                  stStartTime;                      // Start Time
        NET_TIME                  stEndTime;                        // End Time
    }FIND_RECORD_ACCESSCTLCARDREC_CONDITION;
    
    // Holiday Recordset Query Conditions
    typedef struct tagFIND_RECORD_ACCESSCTLHOLIDAY_CONDITION
    {
        DWORD                     dwSize;
    }FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION;
    
    // traffic flow record search filter
    typedef struct tagFIND_RECORD_TRAFFICFLOW_CONDITION
    {
        DWORD                     dwSize;
        BOOL                      abChannelId;                      // channel no. search filter is valid or not
        int                       nChannelId;                       // channel no.
        BOOL                      abLane;                           // lane no. searchfilter is valid or not
        int                       nLane;                            // lane no.
        BOOL                      abStartTime;                      // start time searchfilter is valid or not
        NET_TIME                  stStartTime;                      // start time
        BOOL                     abEndTime;                        // end time search filter is valid or not
        NET_TIME                  stEndTime;                        // end time
    }FIND_RECORD_TRAFFICFLOW_CONDITION;
    
#define DH_MAX_CALLTYPE_LIST_NUM        16              // call  type search criteria listmax number
#define DH_MAX_ENDSTATE_LIST_NUM        16              // final status  search criteria listmax number
    
    // call record search criteria
    typedef struct tagFIND_RECORD_VIDEO_TALK_LOG_CONDITION
    {
        DWORD               dwSize;
        BOOL                bCallTypeEnable;                // call  type search criteria valid or not
        int                 nCallTypeListNum;               // corresponding to emCallTypeList valid enumeration number
        EM_VIDEO_TALK_LOG_CALLTYPE   emCallTypeList[DH_MAX_CALLTYPE_LIST_NUM];  // call  type enable list
        BOOL                bEndStateEnable;                // final status  search criteria isvalid or not
        int                 nEndStateListNum;               // corresponding to emEndStateList valid enumeration number
        EM_VIDEO_TALK_LOG_ENDSTATE   emEndStateList[DH_MAX_ENDSTATE_LIST_NUM];  // final status enable list
    }FIND_RECORD_VIDEO_TALK_LOG_CONDITION;
    
    // status  record search criteria
    typedef struct tagFIND_RECORD_REGISTER_USER_STATE_CONDITION
    {
        DWORD               dwSize;
        BOOL                bUserIDEnable;                  // userID search criteria is valid or not
        char                szUserID[DH_MAX_USERID_LEN];    // user ID
        BOOL                bOnlineEnable;                  // online search criteria is valid or not
        BOOL                bOnline;                        // online or not
        BOOL                bVideoTalkingEnable;            // audio talk status  search criteria  is valid or not
        EM_REGISTER_USER_STATE     emVideoTalking;          // audio talk status
    }FIND_RECORD_REGISTER_USER_STATE_CONDITION;
    
    // contact record search criteria
    typedef struct tagFIND_RECORD_VIDEO_TALK_CONTACT_CONDITION
    {
        DWORD               dwSize;
        BOOL                bVTShortNumberEnable;                   // visual talk short no. search criteria  is valid or not
        char                szVTShortNumber[DH_COMMON_STRING_32];   // visual talk short no.
    }FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION;
    
    // traffic flow record
    typedef struct tagNET_RECORD_TRAFFIC_FLOW_STATE
    {
        DWORD                           dwSize;
        int                             nRecordNum;                 // record no.
        int                             nChannel;                   // channel no.
        int                             nLane;                      // lane no.
        int                             nVehicles;                  // pass vehicle total
        float                           fAverageSpeed;              // average speed??unit km/h
        float                           fTimeOccupyRatio;           // time occupancy rate??as within unit time passed vehicle used time total and unit occupied scale
        float                           fSpaceOccupyRatio;          // space occupancy??as percentage of total vehicle length to time interval average vehicle driving distance
        float                           fSpaceHeadway;              // head distance, with adjacent vehicle, unit meter/vehicle
        float                           fTimeHeadway;               // head distance??unit meter/vehicle
        int                             nLargeVehicles;             // truck flow(9m<vehicle length<12m)??vehicle/unit time
        int                             nMediumVehicles;            // Midsize vehicle flow(6m<vehicle length<9m)??vehicle/unit time
        int                             nSmallVehicles;             // car flow(4m<vehicle legnth<6m)??vehicle/unit??
        float                           fBackOfQueue;               // line length??unit??meter, from signal cross to front line end
    }NET_RECORD_TRAFFIC_FLOW_STATE;
    
    // CLIENT_FindRecord    Interface Input Parameters
    typedef struct _NET_IN_FIND_RECORD_PARAM
    {
        DWORD                     dwSize;          // The Structure Size
        EM_NET_RECORD_TYPE        emType;          // The record type to query
        void*                     pQueryCondition; // Query types corresponding to the query conditions
    }NET_IN_FIND_RECORD_PARAM;
    
    // CLIENT_FindRecord  Interface Output Parameters
    typedef struct _NET_OUT_FIND_RECORD_PARAM
    {
        DWORD                     dwSize;          // Structure Size
        LLONG                     lFindeHandle;    // Query Log Handle,Uniquely identifies a certain query
    }NET_OUT_FIND_RECORD_PARAM;
    
    // CLIENT_FindNextRecord  Interface Input Parameters
    typedef struct _NET_IN_FIND_NEXT_RECORD_PARAM
    {
        DWORD                     dwSize;          // Structure Size
        LLONG                     lFindeHandle;    // Query Log Handle
        int                       nFileCount;      // The current number of records  need query
    }NET_IN_FIND_NEXT_RECORD_PARAM;
    
    // CLIENT_FindNextRecord  Interface Output Parameters
    typedef struct _NET_OUT_FIND_NEXT_RECORD_PARAM
    {
        DWORD                     dwSize;          // Structure Size
        void*                     pRecordList;     // Record List, the user allocates memory
        int                       nMaxRecordNum;   // List Record Number
        int                       nRetRecordNum;   // Query to the number of records, when the query to the article number less than want to query the number, end
    }NET_OUT_FIND_NEXT_RECORD_PARAM;
    
    typedef struct tagNET_INSERT_RECORD_INFO
    {
        DWORD                     dwSize;
        NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information
    }NET_INSERT_RECORD_INFO;
    
    typedef struct tagNET_UPDATE_RECORD_INFO
    {
        DWORD                     dwSize;
        NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information
    }NET_UPDATE_RECORD_INFO;
    
    typedef struct tagNET_REMOVE_RECORD_INFO
    {
        DWORD                     dwSize;
        int                       nRecordNo;       // Queried Record Number
    }NET_REMOVE_RECORD_INFO;
    
    typedef struct tagNET_IN_OPERATE_TRAFFIC_LIST_RECORD
    {
        DWORD                     dwSize;
        
        EM_RECORD_OPERATE_TYPE    emOperateType;
        EM_NET_RECORD_TYPE        emRecordType;    // record type to operate
        void                      *pstOpreateInfo;
        
    }NET_IN_OPERATE_TRAFFIC_LIST_RECORD;
    
    //In current implementation of operation interface, only return nRecordNo operation, stRetRecord is temporarily unavailable
    typedef struct tagNET_OUT_OPERATE_TRAFFIC_LIST_RECORD
    {
        DWORD                     dwSize;
        int                       nRecordNo;        //Record Number
    }NET_OUT_OPERATE_TRAFFIC_LIST_RECORD;
    
    //PTZ control coordinate unit
    typedef struct tagPTZ_SPEED_UNIT
    {
        float                  fPositionX;           //PTZ horizontal speed, normalized to -1~1
        float                  fPositionY;           //PTZ vertical speed, normalized to -1~1
        float                  fZoom;                //PTZ aperture magnification, normalized to 0~1
        char                   szReserve[32];        //Reserved
    }PTZ_SPEED_UNIT;
    
    //PTZ control coordinate unit
    typedef struct tagPTZ_SPACE_UNIT
    {
        int                    nPositionX;           //PTZ horizontal motion position, effective range??[0,3600]
        int                    nPositionY;           //PTZ vertical motion position, effective range??[-1800,1800]
        int                    nZoom;                //PTZ aperture change position, the effective range??[0,128]
        char                   szReserve[32];        //Reserved
    }PTZ_SPACE_UNIT;
    
    //Continuous control PTZ corresponding structure
    typedef struct tagPTZ_Control_Continuously
    {
        PTZ_SPEED_UNIT         stuSpeed;              //PTZ speed
        int                    nTimeOut;              //Continuous motion timeout, the unit is in seconds
        char                   szReserve[64];         //Reserved
    }PTZ_CONTROL_CONTINUOUSLY;
    
    //Absolute control PTZ corresponding structure
    typedef struct tagPTZ_Control_Absolutely
    {
        PTZ_SPACE_UNIT         stuPosition;           //PTZ Absolute Speed
        PTZ_SPEED_UNIT         stuSpeed;              //PTZ Operation Speed
        char                   szReserve[64];         //Reserved
    }PTZ_CONTROL_ABSOLUTELY;
    
    // Alarm input channel information
    typedef struct tagNET_ALARM_IN_CHANNEL
    {
        DWORD                   dwSize;
        BOOL                    bValid;                             // whether effective,FALSE show the alarm channel is not used
        int                     nChannel;                           // Alarm channel number
        char                    szDeviceID[DH_DEV_ID_LEN];          // Device ID, Local alarm channel: "Local",remote device : use uuid express
        char                    szName[DH_DEV_NAME_LEN];            // Alarm  Channel Names
    }NET_ALARM_IN_CHANNEL;
    
    // Alarm Channel Number
    typedef struct tagNET_ALARM_CHANNEL_COUNT
    {
        DWORD                   dwSize;
        int                     nLocalAlarmIn;                      // Local Alarm Input Channel Number
        int                     nLocalAlarmOut;                     // Local Alarm Output Channel Number
        int                     nRemoteAlarmIn;                     // Remote Alarm Input Channel Number
        int                     nRemoteAlarmOut;                    // Remote Alarm Output Channel Number
    }NET_ALARM_CHANNEL_COUNT;
    
    //With speed rotation site PTZ control corresponding to the preset structure
    typedef struct tagPTZ_Control_GotoPreset
    {
        int                     nPresetIndex;           //Preset BIT Index
        PTZ_SPEED_UNIT          stuSpeed;               //PTZ Operation Speed
        char                    szReserve[64];          //Reserved
    }PTZ_CONTROL_GOTOPRESET;
    
    // CLIENT_SetTourSource   Interface input parameters (Settings window round tour shows source)
    typedef struct tagNET_IN_SET_TOUR_SOURCE
    {
        DWORD                   dwSize;
        int                     nChannel;               // Output Channel Number
        int                     nWindow;                // Window Number
        DH_SPLIT_SOURCE*        pstuSrcs;               // Display Origin Array,can be round tour in the window
        int                     nSrcCount;              // Display Origin Number
    } NET_IN_SET_TOUR_SOURCE;
    
    // CLIENT_SetTourSource    Interface output parameters (Settings window round tour shows source)
    typedef struct tagNET_OUT_SET_TOUR_SOURCE
    {
        DWORD                   dwSize;
    } NET_OUT_SET_TOUR_SOURCE;
    
    // CLIENT_GetTourSource port input parameter
    typedef struct tagNET_IN_GET_TOUR_SOURCE
    {
        DWORD           dwSize;
        int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid
        const char*     pszCompositeID;     //  splicing video wall ID
        int             nWindow;            // window no., -1 means all window
    } NET_IN_GET_TOUR_SOURCE;
    
    // window tour display source info
    typedef struct tagNET_SPLIT_TOUR_SOURCE
    {
        DWORD           dwSize;
        DH_SPLIT_SOURCE*    pstuSrcs;       // display source group, user allocation memory
        int             nMaxSrcCount;       // display source max quantity
        int             nRetSrcCount;       // return display source quantity
    } NET_SPLIT_TOUR_SOURCE;
    
    // CLIENT_GetTourSource port  output parameter
    typedef struct tagNET_OUT_GET_TOUR_SOURCE
    {
        DWORD          dwSize;
        NET_SPLIT_TOUR_SOURCE* pstuWndSrcs; // window tour info group, user allocation memory
        int            nMaxWndCount;        // window max group, user fill in
        int            nRetWndCount;        // return window  quantity
    } NET_OUT_GET_TOUR_SOURCE;
    
    // split tour status info
    typedef struct tagNET_SPLIT_TOUR_STATUS_INFO
    {
        DWORD          dwSize;
        int            nWindow;             // window no.
        NET_TOUR_STATUS   emStatus;         // status
        DH_SPLIT_WND_SOURCE stuSource;      //  current display source info
    }NET_SPLIT_TOUR_STATUS_INFO;
    
    // tour status call function origin, lAttachHandle is CLIENT_AttachSplitTour return value
    typedef void (CALLBACK *fTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SPLIT_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);
    
    // CLIENT_AttachSplitTourport input parameter
    typedef struct tagNET_IN_ATTACH_SPLIT_TOUR
    {
        DWORD           dwSize;
        int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid
        const char*     pszCompositeID;     //  splicing video wall ID
        fTourStatusCallBack cbStatus;       // tour status call function
        LDWORD          dwUser;             // tour status call function
    }NET_IN_ATTACH_SPLIT_TOUR;
    
    // CLIENT_AttachSplitTourport  output parameter
    typedef struct tagNET_OUT_ATTACH_SPLIT_TOUR
    {
        DWORD           dwSize;
    }NET_OUT_ATTACH_SPLIT_TOUR;
    
    // fAttachRecordInfoCB parameter, information of reported video file
    typedef struct tagNET_CB_RECORD_INFO
    {
        DWORD                   dwSize;
        int                     nChannel;               // Channel number
        char                    szFileName[MAX_PATH];   // The name of the video
        DWORD                   dwType;                 // Video type,defined by bit as follows??
        // Bit0-Timing video
        // Bit1-Dynamic test video
        // Bit2-Alarm video
        // Bit3-Video card number
        DWORD                   dwState;                // Video status, 0 - packaging, 1 - to delete
    } NET_CB_RECORD_INFO;
    
    
    
    // Video update callback function prototype??lAttachHandle is return value of CLIENT_AttachRecordInfo, n strip per time??pBuf->dwSize * n == nBufLen
    typedef void (CALLBACK *fAttachRecordInfoCB)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_RECORD_INFO* pBuf, int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttachRecordInfo  Input Parameters
    typedef struct tagNET_IN_ATTACH_RECORD_INFO
    {
        DWORD                   dwSize;
        int                     nInterval;              // Time Interval, Every Interval second, equipment send video information
        int                     nDelay;                 // Report Delay, after equipment choice a random number between 1 and nDelay value, delay report video state, nDelayMust be smaller than nInterval
        fAttachRecordInfoCB     cbAttachRecordInfo;     // Video update callback function
        LDWORD                  dwUser;                 // User data
    } NET_IN_ATTACH_RECORD_INFO;
    
    typedef struct tagNET_OUT_ATTACH_RECORD_INFO
    {
        DWORD                   dwSize;
    } NET_OUT_ATTACH_RECORD_INFO;
    
    
    //Subscribe to PTZ metadata interface and callback function prototypes
    //Pbufs at this stage mainly DH_PTZ_LOCATION_INFO type
    typedef void (CALLBACK *fPTZStatusProcCallBack)(LLONG lLoginID, LLONG lAttachHandle, void* pBuf, int nBufLen, LDWORD dwUser);
    
    // Subscribe to PTZ metadata interface input parameters
    typedef struct tagNET_IN_PTZ_STATUS_PROC
    {
        DWORD                   dwSize;
        int                     nChannel;              // PTZ Channel
        fPTZStatusProcCallBack  cbPTZStatusProc;       // Callback function
        LDWORD                  dwUser;                // User data
    }NET_IN_PTZ_STATUS_PROC;
    
    // Subscribe to PTZ metadata interface output parameters
    typedef struct tagNET_OUT_PTZ_STATUS_PROC
    {
        DWORD                   dwSize;
    }NET_OUT_PTZ_STATUS_PROC;
    
    //PTZ conditions for visual structure
    typedef struct tagDH_OUT_PTZ_VIEW_RANGE_STATUS
    {
        DWORD      dwSize;
        double     dbDistance;                         // Visual range, the unit: m
        int        nAngelH;                            // Horizontal viewing angles, 0~1800, unit: degrees
        int        nAzimuthH;                          // Horizontal azimuth Angle, 0 ~ 3600, unit: degrees
        int        nInclinationH;                      // Horizontal inclination angle, -900~900, unit: degree
    }DH_OUT_PTZ_VIEW_RANGE_STATUS;
    
    //Subscribe to yuntai horizon callback function prototype
    typedef void (CALLBACK *fViewRangeStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, DH_OUT_PTZ_VIEW_RANGE_STATUS* pBuf, int nBufLen, LDWORD dwUser);
    
    // Subscribe to the visible range input parameters
    typedef struct tagNET_IN_VIEW_RANGE_STATE
    {
        DWORD                   dwSize;
        int                     nChannel;              // PTZ channel
        fViewRangeStateCallBack cbViewRange;           // State Callback Function
        LDWORD                  dwUser;                // User Data
    }NET_IN_VIEW_RANGE_STATE;
    
    // Subscribe to the visible range output parameters
    typedef struct tagNET_OUT_VIEW_RANGE_STATE
    {
        DWORD                   dwSize;
    }NET_OUT_VIEW_RANGE_STATE;
    
    //Set the PTZ vision information
    typedef struct tagPTZ_VIEW_RANGE_INFO
    {
        int                     nStructSize;
        int                     nAzimuthH;              // Horizontal azimuth Angle, 0~3600, unit: degrees
    }PTZ_VIEW_RANGE_INFO;
    
    // Channel number information
    typedef struct tagNET_CHN_COUNT_INFO
    {
        DWORD                   dwSize;
        int                     nMaxTotal;              // Equipment to the total number of channels (the sum of all valid channel number
        int                     nCurTotal;              // the number of configured on channels
        int                     nMaxLocal;              // Maximum number of local channels, including motherboard and pluggable cartoon
        int                     nCurLocal;              // configured local channel number
        int                     nMaxRemote;             // Maximum number of remote channel
        int                     nCurRemote;             // Configured remote channel number
    } NET_CHN_COUNT_INFO;
    
    // Equipment channel number information
    typedef struct tagNET_DEV_CHN_COUNT_INFO
    {
        DWORD                   dwSize;
        NET_CHN_COUNT_INFO      stuVideoIn;             // Video Input Channel
        NET_CHN_COUNT_INFO      stuVideoOut;            // Video Output Channel
    } NET_DEV_CHN_COUNT_INFO;
    
    //  detailed information of video state
    typedef struct tagNET_RECORD_STATE_DETAIL
    {
        DWORD                   dwSize;
        BOOL                    bMainStream;            // The main stream, TRUE - are video, FALSE - not in the video
        BOOL                    bExtraStream1;          // Auxiliary stream 1, TRUE - are video, FALSE - not in the video
        BOOL                    bExtraStream2;          // Auxiliary stream 2, TRUE - are video, FALSE - not in the video
        BOOL                    bExtraStream3;          // Auxiliary stream 3, TRUE - are video, FALSE - not in the video
    } NET_RECORD_STATE_DETAIL;
    
    // OSN Interface return to status code
    typedef enum{
        EM_OSN_OK,                                      // Successful Operation
        EM_OSN_OK_P2P,                                  // Operation is successful, create P2P mapping type
        EM_OSN_OK_RELAYED,                              // Operation is successful, create RALAYED mapping type
        EM_OSN_ERROR_API_NOT_INITIALIZED,               // Failed to initialize
        EM_OSN_ERROR_NO_NETWORK,                        // No Available Net
        EM_OSN_ERROR_CANNOT_CONNECT_TO_AGENT,           // Unable to connect to the specified host
        EM_OSN_ERROR_LOCAL_PORT_ALREADY_USED,           // Unable to connect to the specified host
        EM_OSN_ERROR_AGENT_RESOURCES_LIMIT_REACHED,     // Unable to connect, maximum number of connections to achieve
        EM_OSN_ERROR_INVALID_DEVICE_ID,                 // Device ID illegal
        EM_OSN_ERROR_INVALID_SERVICE_PORT,              // Service port illegal
        EM_OSN_ERROR_INVALID_LOCAL_PORT,                // Local port illegal
        EM_OSN_ERROR_INVALID_TUNNEL,                    // mapping information illegal(when deleting the mapping information mapping)
        EM_OSN_ERROR                                    // unknown error
    }EM_OSN_STATUS;
    
    //Mapping the input parameters
    typedef struct {
        unsigned int             servicePort;           // Service port (for example, 80900, 0102, 5 or 23)
        unsigned int             localPort;             // local port 1024 - 65536??0 means automatically assigned
        const char*              pdeviceId;             // Device ID
        BYTE                     Reserved[64];          // reserve
    }OSN_IN_CREATE_TUNNEL_PARAM, *LPOSN_IN_CREATE_TUNNEL_PARAM;
    
    // Establish a mapping output parameters
    typedef struct {
        unsigned int             servicePort;           // Service port (for example, 80900, 0102, 5 or 23)
        unsigned int             localPort;             // local port  1024 - 65536??0 means automatically assigned
        EM_OSN_STATUS            tunnelStatus;
        const char*              pdeviceId;             // Device ID
        BYTE                     Reserved[64];          // reserve
    }OSN_OUT_CREATE_TUNNEL_PARAM, *LPOSN_OUT_CREATE_TUNNEL_PARAM;
    
    // Delete the map input parameters
    typedef struct {
        unsigned int             servicePort;           // Service port (for example, 80,9000,1025 or 23)
        unsigned int             localPort;             // local port 1024 - 65536??0 means automatically assigned
        EM_OSN_STATUS            tunnelStatus;
        const char*              pdeviceId;             // Device ID
        BYTE                     Reserved[64];          // reserve
    }OSN_IN_DESTROY_TUNNEL_PARAM, *LPOSN_IN_DESTROY_TUNNEL_PARAM;
    
    //PTZ Absolute Focus Corresponding Structure
    typedef struct tagPTZ_Focus_Absolutely
    {
        DWORD                    dwValue;               // PTZ Focused On Location, range (0~8191)
        DWORD                    dwSpeed;               // PTZ Focused On Speed, the scope (0~7)
        char                     szReserve[64];         // reserved 64 bytes
    }PTZ_FOCUS_ABSOLUTELY;
    
    // CLIENT_PlayAudioFile   Interface Input Parameters
    typedef struct tagNET_IN_PLAY_AUDIO_FILE
    {
        DWORD                   dwSize;
        const char*             pszFilePath;            // File Path
        DWORD                   dwOutput;               // Output Path, can be a variety of output, according to the bit, bit0-mic, bit1-speaker
    } NET_IN_PLAY_AUDIO_FILE;
    
    // CLIENT_PlayAudioFile   Interface Output Parameters
    typedef struct tagNET_OUT_PLAY_FILE_STREAM
    {
        DWORD                   dwSize;
    } NET_OUT_PLAY_AUDIO_FILE;
    
    // RTSP URLInformation list structure
    typedef struct tagNET_DEV_RTSPURL_LIST
    {
        DWORD                   dwSize;
        int                     nChannelID;                                 // Channel number (user input parameters)
        int                     nUrlNum;                                    // Url Address Number
        char                    szURLList[DH_MAX_URL_NUM][DH_MAX_URL_LEN];  // UrlAddress List
    }NET_DEV_RTSPURL_LIST;
    
    // PTZ control - fan and corresponding structure
    typedef struct tagPTZ_Control_SectorScan
    {
        int             nBeginAngle;                    // Staring Angle,Range:[-180,180]
        int             nEndAngle;                      // Ending Angle,Range:[-180,180]
        int             nSpeed;                         // Speed,Range:[0,255]
        char            szReserve[64];                  // Reserved 64 bytes
    }PTZ_CONTROL_SECTORSCAN;
    
    // control Fish eye E-PTZ info
    typedef struct tagPTZ_CONTROL_SET_FISHEYE_EPTZ
    {
        DWORD       dwSize;	                // structure size
        DWORD       dwWindowID;             // EPtz control window no.
        DWORD       dwCommand;              // E-PTZ command
        DWORD       dwParam1;               // command corresponding to parameter 1
        DWORD       dwParam2;               // command corresponding to  parameter 2
        DWORD       dwParam3;               // command corresponding to  parameter 3
        DWORD       dwParam4;               // command corresponding to  parameter 4
    }PTZ_CONTROL_SET_FISHEYE_EPTZ;
    
    // CLIENT_TransmitInfoForWeb   Interface Extension Parameters
    typedef struct tagNET_TRANSMIT_EXT_INFO
    {
        DWORD           dwSize;
        unsigned char*  pInBinBuf;                      // Binary Input Data Buffer
        DWORD           dwInBinBufSize;                 // Binary Input Data Length
    } NET_TRANSMIT_EXT_INFO;
    
    // Monitor CAN Bus Data
    // fAttachProxyCB Parameter
    typedef struct tagNET_CB_CANDATA
    {
        DWORD           dwSize;
        int             nDataLength;                    // Common Data Length
        unsigned char*  pDataContent;                   // Common Data Content
    }NET_CB_CANDATA;
    
    // Monitor CAN bus data callback function prototype ??lAttachHandle is return value of CLIENT_AttachCAN
    typedef void (CALLBACK *fAttachCANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_CANDATA* pBuf, LDWORD dwUser);
    
    // CLIENT_AttachCAN() Input Parameters
    typedef struct tagNET_IN_ATTACH_CAN
    {
        DWORD          dwSize;
        int            nChannel;                        // Monitor CAN channel number
        fAttachCANCB   cbAttachCAN;                     // Callback Registered Video Phone State Changes
        LDWORD         dwUser;                          // User Data
    }NET_IN_ATTACH_CAN;
    
    // CLIENT_AttachCAN() Output Parameters
    typedef struct tagNET_OUT_ATTACH_CAN
    {
        DWORD          dwSize;
    }NET_OUT_ATTACH_CAN;
    
    // CLIENT_SendCAN() input parameter
    typedef struct tagNET_IN_SEND_CAN
    {
        DWORD          dwSize;
        int            nChannel;                       // CAN channel no.
        int            nSendDataLength;                // Send data length
        unsigned char* pSendData;                      // Send data content
    }NET_IN_SEND_CAN;
    
    // CLIENT_SendCAN() output parameter
    typedef struct tagNET_OUT_SEND_CAN
    {
        DWORD          dwSize;
    }NET_OUT_SEND_CAN;
    
    // parameter of fAttachDevCommCB
    typedef struct tagNET_CB_DEVCOMMDATA
    {
        DWORD           dwSize;
        int             nDataLength;                    // data length
        unsigned char*  pDataContent;                   // data content
    }NET_CB_DEVCOMMDATA;
    
    // callback prototype of listening to data from trans comm, lAttachHandle is return value of CLIENT_AttachDevComm
    typedef void (CALLBACK *fAttachDevCommCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_DEVCOMMDATA* pBuf, LDWORD dwUser);
    
    // CLIENT_AttachDevComm() input parameter
    typedef struct tagNET_IN_ATTACH_DEVCOMM
    {
        DWORD               dwSize;
        int                 nChannel;                        // channel
        fAttachDevCommCB    cbAttachDevComm;                 // callback function
        LDWORD              dwUser;                          // user param
    }NET_IN_ATTACH_DEVCOMM;
    
    // CLIENT_AttachDevComm() output parameter
    typedef struct tagNET_OUT_ATTACH_DEVCOMM
    {
        DWORD          dwSize;
    }NET_OUT_ATTACH_DEVCOMM;
    
    // Gets the current equipment serial number??corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_GET_COMM_COUNT command parameter
    typedef struct tagNET_GET_COMM_COUNT
    {
        DWORD          dwSize;
        int            nChannelCout;                    // Number Of Accessed serial port
    }NET_GET_COMM_COUNT;
    
    // CLIENT_ExChangeData  port input  structure
    typedef struct tagNET_IN_EXCHANGEDATA
    {
        DWORD           dwSize;
        int             nChannel;                       // serial port no
        BOOL            bFlag;                          // TRUE is to send data and wait for response??FALSE is to collect data
        int             nCollectTime;                   // Serial collection time length(unit??ms)
        int             nSendDataLength;                // send data length??bFlag = TRUE valid
        unsigned char*  pSendData;                      // send data content??bFlag = TRUE valid
    }NET_IN_EXCHANGEDATA;
    
    // CLIENT_ExChangeData port output  structure
    typedef struct tagNET_OUT_EXCHANGEDATA
    {
        DWORD           dwSize;
    }NET_OUT_EXCHANGEDATA;
    
    // PTZ preset
    typedef struct tagNET_PTZ_PRESET
    {
        int                     nIndex;                         // no.
        char                    szName[PTZ_PRESET_NAME_LEN];    // name
        char                    szReserve[64];                  // reserve 64 bytes
    } NET_PTZ_PRESET;
    
    // PTZ preset list
    typedef struct tagNET_PTZ_PRESET_LIST
    {
        DWORD                   dwSize;
        DWORD                   dwMaxPresetNum;                 // preset max
        DWORD                   dwRetPresetNum;                 // return preset quantity
        NET_PTZ_PRESET          *pstuPtzPorsetList;             // preset list(apply according to max quantity)
    } NET_PTZ_PRESET_LIST;
    
    // event type EVENT_IVS_TRAFFIC_RESTRICTED_PLATE (limited plate event)corresponding data module description info
    typedef struct tagDEV_EVENT_TRAFFIC_RESTRICTED_PLATE
    {
        int                     nChannelID;                     // channel no.
        char                    szName[DH_EVENT_NAME_LEN];      // event name
        int                     nTriggerType;                   // TriggerType:??0 vehicle detector??1 radar??2 video
        DWORD                   PTS;                            // time stamp(unit is ms)
        NET_TIME_EX             UTC;                            // event time
        int                     nEventID;                       // event ID
        int                     nSequence;                      // snapshot no.??as 3,2,1,1 means snapshot end,0 means abnormal end
        BYTE                    byEventAction;                  // event action??0 means impulse event,1 means continuous event start,2 means continuous event end;
        BYTE                    byImageIndex;                   // picture no., same time(to second)may have many pictures, from 0
        BYTE                    byReserved1[2];
        int                     nLane;                          // corresponding lane no.
        DH_MSG_OBJECT           stuObject;                      // detect object
        DH_MSG_OBJECT           stuVehicle;                     // vehicle info
        DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding file info
        int                     nMark;                          // basic level generated trigger snapshot frame mark
        int                     nFrameSequence;                 // video analysis frame no.
        int                     nSource;                        // video analysis data surce address
        DWORD                   dwSnapFlagMask;                 // snapshot mark (by bit)??see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO      stuResolution;                  // corresponding picture resolution
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
        BYTE                    byReserved[1024];               // reserve text
        EVENT_COMM_INFO         stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_RESTRICTED_PLATE;
    
    // event type EVENT_IVS_TRAFFIC_OVERSTOPLINE (cross line event)corresponding to data module info
    typedef struct tagDEV_EVENT_TRAFFIC_OVERSTOPLINE
    {
        int                     nChannelID;                     // channel no.
        char                    szName[DH_EVENT_NAME_LEN];      // event name
        int                     nTriggerType;                   // TriggerType: trigger type??0 detect??1 radar??2 video
        DWORD                   PTS;                            // time stamp( unit is ms)
        NET_TIME_EX             UTC;                            // event time
        int                     nEventID;                       // event ID
        int                     nSequence;                      // snapshot no.
        BYTE                    byEventAction;                  // event action??
        BYTE                    byImageIndex;                   //picture no., within same time, may have more than one picture, start ftom 0
        BYTE                    byReserved1[2];
        int                     nLane;                          // corresponding to lane no.
        DH_MSG_OBJECT           stuObject;                      // detected object
        DH_MSG_OBJECT           stuVehicle;                     // vehicle body info
        DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding to text
        int                     nMark;                          // bottom trigger snapshot frame mark
        int                     nFrameSequence;                 // video analysis no.
        int                     nSource;                        // video analysis data source address
        DWORD                   dwSnapFlagMask;                 // snapshot maek??see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO      stuResolution;                  // corresponding to picture resolution
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
        int                     nSpeed;                         // vehicle speed,Km/h
        BYTE                    byReserved[1024];               // reserved text
        EVENT_COMM_INFO         stCommInfo;                     // public info
    }DEV_EVENT_TRAFFIC_OVERSTOPLINE;
    
    
    typedef enum tagNET_SAFEBELT_STATE
    {
        SS_NUKNOW  = 0 ,            // unknown
        SS_WITH_SAFE_BELT ,         //fastened seat belt
        SS_WITHOUT_SAFE_BELT ,      // unfasten seat belt
    }NET_SAFEBELT_STATE;
    
    // event type EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(Traffic unfasten seat belt event event )corresponding to data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT
    {
        int           nChannelID;					// channel no.
        char          szName[DH_EVENT_NAME_LEN];    // event name
        int           nTriggerType;                 // TriggerType:trigger type ??0 vehicle detector??1 radar??2 video
        DWORD         PTS;                          // time stamp(unit is ms)
        NET_TIME_EX   UTC;                          // event occurred time
        int           nEventID;                     // event ID
        int           nSequence;                    // means snaoshot no.??as 3,2,1,1 means snapshotend ,0 means abnormal end
        BYTE          byEventAction;                // event  motion ??0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
        BYTE          byImageIndex;                 // picture no., same time(accurate to second)may have multiple pictures , start from 0
        BYTE          byReserved1[2];
        DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info
        int           nLane;                        // corresponding to lane no.
        int           nMark;                        // bottom generated trigger snapshot frame mark
        int           nFrameSequence;               // video analysis frame no.
        int           nSource;                      // video analysis data source address
        DH_MSG_OBJECT      stuObject;               // detection object
        DH_MSG_OBJECT      stuVehicle;              // body info
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info
        int           nSpeed;                       // vehicle actual speed,Km/h
        NET_SAFEBELT_STATE   emMainSeat;            // main driver seat belt status
        NET_SAFEBELT_STATE   emSlaveSeat;           // co-drvier seat belt status
        DWORD         dwSnapFlagMask;               // snapshot mark(by bit)??see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
        BYTE          byReserved[1024];             // reserved text
        EVENT_COMM_INFO     stCommInfo;             // public info
    }DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT;
    
    // event type EVENT_IVS_TRAFFIC_DRIVER_SMOKING (driver smoke event )corresponding to data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_SMOKING
    {
        int           nChannelID;                   // channel no.
        char          szName[DH_EVENT_NAME_LEN];    // event name
        int           nTriggerType;                 // TriggerType: trigger type ??0 vehicle detector??1 radar??2 video
        DWORD         PTS;                          // time stamp(unit is ms)
        NET_TIME_EX   UTC;                          // event occurred time
        int           nEventID;                     // event ID
        int           nSequence;                    // means snapshot no.?? as 3,2,1,1 means snapshot end,0 means abnormal end
        BYTE          byEventAction;                // event  motion ??0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
        BYTE          byImageIndex;                 // picture no., same time(accurate to second) may be multiple pictures , start from 0
        BYTE          byReserved1[2];
        DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info
        int           nLane;                        // corresponding to lane no.
        int           nMark;                        // bottom occurred trigger snapshot mark
        int           nFrameSequence;               // video analysis frame no.
        int           nSource;                      // video analysis data source address
        DH_MSG_OBJECT      stuObject;               // detection received object
        DH_MSG_OBJECT      stuVehicle;              // body info
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info
        int           nSpeed;                       // car actual speed,Km/h
        DWORD         dwSnapFlagMask;               // snapshot mark(by bit)??see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
        EVENT_COMM_INFO     stCommInfo;             // public info
        BYTE          byReserved[1024];             // reserve text
    }DEV_EVENT_TRAFFIC_DRIVER_SMOKING;
    
    // event type EVENT_IVS_TRAFFIC_DRIVER_CALLING(driver call event )corresponding to data block description info
    typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_CALLING
    {
        int           nChannelID;                   // channel no.
        char          szName[DH_EVENT_NAME_LEN];    // event name
        int           nTriggerType;                 // TriggerType: trigger type ??0 vehicle detector??1 radar??2 video
        DWORD         PTS;                          // time stamp(unit is ms)
        NET_TIME_EX   UTC;                          // event occurred time
        int           nEventID;                     // event ID
        int           nSequence;                    // means snapshot no.??as 3,2,1,1 means snapshot end,0 means abnormal end
        BYTE          byEventAction;                // event  motion ??0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
        BYTE          byImageIndex;                 // picture no., same time (accurate to second) maybe multiple picture , start from 0
        BYTE          byReserved1[2];
        DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info
        int           nLane;                        // corresponding to lane no.
        int           nMark;                        // bottom trigger snapshot frame mark
        int           nFrameSequence;               // video analysis frame no.
        int           nSource;                      // video analysis data source address
        DH_MSG_OBJECT      stuObject;               // detection received object
        DH_MSG_OBJECT      stuVehicle;              // body info
        DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info
        int           nSpeed;                       // vehicle actual speed,Km/h
        DWORD         dwSnapFlagMask;               // snapshot mark(by bit)??see NET_RESERVED_COMMON
        DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
        EVENT_COMM_INFO     stCommInfo;             // public info
        BYTE          byReserved[1024];             // reserve text
    }DEV_EVENT_TRAFFIC_DRIVER_CALLING;
    
    // event type EVENT_IVS_OBJECT_DETECTION(object feature detection event )corresponding to data description info
    typedef struct tagDEV_EVENT_TRAFFIC_OBJECT_DETECTION
    {
        int	        nChannelID;                     // channel no.
        char        szName[128];                    // event name
        char        bReserved1[4];                  // field align
        double      PTS;                            // time stamp(unit is ms)
        NET_TIME_EX     UTC;                        // event occurred time
        int         nEventID;                       // event ID
        DH_EVENT_FILE_INFO stuFileInfo;             // event corresponding to file info
        BYTE        bEventAction;                   // event  motion ??0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;
        BYTE        byReserved[2];                  // reserved text
        BYTE        byImageIndex;                   // picture no., same time(accurate to second)may be multiple picture , start from 0
        DWORD       dwSnapFlagMask;                 // snapshot mark(by bit)??see NET_RESERVED_COMMON
        int         nSourceIndex;                   // event source device index,-1 means data invalid
        char        szSourceDevice[MAX_PATH];       // event source device SN, field does not exist or null means local device
        unsigned int    nOccurrenceCount;           // event trigger accumilated times
        int         nObjectNum;                     //object info number
        DH_MSG_OBJECT_EX  *pstObjectInfo;           //object info data
        BYTE        byReserved2[1024];              //reserved text
    }DEV_EVENT_TRAFFIC_OBJECT_DETECTION;
    
    // redundant power abnormal alarm
    typedef struct tagALARM_POWER_ABNORMAL_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // channel no.
        NET_TIME                stuTime;                        // time
        DWORD                   dwAction;                       // event ation, 0:Start, 1:Stop
    }ALARM_POWER_ABNORMAL_INFO;
    
    // Tri-status enable
    typedef enum tagNET_THREE_STATE_ENABLE
    {
        EM_STATE_ENABLE_INVALID = 0,            // invalid
        EM_STATE_ENABLE_OFF,                    // off
        EM_STATE_ENABLE_ON,                     // on
    } NET_THREE_STATE_ENABLE;
    
    // config enable change reported event
    typedef struct tagCONFIG_ENABLE_CHANGE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // chanle no., start from 0
        NET_THREE_STATE_ENABLE  emMotionDetect;                 // motion detect,     0: invalid , 1: off, 2: on
        NET_THREE_STATE_ENABLE  emLossDetect;                   // video loss enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emBlindDetect;                  // video tempering enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emAlarmLocal;                   // external alarm enable, 0: invalid , 1: off, 2: on
        NET_THREE_STATE_ENABLE  emBlindDetect;                  // blind detect enable, 0: invalid , 1: off, 2: on
        NET_THREE_STATE_ENABLE  emAlarmLocal;                   // alarm local enable, 0: invalid , 1: off, 2: on
    }ALARM_CONFIG_ENABLE_CHANGE_INFO;
    
#define UPDATE_VERSION_LEN        64
    
    // get device upgrade status corresponding structure
    typedef struct tagDHDEV_UPGRADE_STATE_INFO
    {
        int                  nState;                            // 0:None- no update found, default status; 1:Regular-general upgrade;
        // 2:Emergency-forced; 3:Upgrading-upgrading
        
        char                szOldVersion[UPDATE_VERSION_LEN];   // old version
        char                szNewVersion[UPDATE_VERSION_LEN];   // new version
        DWORD               dwProgress;                         // upgrading progress
        int                 reserved[256];                      // reserve text
    }DHDEV_UPGRADE_STATE_INFO;
    
    
    /////////////////////////////////Burning Session /////////////////////////////////////////
    
    // CLIENT_StartBurnSession port input parameter
    typedef struct tagNET_IN_START_BURN_SESSION
    {
        DWORD               dwSize;
        unsigned int        nSessionID;                         // session ID
    } NET_IN_START_BURN_SESSION;
    
    typedef struct tagNET_OUT_START_BURN_SESSION
    {
        DWORD               dwSize;
    } NET_OUT_START_BURN_SESSION;
    
    // Burning session
    typedef enum tagNET_BURN_MODE
    {
        BURN_MODE_SYNC,                     // sync
        BURN_MODE_TURN,                     // turn
        BURN_MODE_CYCLE,                    // cycle
    } NET_BURN_MODE;
    
    // burning stream format
    typedef enum tagNET_BURN_RECORD_PACK
    {
        BURN_PACK_DHAV,                     // DHAV
        BURN_PACK_PS,                       // PS
        BURN_PACK_ASF,                      // ASF
        BURN_PACK_MP4,                      // MP4
        BURN_PACK_TS,                       // TS
    } NET_BURN_RECORD_PACK;
    
    // CLIENT_StartBurn port input parameter
    typedef struct tagNET_IN_START_BURN
    {
        DWORD                dwSize;
        DWORD                dwDevMask;                             // burning device mask, by bit means multiple burning device group
        int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
        int                  nChannelCount;                         // burning channel number
        NET_BURN_MODE        emMode;                                // burning mode
        NET_BURN_RECORD_PACK emPack;                                // burning stream format
    } NET_IN_START_BURN;
    
    // CLIENT_StartBurn port output parameter
    typedef struct tagNET_OUT_START_BURN
    {
        DWORD               dwSize;
    } NET_OUT_START_BURN;
    
    // CLIENT_BurnMarkTag port input parameter
    typedef struct tagNET_IN_BURN_MAAK_TAG
    {
        DWORD               dwSize;
        const char*         pszDescInfo;                            // mark description info
    } NET_IN_BURN_MARK_TAG;
    
    // CLIENT_BurnMarkTag port output parameter
    typedef struct tagNET_OUT_BURN_MAAK_TAG
    {
        DWORD               dwSize;
    } NET_OUT_BURN_MARK_TAG;
    
    // CLIENT_BurnChangeDisk port input parameter
    typedef struct tagNET_IN_BURN_CHANGE_DISK
    {
        DWORD               dwSize;
        BOOL                nAction;                                // switch action, 0-start, 1-end
    } NET_IN_BURN_CHANGE_DISK;
    
    // CLIENT_BurnChangeDisk port output parameter
    typedef struct tagNET_OUT_BURN_CHANGE_DISK
    {
        DWORD               dwSize;
    } NET_OUT_BURN_CHANGE_DISK;
    
    // burning status
    typedef enum tagNET_BURN_STATE
    {
        BURN_STATE_STOP,                    // stop
        BURN_STATE_STOPING,                 // stoping
        BURN_STATE_INIT,                    // initialize
        BURN_STATE_BURNING,                 // burning
        BURN_STATE_PAUSE,                   // pause
        BURN_STATE_CHANGE_DISK,             // changing
        BURN_STATE_PREPARE_EXTRA_FILE,      // attachment initialize
        BURN_STATE_WAIT_EXTRA_FILE,         // wait for attachment burning
        BURN_STATE_UPLOAD_FILE_START,       // attachment burning
        BURN_STATE_CHECKING_DISK,           // detecting disk
        BURN_STATE_DISK_READY,              // disk is ready
    } NET_BURN_STATE;
    
    // burning error code
    typedef enum tagNET_BURN_ERROR_CODE
    {
        BURN_CODE_NORMAL,                   // normal
        BURN_CODE_UNKNOWN_ERROR,            // unknown error
        BURN_CODE_SPACE_FULL,               // burning full
        BURN_CODE_START_ERROR,              // start burning error
        BURN_CODE_STOP_ERROR,               // normal
        BURN_CODE_WRITE_ERROR,              // burning error
    } NET_BURN_ERROR_CODE;
    
    // CLIENT_BurnGetState port input parameter
    typedef struct tagNET_IN_BURN_GET_STATE
    {
        DWORD                dwSize;
    } NET_IN_BURN_GET_STATE;
    
    // burning device status
    typedef struct tagNET_BURN_DEV_STATE
    {
        DWORD                dwSize;
        int                  nDeviceID;                             // ROM device ID
        char                 szDevName[DH_BURNING_DEV_NAMELEN];     // ROM devicename
        DWORD                dwTotalSpace;                          // ROM total capacity, uni KB
        DWORD                dwRemainSpace;                         // ROM remaining capacity, unit KB
    } NET_BURN_DEV_STATE;
    
    // CLIENT_BurnGetState port output parameter
    typedef struct tagNET_OUT_BURN_GET_STATE
    {
        DWORD                dwSize;
        NET_BURN_STATE       emState;                               // burning status
        NET_BURN_ERROR_CODE  emErrorCode;                           // error code
        DWORD                dwDevMask;                             // burning device mask, by bit means multiple device group
        int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
        int                  nChannelCount;                         // burning channel number
        NET_BURN_MODE        emMode;                                // burning mode
        NET_BURN_RECORD_PACK emPack;                                // burning stream format
        int                  nFileIndex;                            // current burning file no.
        NET_TIME             stuStartTime;                          // burning start time
        NET_BURN_DEV_STATE   stuDevState[DH_MAX_BURNING_DEV_NUM];   // burning device status
    } NET_OUT_BURN_GET_STATE;
    
    // fAttachBurnStateCB parameter
    typedef struct tagNET_CB_BURNSTATE
    {
        DWORD               dwSize;
        const char*         szState;                        // info type
        //"UploadFileStart"??may start to upload attachment
        //"InitBurnDevice":initialize burning device
        //"Burning":burning
        //"BurnExtraFileStop"??stop burning
        //"BurnFilePause":pause burning
        //"SpaceFull":burning space full
        //"BurnFileError": burning error
        const char*         szFileName;                     // current burning file name, use to "UploadFileStart" start upload attachment info
        unsigned int        dwTotalSpace;                   // total capacity, unit KB??use to "Burning" ??display capacity or calculate progress
        unsigned int        dwRemainSpace;                  // free capacity, unit KB??useto "Burning"
        const char*         szDeviceName;                   // burning device name, use for different burning devices
    }NET_CB_BURNSTATE;
    
    // burning device callback function original??lAttachHandle is CLIENT_AttachBurnState return value,each 1 item??pBuf->dwSize == nBufLen
    typedef void (CALLBACK *fAttachBurnStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURNSTATE* pBuf, int nBufLen, LDWORD dwUser);
    
    // burning device callback extension function original
    typedef void (CALLBACK *fAttachBurnStateCBEx)(LLONG lLoginID, LLONG lAttachHandle, NET_OUT_BURN_GET_STATE* pBuf, int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttachBurnState() input parameter
    typedef struct tagNET_IN_ATTACH_STATE
    {
        DWORD                   dwSize;
        const char*             szDeviceName;                   // disk name??as "/dev/sda"
        fAttachBurnStateCB      cbAttachState;                  // burning listening callback
        LDWORD                  dwUser;                         // user data
        LLONG                   lBurnSession;                   // burning session handle, CLIENT_StartBurnSession retuen value. This value is 0, szDeviceName is valid, by burning device subscribe burning status
        fAttachBurnStateCBEx    cbAttachStateEx;                // extension burning listening callback
        LDWORD                  dwUserEx;                       // extension burninglistening callback user data
    }NET_IN_ATTACH_STATE;
    
    // CLIENT_AttachBurnState output parameter
    typedef struct tagNET_OUT_ATTACH_STATE
    {
        DWORD                   dwSize;
    }NET_OUT_ATTACH_STATE;
    
    // burning device callback function orginal??lUploadHandle is CLIENT_StartUploadFileBurned return value
    typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
    
    // CLIENT_StartUploadFileBurned() input parameter
    typedef struct tagNET_IN_FILEBURNED_START
    {
        DWORD                   dwSize;
        const char*             szMode;                        // file upload method "append", append mode, now burning file name fixed as" FILE.zip ",filename ignored
        const char*             szDeviceName;                  // disk name??as ?¡ã/dev/sda?¡À
        const char*             szFilename;                    // local file name
        fBurnFileCallBack       cbBurnPos;                     // burning progress callback
        LDWORD                  dwUser;                        // user data
        LLONG                   lBurnSession;                  // burning handle, CLIENT_StartBurnSession return value This value is , szDeviceName valid, now by burning device subscribe burning status
    }NET_IN_FILEBURNED_START;
    
    // CLIENT_StartUploadFileBurned output parameter
    typedef struct tagNET_OUT_FILEBURNED_START
    {
        DWORD                   dwSize;
        char                    szState[DH_MAX_NAME_LEN];      // "start"??system is ready,may start to upload; "busy"??system busy, try later."error"??system is not burning, return error, request failed
    }NET_OUT_FILEBURNED_START;
    
    // burning case info
    typedef struct tagNET_BURN_CASE_INFO
    {
        DWORD       dwSize;
        int         nChannel;                                   // channel no.
        NET_TIME    stuStartTime;                               // burning start time
        NET_TIME    stuEndTime;                                 // burning end time
        int         nIndex;                                     // sn
        int         nCode;                                      // no.
        int         nDiscNum;                                   // disk no.
        char        szName[DH_COMMON_STRING_128];               // name
        char        szPlace[DH_COMMON_STRING_128];              // location
        char        szInvestigator[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32]; // handled by
        char        szSuspects[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32];     // invloved
        char        szMemo[DH_COMMON_STRING_256];               // note
        char        szVideoName[DH_COMMON_STRING_128];          // record name
        char        szRecorder[DH_COMMON_STRING_32];            // burned by
    } NET_BURN_CASE_INFO;
    
    // burning device callback function original??lAttachHandle is CLIENT_AttachBurnCase return value
    typedef void (CALLBACK *fBurnCaseCallBack) (LLONG lAttachHandle, NET_BURN_CASE_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);
    
    // CLIENT_AttachBurnCase port input parameter
    typedef struct tagNET_IN_ATTACH_BURN_CASE
    {
        DWORD                dwSize;
        fBurnCaseCallBack    cbBurnCase;                        // case info callback function
        LDWORD               dwUser;                            // user data
    } NET_IN_ATTACH_BURN_CASE;
    
    // CLIENT_AttachBurnCase port output parameter
    typedef struct tagNET_OUT_ATTACH_BURN_CASE
    {
        DWORD                dwSize;
    } NET_OUT_ATTACH_BURN_CASE;
    
    /////////////////////////////////// Storage ///////////////////////////////////////
    
    // remote storage writing-in result
    typedef enum tagNET_STORAGE_WRITE_STATE
    {
        NS_WRITE_UNKNOWN,                                   // unknown
        NS_WRITE_OK,                                        // successful
        NS_WRITE_DISK_IO_ERROR,                             // disk IO error
        NS_WRITE_DISK_NOT_READY,                            // disk not ready
        NS_WRITE_DISK_FAULT,                                // disk failure
        NS_WRITE_STREAM_NOT_EXIST,                          // data stream ID inexists
        NS_WRITE_MOUNT_DISK_ERROR,                          // disk load error
    } NET_STORAGE_WRITE_STATE;
    
    // remote module info
    typedef struct tagNET_STORAGE_BLOCK
    {
        DWORD                   dwSize;
        unsigned int            nID;                        // CQFS module ID
        unsigned int            nStreamID;                  // data stream SN
        unsigned int            nRecycleTimestamp;          // CQFS recycle time stamp
        unsigned int            nBeginTimestamp;            // module internal data start time stamp
        unsigned int            nEndTimestamp;              //  module internal data endtime stamp
        unsigned int            nLockCount;                 // lock value, 0 means not locked
        char                    szDiskUUID[DH_COMMON_STRING_64]; // disk UUID
    } NET_STORAGE_BLOCK;
    
    // remote storage info status
    typedef struct tagNET_STORAGE_WRITE_INFO
    {
        DWORD                    dwSize;
        NET_STORAGE_WRITE_STATE  emState;                   // writing in result
        int                      nBlockCount;               //  module quantity
        NET_STORAGE_BLOCK        stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; //  module info
    } NET_STORAGE_WRITE_INFO;
    
    //////////////////////////////////////////////////////////////////////////
    /// \fn subscribe write-in remote storage info status callback function
    /// \brief
    /// \author yang_xiuqing
    /// \param  LLONG lAttachHandle [OUT] subscribe handle, CLIENT_NetStorageAttachWriteInfo return value
    /// \param  NET_STORAGE_WRITE_INFO * pBuf [OUT] remote storage info status
    /// \param  int nBufLen [OUT] status info length
    /// \param  LDWORD dwUser user data
    /// \return n/a
    ///////////////////////////////////////////////////////////////////////////
    typedef void (CALLBACK *fNetStorageAttachWriteInfoCB)(LLONG lAttachHandle, NET_STORAGE_WRITE_INFO* pBuf, int nBufLen, LDWORD dwUser);
    
    // CLIENT_NetStorageAttachWriteInfo port input parameter
    typedef struct tagNET_IN_STORAGE_ATTACH_WRITE_INFO
    {
        DWORD                           dwSize;
        const char*                     pszName;                // remote storage name, value from NAS config
        fNetStorageAttachWriteInfoCB    cbISCSIBlcok;           // callback function
        LDWORD                          dwUser;                 // user data
    } NET_IN_STORAGE_ATTACH_WRITE_INFO;
    
    // CLIENT_NetStorageAttachWriteInfo port output parameter
    typedef struct tagNET_OUT_STORAGE_ATTACH_WRITE_INFO
    {
        DWORD                       dwSize;
    } NET_OUT_STORAGE_ATTACH_WRITE_INFO;
    
    // CLIENT_NetStorageGetWriteInfo port input parameter
    typedef struct tagNET_IN_STORAGE_GET_WRITE_INFO
    {
        DWORD                       dwSize;
        const char*                 pszName;                    // remote storage name
    } NET_IN_STORAGE_GET_WRITE_INFO;
    
    // CLIENT_NetStorageGetWriteInfo port output parameter
    typedef struct tagNET_OUT_STORAGE_GET_WRITE_INFO
    {
        DWORD                       dwSize;
        int                         nBlockCount;                //  module quantity
        NET_STORAGE_BLOCK           stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; //  module info
    } NET_OUT_STORAGE_GET_WRITE_INFO;
    
    // RAID operation type
    typedef enum tagNET_RAID_OPERATE_TYPE
    {
        NET_RAID_OPERATE_ADD,                    // add RAID, corresponding structure  NET_IN_RAID_ADD  and NET_OUT_RAID_ADD
        NET_RAID_OPERATE_REMOVE,                 // delete RAID, corresponding structure  NET_IN_RAID_REMOVE  and NET_OUT_RAID_REMOVE
        NET_RAID_OPERATE_GET_SUBDEVICE,          // get RAID sub device info, corresponding structure  NET_IN_RAID_GET_SUBDEVICE  and NET_OUT_RAID_GET_SUBDEVICE
        NET_RAID_OPERATE_GET_SUBSMART,           // get RAID sub device SMART info, corresponding structure  NET_IN_RAID_GET_SUBSMART  and NET_OUT_RAID_GET_SUBSMART
        NET_RAID_OPERATE_MODIFY,                 // modify RAID, corresponding to  structure  NET_IN_RAID_MODIFY and NET_OUT_RAID_MODIFY
    } NET_RAID_OPERATE_TYPE;
    
    // RAID info
    typedef struct tagNET_RAID_INFO
    {
        DWORD                dwSize;
        char                 szName[DH_COMMON_STRING_64];     // name, as time name returned by device
        char                 szLevel[DH_COMMON_STRING_16];    // level, such as "RAID0", "RAID5" and etc.
        int                  nMemberNum;                      // member quantity
        char                 szMembers[DH_MAX_MEMBER_PER_RAID][DH_COMMON_STRING_64]; // member info
    } NET_RAID_INFO;
    
    // add RAID return result
    typedef struct tagNET_RAID_ADD_RESULT
    {
        DWORD                dwSize;
        BOOL                 bResult;
        DWORD                dwErrorCode;                    // failed error code
        char                 szName[DH_COMMON_STRING_64];    // name
    } NET_RAID_ADD_RESULT;
    
    // add RAID input parameter
    typedef struct tagNET_IN_RAID_ADD
    {
        DWORD                dwSize;
        int                    nRaidNun;                        // RAID quantity
        NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
    } NET_IN_RAID_ADD;
    
    // add RAID oiutput parameter
    typedef struct tagNET_OUT_RAID_ADD
    {
        DWORD                dwSize;
        int                  nResultNum;                        // result
        NET_RAID_ADD_RESULT  stuResults[DH_MAX_RAID_NUM];       // RAID operation result
    } NET_OUT_RAID_ADD;
    
    // delete RAID return result
    typedef struct tagNET_RAID_REMOVE_RESULT
    {
        DWORD                dwSize;
        BOOL                 bResult;
        DWORD                dwErrorCode;                       // failed error code
    } NET_RAID_REMOVE_RESULT;
    
    // delete RAID input parameter
    typedef struct tagNET_IN_RAID_REMOVE
    {
        DWORD                dwSize;
        int                  nRaidNum;                         // RAID quantity
        char                 szRaids[DH_MAX_RAID_NUM][DH_COMMON_STRING_64];    // RAID name group
    } NET_IN_RAID_REMOVE;
    
    // delete RAID output parameter
    typedef struct tagNET_OUT_RAID_REMOVE
    {
        DWORD                dwSize;
        int                  nResultNum;                       // result
        NET_RAID_REMOVE_RESULT stuResults[DH_MAX_RAID_NUM];    // RAID operation result
    } NET_OUT_RAID_REMOVE;
    
    // get RAID sub device input parameter
    typedef struct tagNET_IN_RAID_GET_SUBDEVICE
    {
        DWORD                dwSize;
        const char*          pszRaidName;                    // RAID name
    } NET_IN_RAID_GET_SUBDEVICE;
    
    // get RAID sub device output parameter
    typedef struct tagNET_OUT_RAID_GET_SUBDEVICE
    {
        DWORD                dwSize;
        int                  nSubDeviceNum;                  // sub device quantity
        DH_STORAGE_DEVICE    stuSubDevices[DH_MAX_MEMBER_PER_RAID]; // sub device quantity
    } NET_OUT_RAID_GET_SUBDEVICE;
    
    // RAID sub device SMART info
    typedef struct tagNET_RAID_SMART_INFO
    {
        DWORD                dwSize;
        unsigned int         nID;                            // property ID
        char                 szName[DH_COMMON_STRING_64];    // property name
        int                  nCurrent;                       // property value
        int                  nWorst;                         // max error value
        int                  nThreshold;                     // threshold
        int                  nPredict;                       // status
        char                 szRaw[DH_COMMON_STRING_16];     // actual value
    } NET_RAID_SMART_INFO;
    
    // get RAID sub device SMART info input parameter
    typedef struct tagNET_IN_RAID_GET_SUBSMART
    {
        DWORD                dwSize;
        const char*          pszSubDevName;                  // RAID sub device name
    } NET_IN_RAID_GET_SUBSMART;
    
    // get RAID sub device SMART info output parameter
    typedef struct tagNET_OUT_RAID_GET_SUBSMART
    {
        DWORD                dwSize;
        int                  nSmartNum;                          // SMART info
        NET_RAID_SMART_INFO  stuSmartInfos[MAX_SMART_VALUE_NUM]; // SMART info
    } NET_OUT_RAID_GET_SUBSMART;
    
    // modify RAID return result
    typedef struct tagNET_RAID_MODIFY_RESULT
    {
        DWORD                dwSize;
        BOOL                 bResult;
        DWORD                dwErrorCode;                       // failed error code
    } NET_RAID_MODIFY_RESULT;
    
    // modify RAID input parameter
    typedef struct tagNET_IN_RAID_MODIFY
    {
        DWORD                dwSize;
        int                  nRaidNun;                          // RAID quantity
        NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
    } NET_IN_RAID_MODIFY;
    
    // modify RAID output parameter
    typedef struct tagNET_OUT_RAID_MODIFY
    {
        DWORD                dwSize;
        int                  nResultNum;                        // result
        NET_RAID_MODIFY_RESULT stuResults[DH_MAX_RAID_NUM];     // RAID operation result
    } NET_OUT_RAID_MODIFY;
    
    
    //////////////////////////////// external device //////////////////////////////////////////
    
    // external device type
    typedef enum tagNET_EXT_DEV_TYPE
    {
        EXT_DEV_UNKNOWN,                    // unknow
        EXT_DEV_PROJECTOR,                  // projector
        EXT_DEV_SEQUENCE_POWER,            // power sequence
    } NET_EXT_DEV_TYPE;
    
    // external device info
    typedef struct tagNET_EXTERNAL_DEVICE
    {
        DWORD               dwSize;
        NET_EXT_DEV_TYPE    emType;                             // device type
        char                szDevID[DH_DEV_ID_LEN_EX];          // device ID, SN
        char                szDevName[DH_DEV_ID_LEN_EX];        // device name
    } NET_EXTERNAL_DEVICE;
    
    // power sequence control parameter
    typedef struct tagNET_CTRL_SEQPOWER_PARAM
    {
        DWORD               dwSize;
        const char*         pszDeviceID;                        // device ID
        int                 nChannel;                           // output or output sequence
    } NET_CTRL_SEQPOWER_PARAM;
    
    // projector control parameter
    typedef struct tagNET_CTRL_PROJECTOR_PARAM
    {
        DWORD               dwSize;
        const char*         pszDeviceID;                        // device ID
    } NET_CTRL_PROJECTOR_PARAM;
    
    // IR button
    typedef struct tagNET_CTRL_INFRARED_KEY_PARAM
    {
        DWORD               dwSize;
        int                 nChannel;                           // IR control channel no.
        unsigned int        nKey;                               // IR button ID
    } NET_CTRL_INFRARED_KEY_PARAM;
    
    // no HDD alarm
    typedef struct tagALARM_NO_DISK_INFO
    {
        DWORD               dwSize;
        NET_TIME            stuTime;                            // time
        DWORD               dwAction;                           // event action, 0:Start, 1:Stop
    }ALARM_NO_DISK_INFO;
    //protective capsule status enumeration
    typedef enum __EM_CAPSULE_STATE
    {
        CAPSULE_STATE_UNKNOW ,      //undefine
        CAPSULE_STATE_NORMAL ,      //normal
        CAPSULE_STATE_TIME_OUT ,    //overtime
        CAPSULE_STATE_EMERGENCY_CALL,   //sos call
    }EM_CAPSULE_STATE;
    
    //protective capsule event
    typedef struct tagALARM_PROTECTIVE_CAPSULE_INFO
    {
        DWORD               dwSize;
        EM_CAPSULE_STATE    emCapsuleState; //protective capsule status
        DWORD               nLock;          //0:unlock??1:lock; only when emCapsuleStateis CAPSULE_STATE_NORMAL valid
        DWORD               nInfrared;      //0:idle (no one),1:trigger(someone); only emCapsuleState is CAPSULE_STATE_NORMAL valid
    }ALARM_PROTECTIVE_CAPSULE_INFO;
    
    // Get Fish eye capacity input parameter
    typedef struct tagNET_IN_VIDEOIN_FISHEYE_CAPS
    {
        DWORD       dwSize;
        int         nChannel; //channel no.
    }NET_IN_VIDEOIN_FISHEYE_CAPS;
    
    // Get Fish eye capacity  output parameter
    typedef struct tagNET_OUT_VIDEOIN_FISHEYE_CAPS
    {
        DWORD                   dwSize;
        int                     nMountModeNum;              // supported installation mode number
        NET_FISHEYE_MOUNT_MODE  emMountModes[NET_MAX_FISHEYE_MOUNTMODE_NUM]; // supported installation mode list
        int                     nCalibrateModeNum;          // supported Fish eye correction mode number
        NET_FISHEYE_CALIBRATE_MODE emCalibrateModes[NET_MAX_FISHEYE_CALIBRATEMODE_NUM]; // supported Fish eye correction mode list
        int                     nEPtzCmdNum;                // supported Fish eye E-PTZ operation number
        NET_FISHEYE_EPTZ_CMD    emEPtzCmds[NET_MAX_FISHEYE_EPTZCMD_NUM]; // supported Fish eye E-PTZ operationlist
        NET_FISHEYE_TYPE        emType;                     //Fish eye type
    }NET_OUT_VIDEOIN_FISHEYE_CAPS;
    
    // get power sequence input parameter
    typedef struct tagNET_IN_CAP_SEQPOWER
    {
        DWORD                dwSize;
        const char*          pszDeviceID;                       // device ID
    } NET_IN_CAP_SEQPOWER;
    
    // get power sequence output parameter
    typedef struct tagNET_OUT_CAP_SEQPOWER
    {
        DWORD                dwSize;
        int                  nChannelNum;                       // channel no.
    } NET_OUT_CAP_SEQPOWER;
    
    // get device encode config corresponding capacity input parameter
    typedef struct tagNET_IN_ENCODE_CFG_CAPS
    {
        DWORD               dwSize;
        int                 nChannelId;                         // channel no.
        int                 nStreamType;                        // stream type??0??main stream??1??sub stream1??2??sub stream2??3??sub stream3??4??snapshot stream
        // can be left unset, whatever value it is set, you get results of main stream, sub stream1 and snapshot stream
        char*               pchEncodeJson;                      // Encode config??cia calling dhconfigsdk.dll port CLIENT_PacketData to get
        // correspondingsampling command is CFG_CMD_ENCODE
    }NET_IN_ENCODE_CFG_CAPS;
    
    // stream config corresponding capacity
    typedef struct tagNET_STREAM_CFG_CAPS
    {
        DWORD               dwSize;
        int                 nAudioCompressionTypes[DH_MAX_AUDIO_ENCODE_TYPE]; // supported audio encode type??see DH_TALK_CODING_TYPE
        int                 nAudioCompressionTypeNum;                   // audio compression quantity
        int                 dwEncodeModeMask;                           // video encode mode mask??see "encode mode"
        DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution, discard
        int                 nResolutionFPSMax[DH_MAX_CAPTURE_SIZE_NUM]; // different resolution max frame, subscript nResolutionTypescorresponding
        int                 nResolutionTypeNum;                         // video resolution quantity
        int                 nMaxBitRateOptions;                         // max video stream(kbps)
        int                 nMinBitRateOptions;                         // min video stream(kbps)
        BYTE                bH264ProfileRank[DH_PROFILE_HIGH];          // supported??H.264 Profile level,refer to enumeration type EM_H264_PROFILE_RANK;
        int                 nH264ProfileRankNum;                        // supported H.264 Profile level
        int                 nCifPFrameMaxSize;                          // when resolution is  cif, max p frame(Kbps)
        int                 nCifPFrameMinSize;                          // when currentresolution is cif, min p frame(Kbps)
        int                 nFPSMax;                                    // video max frame rate??as 0 ??make nResolutionFPSMax as standard
        DH_RESOLUTION_INFO  stuIndivResolutionTypes[DH_MAX_COMPRESSION_TYPES_NUM][DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution
        BOOL				abIndivResolution;							// 0: stuResolutionTypes,nResolutionTypeNum is valid
        // 1: stuIndivResolutionTypes, nIndivResolutionNums is valid
        int                 nIndivResolutionNums[DH_MAX_COMPRESSION_TYPES_NUM];// ????¡À¨¤????????¡À??¡ì??????????¡À???????
    }NET_STREAM_CFG_CAPS;
    
    // get device encode config corresponding capacity output parameter
    typedef struct tagNET_OUT_ENCODE_CFG_CAPS
    {
        DWORD               dwSize;
        NET_STREAM_CFG_CAPS stuMainFormatCaps[DH_REC_TYPE_NUM];         // main stream corresponding capacity
        NET_STREAM_CFG_CAPS stuExtraFormatCaps[DH_N_ENCODE_AUX];        // sub streamconfig corresponding capacity
        NET_STREAM_CFG_CAPS stuSnapFormatCaps[SNAP_TYP_NUM];            // sub stream config corresponding capacity
        int                 nMainFormCaps;                              // Efficienct numbers of the capacity of main stream configuration
        int                 nExtraFormCaps;                             // Efficienct numbers of the capacity of sub stream configuration
        int                 nSnapFormatCaps;                            // Efficienct numbers of the capacity of capture stream configuration
    }NET_OUT_ENCODE_CFG_CAPS;
    
    // Video detect device caps
    typedef struct tagNET_IN_VIDEO_DETECT_CAPS
    {
        DWORD               dwSize;
        int                 nChannel;  //channel, start from 0
    }NET_IN_VIDEO_DETECT_CAPS;
    
    typedef enum tagEM_DETECT_VERSION_TYPE
    {
        EM_DETECT_VERSION_UNKNOW = 0 ,
        EM_DETECT_VERSION_V1_0 ,           //Ver1 motion detection
        EM_DETECT_VERSION_V3_0 ,           //Ver3 motion detection
    }EM_DETECT_VERSION_TYPE;
#define    MAX_DETECT_VERSION_NUM           64
    
    typedef enum tagEM_BLIND_DETECT_VERSION_TYPE
    {
        EM_BLIND_DETECT_VERSION_UNKNOW = 0 ,
        EM_BLIND_DETECT_VERSION_FULL_SCREEN ,   //Full screen detection
        EM_BLIND_DETECT_VERSION_MULTI_WINDOW ,  //Multi window detection
    }EM_BLIND_DETECT_VERSION_TYPE;
#define    MAX_BLIND_DETECT_VERSION_NUM     64
    
    typedef struct tagNET_OUT_VIDEO_DETECT_CAPS
    {
        DWORD                       dwSize;
        BOOL                        bSupportBlind;          //Is support BlindScreen detect, TRUE:yes, FALSE:no
        BOOL                        bSupportLoss;           //Is support VideoLoss detect, TRUE:yes, FALSE:no
        BOOL                        bSupportMotion;         //Is support VideoMotion detect, TRUE:yes, FALSE:no
        BOOL                        bMotionResult;          //Is support to get motion detect result in every region
        DWORD                       nMotionColumns;         //Columns of motion detect detect region
        DWORD                       nMotionRows;            //Rows of motion detect detect region
        DWORD                       nMotionDetectWindow;    //Video windows of motion detect
        DWORD                       nBlindColumns;          //Columns of video blind detect region
        DWORD                       nBlindRows;             //Rows of video blind detect region
        DWORD                       nBlindDetectWindow;     //Video windows of video blind detect
        BOOL                        bPositionDetect;        //Is support motion position detect
        DWORD                       nDetectVersionNum;      //Number of supported motion detect versions
        EM_DETECT_VERSION_TYPE      emDetectVersions[MAX_DETECT_VERSION_NUM];               //Supported motion detect versions info
        DWORD                       nBlindDetectVersionNum; //Number of supported video blind detect versions
        EM_BLIND_DETECT_VERSION_TYPE emBlindDetectVersions[MAX_BLIND_DETECT_VERSION_NUM];   //Supported video blind detect versions info
        BOOL                        bMotionLinkPtzPreset;   //Is support motion detect linked ptz preset, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzTour;     //Is support motion detect linked ptz tour, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzPattern;  //Is support motion detect linked ptz pattern, TRUE:yes, FALSE:no
        BOOL                        bUnFocusDetect;         //Is support unfocus detect, TRUE:yes, FALSE:no
        BOOL                        bAlarmDetect;           //Is support detect and trigger alarm when motion detect is working, TRUE:yes, FALSE:no
    }NET_OUT_VIDEO_DETECT_CAPS;
    
    // fall event type
    typedef struct tagALARM_FALLING_INFO
    {
        DWORD               dwStructSize;                               //  structure size
        BYTE                bEventAction;                               // event action??0 means impulse event,1 means continuous event start,2 means continuous event end;
        BYTE                byRserved[3];                               // align
    }ALARM_FALLING_INFO;
    
    //order Bus status call function model
    typedef void (CALLBACK *fBusStateCallBack)(LLONG lAttachHandle, LONG lCommand, char *pBuf, DWORD dwBufLen, LDWORD dwUser);
    
    // swipe card type
    typedef enum tagNET_DRIVER_CHECK_TYPE
    {
        NET_DRIVER_CHECK_TYPE_UNKNOWN,                                  // unknow
        NET_DRIVER_CHECK_TYPE_SIGNIN,                                   // sign up
        NET_DRIVER_CHECK_TYPE_SIGNOUT,                                  // sign out
    } NET_DRIVER_CHECK_TYPE;
    
    // swipe card
    typedef enum tagNET_DRIVER_CHECK_METHOD
    {
        NET_DRIVER_CHECK_METHOD_UNKNOWN,                                // unknown
        NET_DRIVER_CHECK_METHOD_POS,                                    // POS device
        NET_DRIVER_CHECK_METHOD_HAND,                                   // manually input
    } NET_DRIVER_CHECK_METHOD;
    
    // alarm event type DH_ALARM_BUS_DRIVER_CHECK( driver recognition card detection event)corresponding to data description info
    typedef struct tagALARM_BUS_DRIVER_CHECK_INFO
    {
        DWORD                   dwSize;
        char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // plate
        char                    szDriverName[DH_COMMON_STRING_16];      // driver name
        char                    szDriverID[DH_MAX_PERSON_ID_LEN];       // ID
        char                    szOrganize[DH_COMMON_STRING_128];       // licence issuing organization name
        NET_TIME_EX             stUsefulLife;                           // licence validity
        NET_GPS_STATUS_INFO     stGPSStatusInfo;                        // GPS info
        NET_TIME_EX             stCheckTime;                            // sign up time
        NET_DRIVER_CHECK_METHOD emCheckMethod;                          // sign up method
        NET_DRIVER_CHECK_TYPE   emCheckType;                            // sign up type
    }ALARM_BUS_DRIVER_CHECK_INFO;
    
    // alarm event type DH_ALARM_DEVICE_MSG_NOTIFY(device to platform notice event)corresponding to data description info
    typedef struct tagALARM_DEVICE_MSG_NOTIFY_INFO
    {
        DWORD                   dwSize;
        char                    szMsg[DH_COMMON_STRING_256];            // message content
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    } ALARM_DEVICE_MSG_NOTIFY_INFO;
    
    // alarm event type DH_ALARM_VEHICLE_STANDING_OVER_TIME(parking timeout alarm)corresponding to  data description info
    typedef struct tagALARM_VEHICLE_STANDING_OVER_TIME_INFO
    {
        DWORD                   dwSize;
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
        NET_TIME_EX             stuTime;                                // first occurance time
    } ALARM_VEHICLE_STANDING_OVER_TIME_INFO;
    
    // direction
    typedef enum tagNET_LINE_DIRECTION
    {
        NET_LINE_DIRECTION_UNKNOWN,                                     // unknown
        NET_LINE_DIRECTION_POSTIVE,                                     // firward direction
        NET_LINE_DIRECTION_NEGATIVE,                                    // opposite direction
        NET_LINE_DIRECTION_AROUND,                                      // loop
        NET_LINE_DIRECTION_DISPERSE,                                    // disperse
    } NET_LINE_DIRECTION;
    
    // in/out station status
    typedef enum tagNET_BUS_STATE
    {
        NET_BUS_STATE_UNKNOWN,                                         // unknown
        NET_BUS_STATE_ILLEGAL,                                         // illegal
        NET_BUS_STATE_LEGAL,                                           // legal
    } NET_BUS_STATE;
    
    // stop announcement method
    typedef enum tagNET_PORT_TYPE
    {
        NET_PORT_TYPE_UNKOWN,                                           // unknown
        NET_PORT_TYPE_MANUAL,                                           // manual stop announcement
        NET_PORT_TYPE_GPS,                                              // GPS stopannouncement
    } NET_PORT_TYPE;
    
    // mobile unlock event data type
    typedef enum tagEM_VEHICLE_DATA_TYPE
    {
        EM_VEHICLE_DOOR_OPEN_DATA_UNKNOWN = 0,
        EM_VEHICLE_DOOR_OPEN_DATA_REALTIME,               // real-time data
        EM_VEHICLE_DOOR_OPEN_DATA_HISTORY,                // re-send data
    }EM_VEHICLE_DATA_TYPE;
    
    // alarm event type DH_ALARM_BUS_IMPORT_SITE(in station event)corresponding to data description info
    typedef struct tagALARM_BUS_IMPORT_SITE_INFO
    {
        DWORD                   dwSize;
        char                    szSiteID[DH_COMMON_STRING_64];          // station mark
        DWORD                   dwSiteNum;                              // stop order
        NET_LINE_DIRECTION      emDirection;                            // direction
        char                    szLineID[DH_COMMON_STRING_64];          // maek
        NET_TIME_EX             stuTime;                                // in/out station time
        int                     nTime;                                  // used to confirm event time, UTC, unit is second
        NET_BUS_STATE           emState;                                // if in/out station on time
        NET_PORT_TYPE           emType;                                 // stop announcement method
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
        DWORD                   dwSiteCount;                            // total stop point
        char                    szSiteName[DH_COMMON_STRING_64];        // stop name
        char                    szDesignation[DH_COMMON_STRING_64];     // path no.
        EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type
        BOOL                    bNeedConfirm;                           // confirm or not, via callCLIENT_BusConfirmEventport to confirm
    } ALARM_BUS_IMPORT_SITE_INFO;
    
    //alarm event type DH_ALARM_BUS_EXPORT_SITE(out station event)corresponding to data description info
    typedef struct tagALARM_BUS_EXPORT_SITE_INFO
    {
        DWORD                   dwSize;
        char                    szSiteID[DH_COMMON_STRING_64];          // stop mark
        DWORD                   dwSiteNum;                              // order
        NET_LINE_DIRECTION      emDirection;                            // direction
        char                    szLineID[DH_COMMON_STRING_64];          // mark
        NET_TIME_EX             stuTime;                                // in/out station time
        int                     nTime;                                  // used to confirm  event time, UTC, unit is second
        NET_BUS_STATE           emState;                                // if out station on time
        NET_PORT_TYPE           emType;                                 // stop announcement method
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
        DWORD                   dwSiteCount;                            // total stop point
        char                    szSiteName[DH_COMMON_STRING_64];        // stop name
        char                    szDesignation[DH_COMMON_STRING_64];     // path no.
        EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type
        BOOL                    bNeedConfirm;                           // confirm or not, via call CLIENT_BusConfirmEventport to confirm
    } ALARM_BUS_EXPORT_SITE_INFO;
    
    // abnormal event type
    typedef enum tagEM_ALARM_BUS_ABNORMAL_EVENT_TYPE
    {
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_UNKNOWN,      // unknown
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RUNNING,      // recover operation??"Running"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MEAL,         // eat??"Meal"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BLOCK,        // jam??"Block"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CALL,         // call??"Call"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BREAKDOWN,    // breakdown??"Breakdown"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISCONTINUED, // stop operation??"Discontinued"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ROBING,       // robing??"Robing"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERLOAD,     // overload??"Overload"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISPUTE,      // dispute??"Dispute"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ACCIDENT,     // event??"Accident"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERSPEED,    // over speed??"OverSpeed"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RENTAL,       // rental??"Rental"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MAINTENANCE,  // maintenance??"Maintenance"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CLOSURE,      // closure??"Closure"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_PUBSECURITY,       // "PubSecurity"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ENTER_PARK,        // "EnterPark"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_LEAVE_PARK,        // "LeavePark"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_REFUEL,            // "Refuel"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_FIRE,              // "Fire"
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_HELP,              // "Help"
    }EM_ALARM_BUS_ABNORMAL_EVENT_TYPE;
    
    // alarm event type DH_ALARM_BUS_ABNORMAL(vehicle abnormal event )corresponding to data description info
    typedef struct tagALARM_BUS_ABNORMAL_INFO
    {
        DWORD                   dwSize;
        EM_ALARM_BUS_ABNORMAL_EVENT_TYPE    emEventType;            // abnormal event type
        char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];   // plate
        char                    szLineID[DH_COMMON_STRING_64];      // path mark
        NET_LINE_DIRECTION      emLineDirection;                    // path direction
        NET_TIME_EX             stuTime;                            // occur time
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPSinfo
    } ALARM_BUS_ABNORMAL_INFO;
    
    // alarm event type DH_ALARM_ENCLOSURE_ALARM(e-fence event)corresponding to data description info
    typedef struct tagALARM_ENCLOSURE_ALARM_INFO
    {
        DWORD                   dwSize;
        DWORD                   dwAlarmType;                            // alarm type, by bit means??
        // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
        DWORD                   dwAlarmDetail;                          // alarm description, by bit means,
        // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
        NET_BUS_STATE           emState;                                // if trigger event by schedules time
        DWORD                   dwDriverNo;                             // driver no.
        DWORD                   dwEnclosureID;                          // fence ID
        DWORD                   dwLimitSpeed;                           // speed limit
        DWORD                   dwCurrentSpeed;                         // current speed
        NET_TIME_EX             stuTime;                                // current time
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    } ALARM_ENCLOSURE_ALARM_INFO;
    
    // mobile door status
    typedef NET_ACCESS_CTL_STATUS_TYPE NET_VEHICLE_DOOR_STATUS;
    
    // mobile unlock event , corresponding to event type DH_VEHICLE_DOOR_OPEN
    typedef struct tagALARM_VEHICLE_DOOR_OPEN_INFO
    {
        DWORD                   dwSize;
        NET_VEHICLE_DOOR_STATUS emStatus;           // door status
        int                     nDoor;              // door no., 1:front door,2:middle door,3:rear door
        NET_TIME                stuTime;            // event time, UTC
        int                     nTime;              // used to confirm  event used time, UTC, unit is second
        NET_GPS_STATUS_INFO     stuGPSStatusInfo;   // GPSinfo
        EM_VEHICLE_DATA_TYPE    emDataType;         // event  data  type
        BOOL                    bNeedConfirm;       // confirm or not, via call CLIENT_BusConfirm Eventport to confirm
    }ALARM_VEHICLE_DOOR_OPEN_INFO;
    
    //The current event, the corresponding event type  DH_ALARM_BUS_CUR_MILEAGE
    typedef struct tagALARM_BUS_CUR_MILEAGE_INFO
    {
        DWORD                       dwSize;
        BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
        int                         nTime;                  //Time for confirming the event, UTC, The unit is in seconds
        EM_VEHICLE_DATA_TYPE        emDataType;             // The type of event data
        NET_TIME                    stuTime;                // Event time, UTC
        NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
        NET_TIME                    stuStartTime;           // The beginning of the current period of time, UTC
        NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The informations of the GPS on the beginning of the current period of time
        unsigned int                nMileage;               // Number of miles the current period, unit:0.1km
    }ALARM_BUS_CUR_MILEAGE_INFO;
    
    // The current consumption situation, A corresponding event type DH_ALARM_BUS_CUR_OIL
    typedef struct tagALARM_BUS_CUR_OIL_INFO
    {
        DWORD                       dwSize;
        BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
        int                         nTime;                  // Time for confirmmingevent, UTC, unit:seconds
        EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
        NET_TIME                    stuTime;                // Event time, UTC
        NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
        NET_TIME                    stuStartTime;           // The begining time of the current, UTC
        NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The GPS informations at the beginning time of the current, only longitude and latitude /speed and direction angle valid
        unsigned int                nCurOil;                // Current oil, unit: 0.1L
        unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
        int                         nOilChange;             // The changes oil of current time, unit: 0.1L, Positive means refuel, Negative means oil consumption
    }ALARM_BUS_CUR_OIL_INFO;
    
    // Low oil alarm events, Corresponding event type DH_ALARM_BUS_LOW_OIL
    typedef struct tagALARM_BUS_LOW_OIL_INFO
    {
        DWORD                       dwSize;
        BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
        int                         nTime;                  // Time for confirming the event, UTC, The unit is in seconds
        EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
        NET_TIME                    stuTime;                // Event time, UTC
        NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
        unsigned int                nCurOil;                // Current oil, unit: 0.1L
        unsigned int                nOilLine;               // Oil threshold, unit: 0.1L
        unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
    }ALARM_BUS_LOW_OIL_INFO;
    
    // order Bus status input structure
    typedef struct tagNET_IN_BUS_ATTACH
    {
        DWORD                   dwSize;
        fBusStateCallBack       cbBusState;                             // status call function
        LDWORD                  dwUser;                                 // user data
    }NET_IN_BUS_ATTACH;
    
    // order Bus status output structure
    typedef struct tagNET_OUT_BUS_ATTACH
    {
        DWORD                dwSize;
    }NET_OUT_BUS_ATTACH;
    
    // extention module alarm channel info
    typedef struct tagNET_EXALARMCHANNELS_INFO
    {
        DWORD               dwSize;
        int                 nExAlarmBoxNum;                             // extension alarm box channel no.
        int                 nChannelNum;                                // ths channelno. On alarm box
        char                szChannelName[DH_MAX_EXALARMCHANNEL_NAME_LEN];// alarm channel name
    } NET_EXALARMCHANNELS_INFO;
    
    // CLIENT_QueryDevState port input parameter
    typedef struct tagNET_EXALARMCHANNELS
    {
        DWORD                       dwSize;
        int                         nExAlarmInCount;                    // extension  module alarm input channel quantity??need user search
        int                         nRetExAlarmInCount;                 // extension  module alarm input channel return quantity
        NET_EXALARMCHANNELS_INFO*   pstuExAlarmInInfo;                  // extension  module alarm input channel info
        
        int                         nExAlarmOutCount;                   // extension  module alarm output channel quantity??need user to search
        int                         nRetExAlarmOutCount;                // extension  module alarm output channel return quantity
        NET_EXALARMCHANNELS_INFO*   pstuExAlarmOutInfo;                 // extension  module alarm output channel info
    } NET_EXALARMCHANNELS;
    
    // activate zone info
    typedef struct tagNET_ACTIVATEDDEFENCEAREA_INFO
    {
        DWORD                       dwSize;
        int                         nChannel;                           // zone channel no.
        NET_TIME                    stuActivationTime;                  // zone activation time
    }NET_ACTIVATEDDEFENCEAREA_INFO;
    // CLIENT_QueryDevState port input parameter
    typedef struct tagNET_ACTIVATEDEFENCEAREA
    {
        DWORD                       dwSize;
        int                         nAlarmInCount;                      // search local alarm input channel quantity,  need use to specify
        int                         nRetAlarmInCount;                   // local alarm input channel actual activation quantity
        NET_ACTIVATEDDEFENCEAREA_INFO* pstuAlarmInDefenceAreaInfo;      // local alarm input channel info
        
        int                         nExAlarmInCount;                    // search extension module alarm input quantity. Use specify
        int                         nRetExAlarmInCount;                 // extension  module alarm input channel actual activation quantity
        NET_ACTIVATEDDEFENCEAREA_INFO* pstuExAlarmInDefenceAreaInfo;    // extension  module alarm input channel info
    }NET_ACTIVATEDDEFENCEAREA;
    
    // access control status type
    typedef enum tagEM_NET_DOOR_STATUS_TYPE
    {
        EM_NET_DOOR_STATUS_UNKNOWN,
        EM_NET_DOOR_STATUS_OPEN,                            // door unlock
        EM_NET_DOOR_STATUS_CLOSE,                           // door lock
        EM_NET_DOOR_STATUS_BREAK,                           // door abnormal unlock
    }EM_NET_DOOR_STATUS_TYPE;
    
    // access control status info(CLIENT_QueryDevState port input parameter)
    typedef struct tagNET_DOOR_STATUS_INFO
    {
        DWORD                       dwSize;
        int                         nChannel;               // access control channel no.
        EM_NET_DOOR_STATUS_TYPE     emStateType;            // access control status info
    }NET_DOOR_STATUS_INFO;
    
    // CLIENT_QueryRecordCount port input parameter
    typedef struct _NET_IN_QUEYT_RECORD_COUNT_PARAM
    {
        DWORD                       dwSize;                 //  structure size
        LLONG                       lFindeHandle;           // search handle
    }NET_IN_QUEYT_RECORD_COUNT_PARAM;
    
    // CLIENT_QueryRecordCount port output parameter
    typedef struct _NET_OUT_QUEYT_RECORD_COUNT_PARAM
    {
        DWORD                       dwSize;                 //  structure size
        int                         nRecordCount;           // device return record item
    }NET_OUT_QUEYT_RECORD_COUNT_PARAM;
    
    // analog alarm input channel info
    typedef struct tagNET_ANALOGALARM_CHANNELS_INFO
    {
        DWORD               dwSize;
        int                 nSlot;                          // root address, 0 means local channel, 1 means connection to 1st serial extention channel, 2??3...and so on
        int                 nLevel1;                        // 1st level cascading address, means connection to no.nSlot serial no.nLevel1 detector, from 0
        int                 nLevel2;                        // 2nd level cascading address,means cascading address, means connection to no.nLevel1 node no.nLevel2 detector, from 0, -1 means inexist,
        char                szName[DH_COMMON_STRING_128];   // channel name
    }NET_ANALOGALARM_CHANNELS_INFO;
    
    // analog alarm input channel mapping relation (correspondingDH_DEVSTATE_ANALOGALARM_CHANNELS command)
    typedef struct tagNET_ANALOGALARM_CHANNELS
    {
        DWORD                          dwSize;
        int                            nMaxAnalogAlarmChannels; // max channel
        int                            nRetAnalogAlarmChannels; // return channel
        NET_ANALOGALARM_CHANNELS_INFO* pstuChannelInfo;         // channel info??userallocate memory
    }NET_ANALOGALARM_CHANNELS;
    
    // sensor data info
    typedef struct tagNET_ANALOGALARM_SENSE_INFO
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // channel no.(from 0)
        NET_SENSE_METHOD        emSense;                        // sensor type
        float                   fData;                          // sensor value
        NET_TIME                stuTime;                        // collection time
        int                     nStatus;                        // data status, -1:unknown,0:normal,1data invalid(over measure),
        // 2: over threshold1,3: over threshold 2,4: over threshold 3,5: over threshold 4,
        // 6:below threshold1,7: below threshold 2,8: below threshold 3,9: below threshold 4
        NET_GPS_STATUS_INFO     stuGpsSatus;                    // GPS status
    }NET_ANALOGALARM_SENSE_INFO;
    
    //subscribe analog alarm channel data callback function original
    typedef void (CALLBACK *fAnalogAlarmDataCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser);
    // CLIENT_AttachAnalogAlarmData() port input parameter
    typedef struct tagNET_IN_ANALOGALARM_DATA
    {
        DWORD                       dwSize;
        int                         nChannelId;                 // from 0, -1 means all channels
        fAnalogAlarmDataCallBack    cbCallBack;                 // data callback function
        LDWORD                      dwUser;                     // user custom parameter
    }NET_IN_ANALOGALARM_DATA;
    
    // CLIENT_AttachAnalogAlarmData()port output parameter
    typedef struct tagNET_OUT_ANALOGALARM_DATA
    {
        DWORD    dwSize;
    }NET_OUT_ANALOGALARM_DATA;
    
    // order  record change port definition
#define DH_MAX_RECORD_INSERT_NUM              128
#define DH_MAX_RECORD_DELETE_NUM              128
#define DH_MAX_RECORD_UPDATE_NUM              128
    
    typedef struct tagNET_RECORDUPDATER_INFO
    {
        DWORD           dwSize;
        int             nInsertNum;                   // record info ??inserted  record number
        int             nInsertNumberList[DH_MAX_RECORD_INSERT_NUM];  // means new record  index
        int             nDeleteNum;                   // record info ??deleted record number
        int             nDeleteNumberList[DH_MAX_RECORD_DELETE_NUM];  // means deleted record  index ??-1 means delete all record
        int             nUpdateNum;                   // record info ??updated record number
        int             nUpdateNumberList[DH_MAX_RECORD_UPDATE_NUM];  // means updated record  index
    }NET_RECORDUPDATER_INFO;
    
    //order record change port
    typedef void (CALLBACK *fRecordUpdaterCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_RECORDUPDATER_INFO* pInfo, int nBufLen, LDWORD dwUser);
    
    // CLIENT_AttachRecordUpdater()port input parameter
    typedef struct tagNET_IN_RECORDUPDATER_DATA
    {
        DWORD               dwSize;
        EM_NET_RECORD_TYPE  emType;           // record  set info type
        fRecordUpdaterCallBack   cbRecordUpdater;         // record update call function
        LDWORD              dwUser;           // user defnition parameter
    }NET_IN_RECORDUPDATER_DATA;
    
    // CLIENT_AttachRecordUpdater()port  output parameter
    typedef struct tagNET_OUT_RECORDUPDATER_DATA
    {
        DWORD               dwSize;
    }NET_OUT_RECORDUPDATER_DATA;
    
    
    // search device supported sensor type
    // CLIENT_QueryDevState port DH_DEVSTATE_GET_SENSORLIST  command parameter
#define MAX_SUPPORT_SENSORTYPE_NUM    128                   // max supported sensor device type
    
    typedef struct tagNET_SENSOR_LIST
    {
        DWORD       dwSize;
        int         nSupportSensorNum;                          // return sensor device type
        char        szSensorList[MAX_SUPPORT_SENSORTYPE_NUM][DH_COMMON_STRING_64];
    }NET_SENSOR_LIST;
    
    // CLIENT_QueryDevLogCount get log item input parameter
    typedef struct tagNET_IN_GETCOUNT_LOG_PARAM
    {
        DWORD                       dwSize;
        QUERY_DEVICE_LOG_PARAM      stuQueryCondition;          // search record filter
    } NET_IN_GETCOUNT_LOG_PARAM;
    
    // CLIENT_QueryDevLogCount get log item output parameter
    typedef struct tagNET_OUT_GETCOUNT_LOG_PARAM
    {
        DWORD                       dwSize;
        int                         nLogCount;                  // log quantity(device return)
    } NET_OUT_GETCOUNT_LOG_PARAM;
    
    
    // SDK global log print
    typedef struct tagLogSetPrintInfo
    {
        DWORD           dwSize;
        BOOL            bSetFilePath;                           //reset log path
        char            szLogFilePath[MAX_LOG_PATH_LEN];        // log path(default"./sdk_log/sdk_log.log")
        BOOL            bSetFileSize;                           // reset log size
        unsigned int    nFileSize;                              // each log file size(default size 10240), unit:bit
        BOOL            bSetFileNum;                            // reset log file number
        unsigned int    nFileNum;                               // log file quantity(default size 10)
        BOOL            bSetPrintStrategy;                      // reset log print strategy
        unsigned int    nPrintStrategy;                         // log out strategy, 0: output to file(defualt); 1:output to window
    }LOG_SET_PRINT_INFO;
    
    //////////////////////////////////////////////////////////////////////////
    //       Low Rate Wireless Personal Area Network low speed wireless private network begin
    //////////////////////////////////////////////////////////////////////////
    
    // Wireless Device Type
    typedef enum tagNET_WIRELESS_DEVICE_TYPE
    {
        NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0,
        NET_WIRELESS_DEVICE_TYPE_KEYBOARD,			// Wireless keyboard
        NET_WIRELESS_DEVICE_TYPE_DEFENCE,			// Wireless zone
        NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL,		// Wireless remote control
        NET_WIRELESS_DEVICE_TYPE_MAGNETOMER,		// Wireless door sensor
    } NET_WIRELESS_DEVICE_TYPE;
    
    // Code info
    typedef struct tagNET_CODEID_INFO
    {
        DWORD						dwSize;
        unsigned int				nWirelessId;					// Wireless ID no.
        NET_WIRELESS_DEVICE_TYPE	emType;							// Wireless device type
        char						szName[DH_USER_NAME_LENGTH];	// Username
        BOOL						bEnable;						// Enable this device
    }NET_CODEID_INFO;
    
    // Code error type
    typedef enum tagNET_CODEID_ERROR_TYPE
    {
        NET_CODEID_ERROR_TYPE_RIGHT = 0,			// Code correct
        NET_CODEID_ERROR_TYPE_ALREADYEXIST,			// Exists
        NET_CODEID_ERROR_TYPE_OTHER,				// Other error
    } NET_CODEID_ERROR_TYPE;
    
    // Order wireless code info call function origin??lAttachHandle is CLIENT_AttachLowRateWPAN return valud
    typedef void (CALLBACK *fAttachLowRateWPANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CODEID_INFO* stuBuf, NET_CODEID_ERROR_TYPE emError, LDWORD dwUser);
    
    // CLIENT_AttachLowRateWPAN() input parameter
    typedef struct tagNET_IN_ATTACH_LOWRATEWPAN
    {
        DWORD					dwSize;
        fAttachLowRateWPANCB	cbAttachLowRateWPANCB;         // Code data call
        LDWORD					dwUser;                        // User Data
    }NET_IN_ATTACH_LOWRATEWPAN;
    
    // CLIENT_AttachLowRateWPAN() output parameter
    typedef struct tagNET_OUT_ATTACH_LOWRATEWPAN
    {
        DWORD		        dwSize;
    }NET_OUT_ATTACH_LOWRATEWPAN;
    
    // Delete specific wireless device
    // CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVE command parameter
    typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVE
    {
        DWORD					dwSize;
        unsigned int			nWirelessId;				// Wireless device ID
    }NET_CTRL_LOWRATEWPAN_REMOVE;
    
    // Delete all wireless device
    // CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVEALL command parameter
    typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVEALL
    {
        DWORD					dwSize;
    }NET_CTRL_LOWRATEWPAN_REMOVEALL;
    
    // Modify wireless device info
    // CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_MODIFY command parameter
    typedef struct tagNET_CTRL_LOWRATEWPAN_MODIFY
    {
        DWORD					dwSize;
        NET_CODEID_INFO			stuCodeIDInfo;			// According to CodeIDInfo CodeID??modify its UserandEnable indo??cannot modify others
    }NET_CTRL_LOWRATEWPAN_MODIFY;
    
    // Get code successful total items
    typedef struct tagNET_GET_CODEID_COUNT
    {
        DWORD				dwSize;
        int					nCodeIDCount;		// Code successful total items
    }NET_GET_CODEID_COUNT;
    
    // Get code info
    typedef struct tagNET_GET_CODEID_LIST
    {
        DWORD				dwSize;
        int					nStartIndex;			// Start index symbol, start first search may set to 0
        int					nQueryNum;				// The gotten code items, this value issmaller than or equal to capacity set nMaxPageSize field valud
        int					nRetCodeIDNum;			// Actual returned code items
        NET_CODEID_INFO*	pstuCodeIDInfo;			// Get code content, memory is allocated by user, cannot be lower than nQueryNum*sizeof(NET_CODEID_INFO)
    }NET_GET_CODEID_LIST;
    
    //////////////////////////////////////////////////////////////////////////
    //       Low Rate Wireless Personal Area Network end
    //////////////////////////////////////////////////////////////////////////
    
    // Analog channel data search(corresponding  DH_DEVSTATE_ANALOGALARM_DATA command)
    typedef struct tagNET_GET_ANALOGALARM_DATA 
    {
        DWORD                       dwSize;
        int                         nChannelID;     // Analog channel no. to search(start from 0)
        NET_ANALOGALARM_SENSE_INFO  stuInfo;        // Get analog channel data
    }NET_GET_ANALOGALARM_DATA;
    
    // Monitor control and data collection device type
    typedef enum tagEM_NET_SCADA_DEV_TYPE
    {
        EM_NET_SCADA_DEV_TYPE_UNKNOWN = 0,                         // Unknown
        EM_NET_SCADA_DEV_TYPE_ALL,                                 // All-type device
        EM_NET_SCADA_DEV_TYPE_UPS,                                 // UPS
    } EM_NET_SCADA_DEV_TYPE;
    
    // Monitor control and data collection device spot path info input parameter, search criteria
    typedef struct tagNET_IN_SCADA_POINT_LIST_INFO 
    {
        DWORD                           dwSize;
        char                            szDevType[DH_COMMON_STRING_64]; // Device type
    }NET_IN_SCADA_POINT_LIST_INFO;
    
#define MAX_SCADA_POINT_LIST_INDEX          8               // Max SCADADev config subscript number , as max channel
    
    // Spot chart path info
    typedef struct tagNET_SCADA_POINT_LIST
    {
        DWORD                           dwSize;
        int               nIndexValidNum;                    // Valid config subscript number 
        int               nIndex[MAX_SCADA_POINT_LIST_INDEX];// SCADADev config config subscript value , start from 0
        char              szPath[DH_COMMON_STRING_256];      // chart complete path
    }NET_SCADA_POINT_LIST;
    
#define MAX_SCADA_POINT_LIST_INFO_NUM       256               // max spot path number 
#define MAX_SCADA_POINT_LIST_ALARM_INFO_NUM 256				  // max spot chart alarm number
    
    // Monitor control and data collection device spot chart path info output parameter, search result
    typedef struct tagNET_OUT_SCADA_POINT_LIST_INFO 
    {
        DWORD                           dwSize;
        int                             nList;                  // Valid spot chart path info number 
        NET_SCADA_POINT_LIST            stuList[MAX_SCADA_POINT_LIST_INFO_NUM];// spot chart path info
    }NET_OUT_SCADA_POINT_LIST_INFO;
    
    // Monitor control and data collection device spot chart path info, (corresponding to DH_DEVSTATE_SCADA_POINT_LIST command )
    typedef struct tagNET_SCADA_POINT_LIST_INFO 
    {
        DWORD                           dwSize;
        NET_IN_SCADA_POINT_LIST_INFO    stuIn;                  // search criteria 
        NET_OUT_SCADA_POINT_LIST_INFO   stuOut;                 // search result 
    }NET_SCADA_POINT_LIST_INFO;
    
    // Spot type
    typedef enum tagEM_NET_SCADA_POINT_TYPE
    {
        EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0,                       // unknown
        EM_NET_SCADA_POINT_TYPE_ALL,                               // all type
        EM_NET_SCADA_POINT_TYPE_YC,                                // analog input
        EM_NET_SCADA_POINT_TYPE_YX,                                // switch input
        EM_NET_SCADA_POINT_TYPE_YT,                                // analog output
        EM_NET_SCADA_POINT_TYPE_YK,                                // switch ouput
    } EM_NET_SCADA_POINT_TYPE;
    
    // SCADA monitor spot search criteria 
    typedef struct tagNET_IN_SCADA_INFO 
    {
        DWORD                   dwSize;
        EM_NET_SCADA_POINT_TYPE emPointType;                    // spot type to search
    }NET_IN_SCADA_INFO;
    
#define MAX_SCADA_YX_NUM                128                 // max yx type spot number
#define MAX_SCADA_YC_NUM                128                 // max yc type spot number
#define MAX_SCADA_POINT_INFO_NUM        8                   // max spot chart number
    
    // Spot chart info 
    typedef struct tagNET_SCADA_POINT_INFO 
    {
        DWORD                   dwSize;
        char                    szDevName[DH_COMMON_STRING_64]; // device name
        int                     nYX;                            // valid count of YX type spot in anYX
        unsigned int            anYX[MAX_SCADA_YX_NUM];         // value of YX type spots
        int                     nYC;                            // valid count of YC type spot in afYC
        float                   afYC[MAX_SCADA_YC_NUM];         // value of YC type spots
    }NET_SCADA_POINT_INFO;
    
    // SCADA monitor spot search result 
    typedef struct tagNET_OUT_SCADA_INFO 
    {
        DWORD                   dwSize;
        int                     nPointInfoNum;                  // valid spot chart number 
        NET_SCADA_POINT_INFO    stuPointInfo[MAX_SCADA_POINT_INFO_NUM];// spot chart info
    }NET_OUT_SCADA_INFO;
    
    // Monitor control and data collection device spot chart path monitor spot info (corresponding to DH_DEVSTATE_SCADA_INFO command )
    typedef struct tagNET_SCADA_INFO
    {
        DWORD                   dwSize;
        NET_IN_SCADA_INFO       stuIn;                          // search criteria
        NET_OUT_SCADA_INFO      stuOut;                         // search result
    }NET_SCADA_INFO;
    
    // SCADA capacity type
    typedef enum tagEM_NET_SCADA_CAPS_TYPE
    {
        EM_NET_SCADA_CAPS_TYPE_UNKNOWN,
        EM_NET_SCADA_CAPS_TYPE_ALL,                                // all type
        EM_NET_SCADA_CAPS_TYPE_DEV,                                // DevInfo
    } EM_NET_SCADA_CAPS_TYPE;
    
    // Monitor control and data collection device spot chart path capacity info search criteria 
    typedef struct tagNET_IN_SCADA_CAPS
    {
        DWORD                   dwSize;
        EM_NET_SCADA_CAPS_TYPE  emType;                         // search type
    } NET_IN_SCADA_CAPS;
    
#define MAX_NET_SCADA_CAPS_TYPE (16)
#define MAX_NET_SCADA_CAPS_NAME (16)
    
    // Monitor control and data collection device spot chart path type capacity info 
    typedef struct tagNET_OUT_SCADA_CAPS_ITEM
    {
        DWORD                   dwSize;
        char                    szDevType[DH_COMMON_STRING_32];    // device type
        int                     nValidName;                         // valid device name number
        char                    szDevName[MAX_NET_SCADA_CAPS_NAME][DH_COMMON_STRING_32];// unique device names
    } NET_OUT_SCADA_CAPS_ITEM;
    
    // Monitor control and data collection device spot chart path capacity info search result 
    typedef struct tagNET_OUT_SCADA_CAPS
    {
        DWORD                   dwSize;
        int                     nValidType;                         // valid device type number 
        NET_OUT_SCADA_CAPS_ITEM stuItems[MAX_NET_SCADA_CAPS_TYPE];  // Max 16 types 
    } NET_OUT_SCADA_CAPS;
    
    // Monitor control and data collection device spot chart path capacity info (corresponding to DH_DEVSTATE_SCADA_CAPS command )
    typedef struct tagNET_SCADA_CAPS
    {
        DWORD                   dwSize;
        NET_IN_SCADA_CAPS       stuIn;                          // search criteria 
        NET_OUT_SCADA_CAPS      stuOut;                         // search result 
    } NET_SCADA_CAPS;
    
    // spot info(queried by device id, sensor id)
    typedef struct tagNET_SCADA_POINT_BY_ID_INFO 
    {
        DWORD                   dwSize;
        EM_NET_SCADA_POINT_TYPE emType;                         // spot type
        char                    szID[DH_COMMON_STRING_64];      // id
        int                     nMeasuredVal;                   // measured value, valid if spot type is YX
        float                   fMeasureVal;                    // measured value, valid if spot type is YC
        int                     nSetupVal;                      // setup value, valid if spot type is YK
        float                   fSetupVal;                      // setup value, valid if spot type is YT
        int                     nStatus;                        // data status, -1:unknown, 0:normal, 1:alarm level1, 2:alarm level2, 3:alarm level3, 4:alarm level4, 5:operation event, 6:invalid data
        NET_TIME                stuTime;                        // collect time
    }NET_SCADA_POINT_BY_ID_INFO;
    
#define MAX_SCADA_ID_OF_SENSOR_NUM  128                     // Max count of spot id
    
    // get spot info by sensor id, spot id(corresponding to DH_DEVSTATE_SCADA_INFO_BY_ID)
    typedef struct tagNET_SCADA_INFO_BY_ID
    {
        DWORD                   dwSize;
        char                    szSensorID[DH_COMMON_STRING_64];// input param, sensor ID
        int                     nIDs;                           // input param, valid count of spot id in szIDs
        char                    szIDs[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_64];// input param, spot IDs
        int                     nMaxCount;                      // input param, count of NET_SCADA_POINT_BY_ID_INFO in pstuInfo
        int                     nRetCount;                      // output param, returned count of NET_SCADA_POINT_BY_ID_INFO from device, may be larger than nMaxCount
        NET_SCADA_POINT_BY_ID_INFO* pstuInfo;                   // input/output param, user allocates the memory
    }NET_SCADA_INFO_BY_ID;
    
    // scada device id info
    typedef struct tagNET_SCADA_DEVICE_ID_INFO 
    {
        char                    szDeviceID[DH_COMMON_STRING_64];// device id
        char                    szDevName[DH_COMMON_STRING_64]; // device name, the same as "szDevName" in CFG_SCADA_DEV_INFO
        BYTE                    reserve[1024];
    }NET_SCADA_DEVICE_ID_INFO;
    
    // query scada device IDs(corresponding to DH_DEVSTATE_SCADA_DEVICE_LIST)
    typedef struct tagNET_SCADA_DEVICE_LIST
    {
        DWORD                       dwSize;
        int                         nMax;                       // count of NET_SCADA_DEVICE_ID_INFO in pstuDeviceIDInfo
        int                         nRet;                       // returned count of NET_SCADA_DEVICE_ID_INFO from device, may be larger than nMax
        NET_SCADA_DEVICE_ID_INFO*   pstuDeviceIDInfo;           // scada device id info??user allocates the memory
    }NET_SCADA_DEVICE_LIST;
    
    // monitor spot info 
    typedef struct tagNET_SCADA_NOTIFY_POINT_INFO
    {
        DWORD                       dwSize; 
        char                        szDevName[DH_COMMON_STRING_64];     // device name ??and getInfo Get name identical
        EM_NET_SCADA_POINT_TYPE     emPointType;                        // spot type 
        char                        szPointName[DH_COMMON_STRING_64];   // spot name??and spot chart take value identical
        float                       fValue;                             // value, valid if spot type is YC
        int                         nValue;                             // value, valid if spot type is YX
        char                        szFSUID[DH_COMMON_STRING_64];       // FSUIID(Field Supervision Unit), device itself
        char                        szID[DH_COMMON_STRING_64];          // spot ID
        char                        szSensorID[DH_COMMON_STRING_64];    // sensor ID
        NET_TIME_EX                 stuCollectTime;                     // collect time
    } NET_SCADA_NOTIFY_POINT_INFO;
    
    // monitor spot info list
    typedef struct tagNET_SCADA_NOTIFY_POINT_INFO_LIST
    {
        DWORD                           dwSize;
        int                             nList;                        // monitor spot info number 
        NET_SCADA_NOTIFY_POINT_INFO     stuList[MAX_SCADA_POINT_LIST_INFO_NUM]; // monitor spot info
    } NET_SCADA_NOTIFY_POINT_INFO_LIST;
    
    // order monitor spot info  callback prototype
    typedef void (CALLBACK *fSCADAAttachInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);
    
    // CLIENT_SCADAAttachInfo()'s input param
    typedef struct tagNET_IN_SCADA_ATTACH_INFO
    {
        DWORD                           dwSize;
        fSCADAAttachInfoCallBack        cbCallBack;                 // callback
        EM_NET_SCADA_POINT_TYPE         emPointType;                // spot type
        LDWORD                          dwUser;                     // user's param
    } NET_IN_SCADA_ATTACH_INFO;
    
    // CLIENT_SCADAAttachInfo()'s output param
    typedef struct tagNET_OUT_SCADA_ATTACH_INFO
    {
        DWORD    dwSize;
    } NET_OUT_SCADA_ATTACH_INFO;
    
    //////////////////////////////////////////////////////////////////////////
#define MAX_SCADA_ID_NUM                            1024    // max number of spot id
    
    // spot threshold info
    typedef struct tagNET_SCADA_ID_THRESHOLD_INFO 
    {
        DWORD                   dwSize;
        EM_NET_SCADA_POINT_TYPE emPointType;                // spot type
        char                    szID[DH_COMMON_STRING_32];  // spot ID
        float                   fThreshold;                 // threshold to trigger alarm
        float                   fAbsoluteValue;             // absolute value of threshold
        float                   fRelativeValue;             // relative value of threshold
        int                     nStatus;                    // data state, -1:unknown, 0:normal, 1:alarm level 1, 2:alarm level 2, 3:alarm level 3, 4:alarm level 4, 5:operation event, 6:invalid data
    }NET_SCADA_ID_THRESHOLD_INFO;
    
    // CLIENT_SCADAGetThreshold's input param
    typedef struct tagNET_IN_SCADA_GET_THRESHOLD 
    {
        DWORD           dwSize;
        char            szDeviceID[DH_COMMON_STRING_64];                // device id
        int             nIDs;                                           // valid spot count
        char            szIDs[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];   // spot IDs to query
    }NET_IN_SCADA_GET_THRESHOLD;
    
    // CLIENT_SCADAGetThreshold's output param
    typedef struct tagNET_OUT_SCADA_GET_THRESHOLD 
    {
        DWORD                           dwSize;
        int                             nMax;               // number user malloced, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
        int                             nRet;               // return number, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
        NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spot threshold info, user malloc the memory
    }NET_OUT_SCADA_GET_THRESHOLD;
    
    //////////////////////////////////////////////////////////////////////////
    // CLIENT_SCADASetThreshold's input param
    typedef struct tagNET_IN_SCADA_SET_THRESHOLD 
    {
        DWORD                           dwSize;
        char                            szDeviceID[DH_COMMON_STRING_64];// device id
        int                             nMax;               // count of user malloced, unit: sizeof(NET_SCADA_ID_THRESHOLD_INFO)
        NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spots threshold info, user malloc the memory
    }NET_IN_SCADA_SET_THRESHOLD;
    
    // CLIENT_SCADASetThreshold's output param
    typedef struct tagNET_OUT_SCADA_SET_THRESHOLD 
    {
        DWORD           dwSize;
        int             nSuccess;                                           // valid count of successfully set id
        char            szSuccessID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32]; // IDs that set successfully
        int             nFail;                                              // valid count of failed set id
        char            szFailID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];    // IDs that set failed
    }NET_OUT_SCADA_SET_THRESHOLD;
    
    //////////////////////////////////////////////////////////////////////////
    // CLIENT_StartFindSCADA's input param
    typedef struct tagNET_IN_SCADA_START_FIND 
    {
        DWORD           dwSize;
        NET_TIME        stuStartTime;                   // start time, must provide
        BOOL            bEndTime;                       // to set the end time, TRUE: must provide stuEndTime, FLASE: do not limit the end time
        NET_TIME        stuEndTime;                     // end time
        char            szDeviceID[DH_COMMON_STRING_64];// DeviceID, must provide
        char            szID[DH_COMMON_STRING_32];      // spot ID, must provide
    }NET_IN_SCADA_START_FIND;
    
    // CLIENT_StartFindSCADA's output param
    typedef struct tagNET_OUT_SCADA_START_FIND 
    {
        DWORD           dwSize;
        DWORD           dwTotalCount;                   // total count matching the finding condition
    }NET_OUT_SCADA_START_FIND;
    
    // CLIENT_DoFindSCADA's input param
    typedef struct tagNET_IN_SCADA_DO_FIND 
    {
        DWORD                       dwSize;
        int                         nStartNo;           // start number
        int                         nCount;             // number to query
    }NET_IN_SCADA_DO_FIND;
    
    // CLIENT_DoFindSCADA's output param
    typedef struct tagNET_OUT_SCADA_DO_FIND 
    {
        DWORD                       dwSize;
        int                         nRetNum;            // return number
        NET_SCADA_POINT_BY_ID_INFO* pstuInfo;           // result, user malloc the memroy
        int	                        nMaxNum;            // number of user malloced, unit: sizeof(NET_SCADA_POINT_BY_ID_INFO)
    }NET_OUT_SCADA_DO_FIND;
    
    // spot alarm event info
    typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO
    {
        DWORD           dwSize;
        char            szDevID[DH_COMMON_STRING_16];               // device ID
        char            szPointID[DH_COMMON_STRING_128];            // spot ID
        BOOL            bAlarmFlag;                                 // alarm flag
        NET_TIME        stuAlarmTime;                               // alarm time
        int	            nAlarmLevel;                                // alarm level?¡§0~6??
        int             nSerialNo;                                  // alarm number
        char            szAlarmDesc[DH_COMMON_STRING_128];          // alarm descriptioin
    } NET_SCADA_NOTIFY_POINT_ALARM_INFO;
    
    // spot alarm event list info
    typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST
    {
        DWORD                               dwSize;
        int	                                nList;                                          // spot alarm event number
        NET_SCADA_NOTIFY_POINT_ALARM_INFO   stuList[MAX_SCADA_POINT_LIST_ALARM_INFO_NUM];   // spot alarm event info
    } NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST;
    
    // spot alarm event info callback prototype
    typedef void (CALLBACK *fSCADAAlarmAttachInfoCallBack)(LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);
    
    // CLIENT_SCADAAlarmAttachInfo()'s input param
    typedef struct tagNET_IN_SCADA_ALARM_ATTACH_INFO
    {
        DWORD                           dwSize;
        fSCADAAlarmAttachInfoCallBack   cbCallBack;                 // callback
        LDWORD                          dwUser;	                    // user's param
    } NET_IN_SCADA_ALARM_ATTACH_INFO;
    
    // CLIENT_SCADAAlarmAttachInfo()'s output param
    typedef struct tagNET_OUT_SCADA_ALARM_ATTACH_INFO
    {
        DWORD                       dwSize;
    } NET_OUT_SCADA_ALARM_ATTACH_INFO;
    
    // spot param and value info to be set
    typedef struct tagNET_SCADA_POINT_SET_INFO
    {
        DWORD                       dwSize;
        EM_NET_SCADA_POINT_TYPE	    emType;                         // spot type, only support YK??YT
        char                        szPointID[DH_COMMON_STRING_64];	// spot ID
        int	                        nSetupVal;                      // value, if emType is YK
        float                       fSetupVal;                      // value, if emType is YT
    } NET_SCADA_POINT_SET_INFO;
    
    // set scada spot param and value,CLIENT_SetSCADAInfo()'s input param
    typedef struct tagNET_IN_SCADA_POINT_SET_INFO_LIST
    {
        DWORD                       dwSize;
        char                        szDevID[DH_COMMON_STRING_32];           // device ID
        int	                        nPointNum;                              // spot number
        NET_SCADA_POINT_SET_INFO    stuList[MAX_SCADA_ID_OF_SENSOR_NUM];    // spot info to set
    } NET_IN_SCADA_POINT_SET_INFO_LIST;
    
    // set scada spot param and value,CLIENT_SetSCADAInfo()'s output param
    typedef struct tagNET_OUT_SCADA_POINT_SET_INFO_LIST
    {
        DWORD                   dwSize;
        int                     nSuccess;                                                       // valid count of spot that set ok
        char                    szSuccessID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];   // spot list that set ok
        int                     nFail;                                                          // valid count of spot that set failed
        char                    szFailID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];      // spot list that set failed
    } NET_OUT_SCADA_POINT_SET_INFO_LIST;
    
    
    // get current sub system enable status(correspondingDH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS?¨¹??)
    typedef struct tagNET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES
    {
        DWORD				dwSize;
        int					nChannelId;			// sub system no.
        BOOL				bActive;			// sub system enable status, , TRUE  means enable,FALSE means disable
    }NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES;
    
    // alarm sub system activation setup parameter(correspondingDH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET command)
    typedef struct tagNET_CTRL_ALARM_SUBSYSTEM_SETACTIVE 
    {
        DWORD				dwSize;
        int					nChannelId;			// sub system no.
        BOOL				bActive;			// sub system enable status ,TRUE means enable, FALSE means disable
    }NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE;
    
    // Forbid open strobe param(corresponding to  DH_CTRL_FORBID_OPEN_STROBE)
    typedef struct tagNET_CTRL_FORBID_OPEN_STROBE
    {
        DWORD               dwSize;             
        int                 nChannelID;        // channel no.    
        int                 nTime;             // forbid open gateway duration??unit:s??as after this operation corresponding to time cannot open device gateway 
    }NET_CTRL_FORBID_OPEN_STROBE;
    
#define MAX_PLATENUMBER_LEN    64           // max palte no length
    // open gateway parameter(corresponding to DH_CTRL_OPEN_STROBE command)
    typedef struct tagNET_CTRL_OPEN_STROBE
    {
        DWORD				dwSize;
        int				nChannelId;			                // channel no.
        char				szPlateNumber[MAX_PLATENUMBER_LEN];		// plate no.
    }NET_CTRL_OPEN_STROBE;
    
    // close gateway parameter(corresponding to DH_CTRL_CLOSE_STROBE command)
    typedef struct tagNET_CTRL_CLOSE_STROBE
    {
        DWORD               dwSize;
        int                 nChannelId;                         // channel no.
    }NET_CTRL_CLOSE_STROBE;
    
    // playback refuse listening parameter(corresponding to DH_CTRL_TALKING_REFUSE command)
    typedef struct tagNET_CTRL_TALKING_REFUSE 
    {
        DWORD           dwSize;
        int             nChannelID;                 // talk channel no.
    }NET_CTRL_TALKING_REFUSE;
    
    // parking reservation status
    typedef enum tagEM_NET_ORDER_STATE
    {
        EM_NET_ORDER_STATE_UNKNOWN,
        EM_NET_ORDER_STATE_FREE,                            // Free
        EM_NET_ORDER_STATE_ORDERED,                         // Ordered
    }EM_NET_ORDER_STATE;
    
    // parking reservation status info
    typedef struct tagNET_ORDER_STATE_INFO
    {
        DWORD               dwSize;
        unsigned int        nLane;                          // parking no.
        EM_NET_ORDER_STATE  emOrderState;                   // reservation status
    }NET_ORDER_STATE_INFO;
    
    // set parking reservation status parameter(corresponding to DH_CTRL_SET_ORDER_STATE command)
    typedef struct tagNET_CTRL_SET_ORDER_STATE
    {
        DWORD                   dwSize;
        NET_ORDER_STATE_INFO*   pOrderStateInfo;              // parking reservation infouser allocation space
        unsigned int            nStateCount;                  // valid reservation number
    }NET_CTRL_SET_ORDER_STATE;
    
    // Parking lot entrance/exit controller LED roll screen subtitle speed
    typedef enum tagNET_ECK_LED_SPEED_TYPE 
    {
        NET_ECK_LED_SPEED_UNKNOWN = 0,
        NET_ECK_LED_SPEED_LOW,                              // Slow
        NET_ECK_LED_SPEED_NORMAL,                           // Normal
        NET_ECK_LED_SPEED_HIGH,                             // Fast
    }NET_ECK_LED_SPEED_TYPE;
    
    // Parking lot entrance/exit controller LED setup parameter DH_CTRL_ECK_LED_SET
    typedef struct tagNET_CTRL_ECK_LED_SET_PARAM 
    {
        DWORD                   dwSize;
        NET_ECK_LED_SPEED_TYPE  emLEDSpeed;                 // Subtitle rolling speed
        int                     nCount;                     // Valid display times, range 0-255, 0 means permanent
        char                    szCustomData[DH_COMMON_STRING_512];// LED rolling screen initial characters, 0-256 bytes
    }NET_CTRL_ECK_LED_SET_PARAM;
    
    
    // Intelligent parking system entrance/exit device IC card user type
    typedef enum tagNET_ECK_IC_CARD_USER_TYPE
    {
        NET_ECK_IC_CARD_USER_UNKNOWN,
        NET_ECK_IC_CARD_USER_ALL,                           // all type
        NET_ECK_IC_CARD_USER_TEMP,                          // Temporary user
        NET_ECK_IC_CARD_USER_LONG,                          // Long-term user
        NET_ECK_IC_CARD_USER_ADMIN,                         // admin
        NET_ECK_IC_CARD_USER_BLACK_LIST,                    // black list
    }NET_ECK_IC_CARD_USER_TYPE;
    
    //Intelligent parking lot system entrance/exit device abnormal pass car record type
    typedef enum tagNET_ECK_CAR_PASS_FLAG
    {
        NET_ECK_CAR_PASS_FLAG_NORMAL = 0,                   // Normal
        NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1,                 // Abnormal
        NET_ECK_CAR_PASS_FLAG_ALL,                          // All
    } NET_ECK_CAR_PASS_FLAG;
    
    // Intelligent parking system entrance/exit device IC card info
    typedef struct tagNET_ECK_IC_CARD 
    {
        DWORD                   dwSize;
        DWORD                   dwCard;                     // card no.
        NET_ECK_IC_CARD_USER_TYPE emUserType;               // User type
    }NET_ECK_IC_CARD;
    
#define NET_MAX_ECK_IC_CARD_IMPORT_NUM      50          // Intelligent parking system entrance/exit device max inport IC card quantity
    
    // Intelligent parking system entrance/exit deviceIC card info import parameter DH_CTRL_ECK_IC_CARD_IMPORT
    typedef struct tagNET_CTRL_ECK_IC_CARD_IMPORT_PARAM
    {
        DWORD               dwSize;
        int                 nCardNum;                       // IC card quantity
        NET_ECK_IC_CARD     stuCardInfo[NET_MAX_ECK_IC_CARD_IMPORT_NUM];// IC card info
    }NET_CTRL_ECK_IC_CARD_IMPORT_PARAM;
    
    // Intelligent parking system entrance/exit deviceIC card info sync info parameter DH_CTRL_ECK_SYNC_IC_CARD
    typedef struct tagNET_CTRL_ECK_SYNC_IC_CARD_PARAM
    {
        DWORD               dwSize;
        int                 nCount;                         // Client IC card info quantity
    }NET_CTRL_ECK_SYNC_IC_CARD_PARAM;
    
#define ECK_SCREEN_NUM_MAX (8)                         // The largest number of screens entrance and exits intelligent parking system 
    // Set parking informations on the entrance and exits on the intelligent parking system DH_CTRL_ECK_SET_PARK_INFO
    typedef struct tagNET_CTRL_ECK_SET_PARK_INFO_PARAM
    {
        DWORD           dwSize;
        int             nScreenNum;                             // Screen numbers, not exceeding  ECK_SCREEN_NUM_MAX
        int             nScreenIndex[ECK_SCREEN_NUM_MAX];       // Screen series , every element means the screen series
        int             nFreeParkNum[ECK_SCREEN_NUM_MAX];       // Corresponding to the free parking number under the screen adminstration
        // The length and the subscript accordance with nScreenIndex??every element means the free parking }NET_CTRL_ECK_SET_PARK_INFO_PARAM;
    }NET_CTRL_ECK_SET_PARK_INFO_PARAM;
    
    // fingerprint collection (corresponding to DH_CTRL_CAPTURE_FINGER_PRINT command )
    typedef struct tagNET_CTRL_CAPTURE_FINGER_PRINT 
    {
        DWORD      dwSize;
        int        nChannelID;                      // access control no.(start from 0)
        char       szReaderID[DH_COMMON_STRING_32]; // card reader ID
    }NET_CTRL_CAPTURE_FINGER_PRINT;
    
    // Hang up video phone(Corresponding DH_CTRL_VTP_DISCONNECT)
    typedef struct tagNET_CTRL_VTP_DISCONNECT 
    {
        DWORD                   dwSize;
        const char*             szTargetID;                     // The device ID to be forward , NULL means don??t forward
        EM_NET_VTP_CALL_TYPE    emCallType;                     // Call type
        char                    szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier}NET_CTRL_VTP_DISCONNECT;
    }NET_CTRL_VTP_DISCONNECT;
    
    // client(video talk phone) ack type
    typedef enum tagNET_EM_VTP_ACK
    {
        NET_EM_VTP_OK,                              // client calls right after get the event
        NET_EM_VTP_BUSY,                            // client busy, do not call
    }NET_EM_VTP_ACK;
    
    // client(video talk phone) divert ack
    typedef struct tagNET_CTRL_VTP_DIVERTACK
    {
        DWORD                   dwSize;
        EM_NET_VTP_CALL_TYPE    emCallType;                     // Calling type to query
        const char*             szCallID;                       // Unique ID for calling
        NET_EM_VTP_ACK          emAck;                          // Client's ack
    }NET_CTRL_VTP_DIVERTACK;
    
    // The operation model of remote multimedia files
    typedef enum tagNET_EM_SPEAK_FILE_ACTION
    {
        NET_EM_SPEAK_FILE_ACTION_UPDATE = 0,                    // Update the original file
        NET_EM_SPEAK_FILE_ACTION_ADD,                           // Added files
        NET_EM_SPEAK_FILE_ACTION_DEL,                           //Delete files
    }NET_EM_SPEAK_FILE_ACTION;
    
    // The operation informations of the remote multimedia files 
    typedef struct tagNET_SPEAK_FILE_INFO
    {
        DWORD                       dwSize;
        char                        szFilePath[MAX_PATH];       // File path, use the address setted up by CFG_CMD_NASEX firstly    NET_EM_SPEAK_FILE_ACTION    emAction;                   // Operation type, operation for the files appointed by szFilePath 
        NET_EM_SPEAK_FILE_ACTION    emAction;                   // ??¡Á¡Â?¨¤??, ????szFilePath???¡§??????????¡Á¡Â
        BOOL                        bSave;                      // Whether update or save the files in local device 
    }NET_SPEAK_FILE_INFO;
    
#define MAX_SPEAK_FILE_NUM      32                          // The max number of the files for remote
    
    // Update the files for remote
    typedef struct tagNET_CTRL_UPDATE_FILES
    {
        DWORD                   dwSize;
        DWORD                   dwFileNum;                      // The valid file number
        NET_SPEAK_FILE_INFO     stuFileInfo[MAX_SPEAK_FILE_NUM];// The multimedia file information
    }NET_CTRL_UPDATE_FILES;
    
    
    // (corresponding to DH_CTRL_RAINBRUSH_MOVEONCE)
    typedef struct tagNET_CTRL_RAINBRUSH_MOVEONCE
    {
        DWORD           dwSize;
        int             nChannel;       // Rain-brush channel
    }NET_CTRL_RAINBRUSH_MOVEONCE;
    
    // (corresponding to DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    typedef struct tagNET_CTRL_RAINBRUSH_MOVECONTINUOUSLY
    {
        DWORD           dwSize;
        int             nChannel;       // Rain-brush channel
        unsigned int    nInterval;      // Interval
    }NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY;
    
    // (corresponding to DH_CTRL_RAINBRUSH_STOPMOVE)
    typedef struct tagNET_CTRL_RAINBRUSH_STOPMOVE
    {
        DWORD           dwSize;
        int             nChannel;       // Rain-brush channel
    }NET_CTRL_RAINBRUSH_STOPMOVE;
    
    // (corresponding to DH_CTRL_ALARM_ACK)
    typedef struct tagNET_CTRL_ALARM_ACK
    {
        DWORD                   dwSize;
        int                     nEventID;   // Event ID
    }NET_CTRL_ALARM_ACK;
    ////////////////////////////////system task subscription//////////////////////////////////////////
    // zone status
    typedef struct __NET_PARTITION_STATE
    {
        DWORD             dwSize;
        int               nStatus;                  // zone status??0-normal??1-error 
        double            dbTotalSize;              // zone total capacity??byte is unit
        double            dbRemainSize;             // free capacity??byte is unit
        
    }NET_PARTITION_STATE;
    
    // HDD status
    typedef struct __NET_HDD_STATE
    {
        DWORD             dwSize; 
        int               nState;                   // HDD status??0-normal??1-error   
        double            dbTotalSize;              // HDD total capacity??byte is unit
        NET_PARTITION_STATE stuPartitions[DH_MAX_STORAGE_PARTITION_NUM]; // zone status
        int               nPartitionNum;              // zone quantity
    }NET_HDD_STATE;
    
    // channel status
    typedef struct __NET_CHANNLE_STATE
    {
        DWORD             dwSize;
        BYTE              byRecState;               // record status??1-record??0-close
        BYTE              byVideoInState;           // video input status??1-video in??0-no video  
        BYTE              byReserved[2];            // text align
    }NET_CHANNLE_STATE;
    
    // device self-check info
    typedef struct __NET_SELFCHECK_INFO
    {
        DWORD             dwSize;
        int               nAlarmIn;                 // alarm input channel number
        int               nAlarmOut;                // alarm output channel number  
        NET_TIME          stuTime;                  // report time
        char              szPlateNo[DH_MAX_PLATE_NUMBER_LEN]; // plate
        char              szICCID[DH_MAX_SIM_LEN];  // SIM card no.
        BYTE              byOrientation;            // position status??0-not position??1-position 
        BYTE              byACCState;               // ACC status??0-close??1-open
        BYTE              byConstantElecState;      // power on??0-normal??1-disconnect??2-less pressure, 3-over pressure
        BYTE              byAntennaState;           // channel signal status??0-normal??1-unknown failure??2-disaonnect??3-short circuit
        
        // external device status
        BYTE              byReportStation;          //station announcer status??0-disconnect??1-normal??2-abnormal
        BYTE              byControlScreen;          // dispatch status??0-disconnect??1-normal??2-abnormal
        BYTE              byPOS;                    // POS status??0-disconnect??1-normal??2-abnormal
        BYTE              byCoinBox;                // box status??0-disconnect??1-normal??2-abnormal
        
        // capacity set
        BOOL              bTimerSnap;               // schedule snapshot??TRUE-support??FALSE-not support
        BOOL              bElectronEnclosure;       // e-fence??TRUE-support??FALSE-not support
        BOOL              bTeleUpgrade;             // remote upgrade??TRUE-support??FALSE-not support   
        
        NET_HDD_STATE     stuHddStates[DH_MAX_DISKNUM]; //HDD status
        int               nHddNum;                  // HDD quantity
        
        NET_CHANNLE_STATE* pChannleState;           // channel status??is a group?? memoryis applied by sdk internally??released by sdk intenally
        int               nChannleNum;              // channel quantity
    }NET_SELFCHECK_INFO;
    
    typedef void (CALLBACK *fMissionInfoCallBack)(LLONG lAttachHandle, DWORD dwType, void* pMissionInfo, void* pReserved, LDWORD dwUserData);
    
    typedef enum EM_MISSION_TYPE
    {
        NET_MISSION_TYPE_UNKOWN,                    // unknown
        NET_MISSION_TYPE_SELFCHECK,                 // device self-check??corresponding structure  NET_SELFCHECK_INFO
    }EM_MISSION_TYPE;
    
    //CLIENT_AttachMissionport input parameter
    typedef struct __NET_IN_ATTACH_MISSION_PARAM
    {
        DWORD             dwSize;
        EM_MISSION_TYPE   emMissionType;            // task type
        fMissionInfoCallBack cbMissionInfofunc;     // task info callback function
        LDWORD            dwUser;                   // user data 
    }NET_IN_ATTACH_MISSION_PARAM;
    
    // CLIENT_DetachMissionport output parameter
    typedef struct NET_OUT_ATTACH_MISSION_PARAM
    {
        DWORD             dwSize;
        LLONG             lAttachHandle;           // subscribe handle
    }NET_OUT_ATTACH_MISSION_PARAM;
    
#define MAX_EVENT_TO_CONFIRM_NUM    8    // max to confirm event number 
    
    //to confirm event info 
    typedef struct tagNET_EVENT_INFO_TO_CONFIRM 
    {
        DWORD           dwSize;
        DWORD           dwEventType;        // event type , corresponding to CLIENT_AttachBusStateport event type 
        NET_TIME        stuTime;            // event time, UTC
        LONG            lTime;              // event time, UTC, unit is second
    }NET_EVENT_INFO_TO_CONFIRM;
    
    // vehicle emergency alarm confirm input parameter 
    typedef struct tagNET_IN_BUS_CONFIRM_EVENT 
    {
        DWORD           dwSize;
        int             nEvent;             // to confirm event valid quantity
        NET_EVENT_INFO_TO_CONFIRM  stuEventInfo[MAX_EVENT_TO_CONFIRM_NUM];// to confirm event info 
    }NET_IN_BUS_CONFIRM_EVENT;
    
    // vehicle emergency alarm confirm  output parameter 
    typedef struct tagNET_OUT_BUS_CONFIRM_EVENT 
    {
        DWORD           dwSize;
    }NET_OUT_BUS_CONFIRM_EVENT;
    
    // CLIENT_StartQueryLog input parameter
    typedef struct tagNET_IN_START_QUERYLOG
    {
        DWORD               dwSize;
    } NET_IN_START_QUERYLOG;
    
    // CLIENT_StartQueryLog ouput parameter
    typedef struct tagNET_OUT_START_QUERYLOG
    {
        DWORD               dwSize;
    }NET_OUT_START_QUERYLOG;
    
    // Detail info of log
    typedef struct tagNET_LOG_MESSAGE
    {
        DWORD               dwSize;
        char				szLogMessage[DH_COMMON_STRING_1024];    // detailed info
    } NET_LOG_MESSAGE;
    
    // Info of log
    typedef struct tagNET_LOG_INFO
    {
        DWORD               dwSize;
        NET_TIME            stuTime;                        // time 
        char                szUserName[DH_COMMON_STRING_32];// operator
        char                szLogType[DH_COMMON_STRING_128];// type
        NET_LOG_MESSAGE	    stuLogMsg;                      // detailed info
    } NET_LOG_INFO;
    
    // CLIENT_QueryNextLog input parameter
    typedef struct tagNET_IN_QUERYNEXTLOG
    {
        DWORD               dwSize;
        int                 nGetCount;      // count of log item try to query
    }NET_IN_QUERYNEXTLOG;
    
    // CLIENT_QueryNextLog ouput parameter
    typedef struct tagNET_OUT_QUERYNEXTLOG
    {
        DWORD               dwSize;
        int                 nMaxCount;      // count of log item malloced by user??should be NET_IN_GETNEXTLOG*nGetCount
        NET_LOG_INFO*       pstuLogInfo;    // buffer for log item malloced by user, should be nMaxCount*sizeof(NET_LOG_INFO)
        int                 nRetCount;      // return count of log item
    }NET_OUT_QUERYNEXTLOG;
    
    // Asynchronous callback function registered equipment prototype (when nError back to 11, reserved fields reserved for int type parameters and used to invoke the CLIENT_StartLoginEx landed the port)
    typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);
    
    // CLIENT_StartLoginEx  input parameter
    typedef struct tagNET_IN_STARTLOGINEX 
    {
        DWORD               dwSize;
        const char*         szIp;           // device ip
        DWORD               dwPort;         // login port
        const char*         szName;         // username
        const char*         szPwd;          // password
        fHaveLogin          cbLogin;        // login result call
        LDWORD              dwUser;         // call user parameter
    }NET_IN_STARTLOGINEX;
    
    // CLIENT_StartLoginEx output parameter
    typedef struct tagNET_OUT_STARTLOGINEX 
    {
        DWORD       dwSize;
    }NET_OUT_STARTLOGINEX;
    
    // video splicing operation type
    typedef enum tagNET_VIDEOJOIN_OPERATE_TYPE
    {
        NET_VIDEOJOIN_GET_STATUS,               // get splicing status, corresponding to  NET_IN_VIDEOJOIN_GET_STATUS and NET_OUT_VIDEOJOIN_GET_STATUS
        NET_VIDEOJOIN_GET_CALIBRATE_POINTS,     // get calibrate point , corresponding to  tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS and  tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
        NET_VIDEOJOIN_CALIBRATE,                // mark ,  corresponding to  NET_IN_VIDEOJOIN_CALIBRATE and NET_OUT_VIDEOJOIN_CALIBRATE
    }NET_VIDEOJOIN_OPERATE_TYPE;
    
    // video splicing status
    typedef enum tagNET_VIDEOJOIN_STATUS
    {
        NET_VIDEOJOIN_STATUS_UNKNOWN,               // unknow
        NET_VIDEOJOIN_STATUS_NOTSTART,              // not started
        NET_VIDEOJOIN_STATUS_DOING,                 // running
        NET_VIDEOJOIN_STATUS_FINISH,                // complate
    }NET_VIDEOJOIN_STATUS;
    
    // video splicing mark mode
    typedef enum tagNET_VIDEOJOIN_MODE
    {
        NET_VIDEOJOIN_MODE_UNKNOWN,                 // unknow
        NET_VIDEOJOIN_MODE_AUTO,                    // auto
        NET_VIDEOJOIN_MODE_MANUAL,                  // manual
    }NET_VIDEOJOIN_MODE;
    
    // CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
    typedef struct tagNET_IN_VIDEOJOIN_GET_STATUS
    {
        DWORD           dwSize;
    }NET_IN_VIDEOJOIN_GET_STATUS;
    
    // CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
    typedef struct tagNET_OUT_VIDEOJOIN_GET_STATUS
    {
        DWORD           dwSize;
        NET_VIDEOJOIN_STATUS emStatus;              // splicing status
    }NET_OUT_VIDEOJOIN_GET_STATUS;
    
    // camera mark pair, means one pair of marks
    typedef struct tagNET_POINT_PAIR 
    {
        DH_POINT        stuPoints[POINT_NUM_IN_PAIR];           // camera mark
    }NET_POINT_PAIR;
    
    // video splicing mark group, each group means two channels and multiple mark pairs
    typedef struct tagNET_VIDEOJOIN_POINT_GROUP
    {
        DWORD           dwSize;
        int             nPointPairNum;                          // mark quantity
        NET_POINT_PAIR  stuPointPairs[MAX_POINT_PAIR_NUM];      // mark
        int             nChannels[CHANNEL_NUM_IN_POINT_GROUP];  // video channel no., via data mark to correspond ??mark 0 channel corresponding to NET_POINT_PAIR mark 0 point
    }NET_VIDEOJOIN_POINT_GROUP;
    
    // CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
    typedef struct tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS
    {
        DWORD           dwSize;
    }NET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS;
    
    // CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
    typedef struct tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
    {
        DWORD               dwSize;
        NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
        int                 nPointGroupNum;                         // mark point quantity
        NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, under manual mode is valid
    }NET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS;
    
    // CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_CALIBRATE
    typedef struct tagNET_IN_VIDEOJOIN_CALIBRATE
    {
        DWORD               dwSize;
        NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
        int                 nPointGroupNum;                         // mark point group quantity
        NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, manual mode valid
    }NET_IN_VIDEOJOIN_CALIBRATE;
    
    // CLIENT_OperateVideoJoin output mode, corresponding to NET_VIDEOJOIN_CALIBRATE
    typedef struct tagNET_OUT_VIDEOJOIN_CALIBRATE
    {
        DWORD           dwSize;
    }NET_OUT_VIDEOJOIN_CALIBRATE;
    
    // Get screen window info input parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
    typedef struct tagNET_IN_SPLIT_GET_SCENE 
    {
        DWORD           dwSize;
        int             nChannel;               // output channel no. or cubeless video wall virtual channel no., pszCompositeIDis NULL, it is valid 
        const char*     pszCompositeID;         //  cubeless video wall ID
    }NET_IN_SPLIT_GET_SCENE;
    
    // Get  screen window info  output parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
    typedef struct tagNET_OUT_SPLIT_GET_SCENE 
    {
        DWORD           dwSize;
        DH_SPLIT_SCENE  stuScene;               // window info 
    }NET_OUT_SPLIT_GET_SCENE;
    
    // tv wall tour status 
    typedef enum tagEM_NET_WM_TOUR_STATUS
    {
        EM_NET_WM_TOUR_STATUS_UNKNOWN,          // unknown 
        EM_NET_WM_TOUR_STATUS_START,            // touring
        EM_NET_WM_TOUR_STATUS_STOP,             // tour stop
    } EM_NET_WM_TOUR_STATUS;
    
    // tv wall scheme tour status info 
    typedef struct tagNET_WM_TOUR_STATUS_INFO 
    {
        DWORD          dwSize;
        EM_NET_WM_TOUR_STATUS  emStatus;        // tour status 
        DH_MONITORWALL_SCENE  stuScene;         // scheme info 
    } NET_WM_TOUR_STATUS_INFO;
    
    // tv wall scheme tour status call function origin, lAttachHandle is CLIENT_MonitorWallAttachTour return value 
    typedef void (CALLBACK *fMonitorWallTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WM_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);
    
    // CLIENT_MonitorWallAttachTour port input parameter 
    typedef struct tagNET_IN_WM_ATTACH_TOUR 
    {
        DWORD       dwSize;
        int       	nMonitorWallID;             // tv wall ID
        fMonitorWallTourStatusCallBack cbStatus;// tour status  call function 
        LDWORD     	dwUser;                     // tour status call parameter 
    } NET_IN_WM_ATTACH_TOUR;
    
    // CLIENT_MonitorWallAttachTour port  output parameter 
    typedef struct tagNET_OUT_WM_ATTACH_TOUR 
    {
        DWORD      dwSize;
    } NET_OUT_WM_ATTACH_TOUR;
    
    // CLIENT_SnapManagerConfirmUpload port input parameter
    typedef struct tagNET_IN_SNAP_MANAGER_CONFIRM_UPLOAD
    {
        DWORD           dwSize;
        char            szFilePath[DH_COMMON_STRING_256];       // File path??used for SN of picture
        BOOL            bResult;                                // If picture upload is complete
    }NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD;
    
    // CLIENT_SnapManagerConfirmUpload port output parameter
    typedef struct tagNET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD
    {
        DWORD           dwSize;
    }NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD;
    
    // Video phone status informations
    typedef struct tagNET_VTP_CALL_STATE_INFO 
    {
        DWORD                       dwSize;
        char                        szNumber[DH_COMMON_STRING_128]; // Call number
        char                        szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier
        EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // Call status
    }NET_VTP_CALL_STATE_INFO;
    
    // The callback function prototypes of subscribe to video phone
    typedef void (CALLBACK *fVTPCallStateCallBack)(LLONG lAttachHandle, NET_VTP_CALL_STATE_INFO *pInfo, int nBufLen, LDWORD dwUser);
    
    // Input parameter about the status informations of subscribe to video phone
    typedef struct tagNET_IN_VTP_CALL_STATE_ATTACH 
    {
        DWORD                       dwSize;
        EM_NET_VTP_CALL_TYPE        emCallType;                     // The call type for checking
        fVTPCallStateCallBack       cbCallState;                    // The callback function    LDWORD                      dwUser;                         // User parameter
        LDWORD                      dwUser;                         // user's param
        const char*                 szTargetID;                     // The device ID for forward, NULL means not formard
    }NET_IN_VTP_CALL_STATE_ATTACH;
    
    // The output parameter of the status information of subscribes to video phone
    typedef struct tagNET_OUT_VTP_CALL_STATE_ATTACH 
    {
        DWORD                       dwSize;
    }NET_OUT_VTP_CALL_STATE_ATTACH;
    
    
    //////////////////////////////////////////////////////////////////////////
    // ABILITY INFO
    //////////////////////////////////////////////////////////////////////////
    
    // Check the buses?? routeCLIENT_CheckBusLine()input parameter
    typedef struct tagNET_IN_CHECK_BUS_LINE 
    {
        DWORD           dwSize;
        char            szLineID[DH_COMMON_STRING_32];          // Line marking
        char            szDesignation[DH_COMMON_STRING_32];     // Line serial number
        NET_LINE_DIRECTION  emDirection;                        // Line direction
        int             nSiteCount;                             // The total stations number on the route
        char            szDirectionName[DH_COMMON_STRING_32];   // Name of the line firection
        char            szVersion[DH_COMMON_STRING_32];         // Line version number
    }NET_IN_CHECK_BUS_LINE;
    
    
    // The status type of the bus line whether to update
    typedef enum tagNET_BUS_LINE_UPDATE_TYPE
    {
        NET_BUS_LINE_UPDATE_UNKNOWN = 0,
        NET_BUS_LINE_UPDATE_UPDATED,                            // Need update
        NET_BUS_LINE_UPDATE_NOT_UPDATED,                        // Not update
    }NET_BUS_LINE_UPDATE_TYPE;
    
    // Check the bus routeCLIENT_CheckBusLine()output parameter
    typedef struct tagNET_OUT_CHECK_BUS_LINE
    {
        DWORD           dwSize;
        char            szDeviceID[DH_COMMON_STRING_32];        // device ID
        char            szLineID[DH_COMMON_STRING_32];          // Line marking
        NET_BUS_LINE_UPDATE_TYPE emUpdate;                      // Indicator for whether need to update the status
    }NET_OUT_CHECK_BUS_LINE;
#define MAX_SITE_GPS_POINT_NUM                      64      // Describe the bus stops the largest GPS point
    
    // The shape type of the bus station
    typedef enum tagNET_SITE_AREA_TYPE
    {
        NET_SITE_AREA_ENCLOSURE = 0,                            // Type of the fence
        NET_SITE_AREA_CIRCLE,                                   // Circular
    }NET_SITE_AREA_TYPE;
    
    // Bus station information
    typedef struct tagNET_BUS_SITE_INFO
    {
        DWORD           dwSize;
        char            szLineID[DH_COMMON_STRING_32];          //Line marking
        int             nSiteCount;                             // Total number of the stations
        NET_LINE_DIRECTION  emDirection;                        // Line direction
        int             nStopSequence;                          // Station serial number
        char            szSiteID[DH_COMMON_STRING_32];          // Station ID
        char            szSiteName[DH_COMMON_STRING_32];        // Station name
        NET_SITE_AREA_TYPE emAreaType;                          // Station type
        int             nGPSPointNum;                           // valid GPS points number
        GPS_POINT       stuPoint[MAX_SITE_GPS_POINT_NUM];       // Station GPS information
        int             nRadius;                                // Radius of the station, unit: meter, valid only for the circulai
        int             nSpeedLimit;                            //Station speed limit, unit: km/H
        int             nDriveTime;                             // Time for the last station to current, unit:minute
        int             nTicketPrice;                           // Filp fares
        DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // Time table, The first dimension of each element means ~ on Saturday and Sunday ,holidays
        char            szDesignation[DH_COMMON_STRING_64];     // Line serial number
        char            szDirectionName[DH_COMMON_STRING_64];   // Line direction name
        char            szVersion[DH_COMMON_STRING_32];
    }NET_BUS_SITE_INFO;
    
#define MAX_BUS_STOP_NUM                            32      // The max number of  the stations in a bus line
    
    // Issue bus line CLIENT_DispatchBusLineInfo()Interface input parameters
    typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO 
    {
        DWORD           dwSize;
        int             nBusStopNum;                            // The number of bus line stations
        NET_BUS_SITE_INFO   stuStopInfo[MAX_BUS_STOP_NUM];      // The information of the bus line
    }NET_IN_DISPATCH_BUS_LINE_INFO;
    
    // Issue bus line  CLIENT_DispatchBusLineInfo()Interface output parameters
    typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO 
    {
        DWORD           dwSize;
    }NET_OUT_DISPATCH_BUS_LINE_INFO;
    
    // Vehicle operation dispatching CLIENT_BusSchedule()Interface input parameters
    typedef struct tagNET_IN_BUS_SCHEDULE_INFO 
    {
        DWORD               dwSize;
        char                szLineID[DH_COMMON_STRING_64];      // Operating line identification
        NET_LINE_DIRECTION  emDirection;                        // Operating line direction
        NET_TIME_EX         stuStartTime;                       // Departure time 
        
    }NET_IN_BUS_SCHEDULE_INFO;
    
    // Vehicle operation dispatching CLIENT_BusSchedule()Interface output parameters
    typedef struct tagNET_OUT_BUS_SCHEDULE_INFO 
    {
        DWORD           dwSize;
    }NET_OUT_BUS_SCHEDULE_INFO;
    
    // Vehicle scheduling plan information
    typedef struct tagNET_BUS_WORK_PLAN 
    {
        DWORD               dwSize;
        char                szID[DH_COMMON_STRING_32];          // Scheduling record only, Up to 16 characters
        NET_TIME_EX         stuTime;                            // Departure time 
        char                szDriverName[DH_COMMON_STRING_64];  // The driver name
        char                szStartSite[DH_COMMON_STRING_64];   // Starting station name
        char                szEndSite[DH_COMMON_STRING_64];     // The terminal point name
        BOOL                bRunning;                           // Operation state, TRUE: run, FALSE:stop
    }NET_BUS_WORK_PLAN;
    
    // Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface input parameters
    typedef struct tagNET_IN_BUS_DISPATCH_WORK_PLAN 
    {
        DWORD               dwSize;
        NET_BUS_WORK_PLAN   stuWorkPlan;                        // Vehicle scheduling plan information }NET_IN_BUS_DISPATCH_WORK_PLAN;
    }NET_IN_BUS_DISPATCH_WORK_PLAN;
    
    // Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface output parameters
    typedef struct tagNET_OUT_BUS_DISPATCH_WORK_PLAN 
    {
        DWORD               dwSize;
    }NET_OUT_BUS_DISPATCH_WORK_PLAN;
    
    
    //////////////////////////////////////////////////////////////////////////
    //	Search Type
    typedef enum
    {
        ABILITY_DYNAMIC_CONNECT = 1,        // dynamic connect capacity
        ABILITY_WATERMARK_CFG = 17,			// Watermark configuration capacity
        ABILITY_WIRELESS_CFG = 18,			// wireless  configuration capacity
        ABILITY_DEVALL_INFO = 26,			// Device capacity list 
        ABILITY_CARD_QUERY = 0x0100,		// Card number search capacity 
        ABILITY_MULTIPLAY = 0x0101,			// Multiple-window preview capacity 
        ABILITY_QUICK_QUERY_CFG = 0x0102,	// Fast query configuration Capabilities
        ABILITY_INFRARED = 0x0121,			// Wireless alarm capacity 
        ABILITY_TRIGGER_MODE = 0x0131,		// Alarm activation mode function 
        ABILITY_DISK_SUBAREA = 0x0141,		// Network hard disk partition
        ABILITY_DSP_CFG = 0x0151,			// Query DSP Capabilities
        ABILITY_STREAM_MEDIA = 0x0161,		// Query SIP,RTSP Capabilities
        ABILITY_INTELLI_TRACKER = 0x0171,   // Search intelligent track capability.
    } DH_SYS_ABILITY;
    
    //////////////////////////////////////////////////////////////////////////
    //	The function list device supported 
    enum 
    {
        EN_FTP = 0,						// FTP bitwise, 1: send out record file;  2: Send out snapshot file
        EN_SMTP,						// SMTP bitwise,1: alarm send out text mail 2: Alarm send out image3:support HealthMail
        EN_NTP,							// NTP	 Bitwise:1:Adjust system time 
        EN_AUTO_MAINTAIN,				// Auto maintenance  Bitwise:1:reboot 2:close  3:delete file
        EN_VIDEO_COVER,					// Privacy mask Bitwise  :1:multiple-window privacy mask 
        EN_AUTO_REGISTER,				// Auto registration	Bitwise:1:SDK auto log in after registration 
        EN_DHCP,						// DHCP	Bitwise 1:DHCP
        EN_UPNP,						// UPNP	Bitwise 1:UPNP
        EN_COMM_SNIFFER,				// COM sniffer  Bitwise :1:CommATM
        EN_NET_SNIFFER,					// Network sniffer Bitwise : 1:NetSniffer
        EN_BURN,						// Burn function Bitwise 1:Search burn status 
        EN_VIDEO_MATRIX,				// Video matrix Bitwise  1:Support video matrix or not 2:Support SPOT video matrix or not
        EN_AUDIO_DETECT,				// Video detection Bitwise :1:Support video detection or not 
        EN_STORAGE_STATION,				// Storage position Bitwise:1:Ftp server (Ips) 2:SBM 3:NFS 16:DISK 17:Flash disk 
        EN_IPSSEARCH,					// IPS storage search  Bitwise  1:IPS storage search 	
        EN_SNAP,						// Snapshot Bitwise  1:Resoluiton 2:Frame rate 3:Snapshoot  4:Snapshoot file image; 5:Image quality 
        EN_DEFAULTNIC,					// Search default network card search  Bitwise  1:Support
        EN_SHOWQUALITY,					// Image quality configuration time in CBR mode 1:support 
        EN_CONFIG_IMEXPORT,				// Configuration import& emport function capacity.  Bitwise   1:support 
        EN_LOG,							// Support search log page by page or not. Bitwise 1:support 
        EN_SCHEDULE,					// Record setup capacity. Bitwise  1:Redandunce  2:Pre-record 3:Record period
        EN_NETWORK_TYPE,				// Network type. Bitwise 1:Wire Network 2:Wireless Network 3:CDMA/GPRS,4:CDMA/GPRS multi network card
        EN_MARK_IMPORTANTRECORD,		// Important record. Bitwise 1:Important record mark
        EN_ACFCONTROL,					// Frame rate control activities. Bitwise 1:support frame rate control activities;2:support timing alarm type activate frame rate control(it does not support dynamic detection), this ability mutually exclusive with ACF ability.
        EN_MULTIASSIOPTION,				// Multiple-channel extra stream. Bitwise:1:support three channel extra stream
        EN_DAVINCIMODULE,				// Component modules bitwise: 1.Separate processing the schedule 2.Standard I franme Interval setting
        EN_GPS,                         // GPS function bitwise:1:Gps locate function	
        EN_MULTIETHERNET,				// Support multi net card query   bitwise: 1: support
        EN_LOGIN_ATTRIBUTE,             // Login properties   bitwise: 1: support query login properties  
        EN_RECORD_GENERAL,				// Recording associated  bitwise: 1:Normal recording; 2:Alarm recording; 
        // 3:Motion detection recording;  4:Local storage; 5: Network storage ;  
        // 6:Redundancy storage;  7:Local emergency storage
        EN_JSON_CONFIG,					// Whether support Json configuration, bitwise: 1: support Json
        EN_HIDE_FUNCTION,				// Hide function:bitwise::1,hide PTZ function
        EN_DISK_DAMAGE,                 // Harddisk damage information support ability: bitwise:1,harddisk damage information
        EN_PLAYBACK_SPEED_CTRL,			// Support playback network transmission speed control, bitwise::1 support playback acceleration 
        EN_HOLIDAYSCHEDULE,				// Support holiday period setup : bitwise:1,Support holiday period setup 
        EN_FETCH_MONEY_TIMEOUT,			// ATM fetch money overtime
        EN_BACKUP_VIDEO_FORMAT,			// Device backup support format. DAV, ASF
        EN_QUERY_DISK_TYPE,             // backup disk type query
        EN_CONFIG_DISPLAY_OUTPUT,       // backup device output of display (such as VGA) configuration, by bit: 1: configuration on tour of frame segmentation 
        EN_SUBBITRATE_RECORD_CTRL,      // backup extra stream control configuration, by bit: 1-extra stream control configuration
        EN_IPV6,                        // backup IPV6 configuration, by bit:1-IPV6 configuration
        EN_SNMP,                        // SNMP
        EN_QUERY_URL,                   // back up query device's URL info, by bit: 1-query device's config URL info
        EN_ISCSI,						// ISCSI
        EN_RAID,						// Raid
        EN_HARDDISK_INFO,				// Support disk info query
        EN_PICINPIC,                    // support picture in pictu,by bit:1,set; 2,preview , record , query record , download record
        EN_PLAYBACK_SPEED_CTRL_SUPPORT, // same to EN_PLAYBACK_SPEED_CTRL
        EN_LF_XDEV,						// support LF-X series of 24, 32, 64 channels, label their encode ability with sepcial calculation, by bit 1: able;
        EN_DSP_ENCODE_CAP,				// support F5 DSP encode
        EN_MULTICAST,                   // support different multicast config for different channel
        EM_NET_LIMIT,   				// query the limit ability of net, bitwise,1-limit size of net send code stream  
        EM_COM422, 						// serial port 422
        EM_PROTOCAL_FRAMEWORK,			// support three generations of framework agrement or not(need actualize listMethod(),listService()),by F6 to visit
        EM_WRITE_DISK_OSD,				// write disk OSD overlying ,bitwise, 1-write disk OSD overlying configuration
        EM_DYNAMIC_MULTI_CONNECT,		// dynamic multi-connect,bitise,1-request reply video data
        EM_CLOUDSERVICE,  				// cloud service,bitwise,1- support private cloud service
        EM_RECORD_INFO,					// Video Information Report, by bit. 1-Active video information report, 2-Frame numbers inquiry support
        EN_DYNAMIC_REG,                 // Active Register Support, by bit. 1- Dynamic active register support.
        EM_MULTI_PLAYBACK,              // Multi-channel Preview and Playback, by bit. 1-Multi-channel preview and playback support.
        EN_ENCODE_CHN,					// Encoding Channel, by bit. 1- Audio-only channel support
        EN_SEARCH_RECORD,               // Record search, by bit, 1-support sync search record, 2-support 3rd generation protocol search record
    };
    
    typedef struct 
    {
        DWORD IsFucEnable[512];			// Function list capacity set. Corresponding to the above mentioned enumeration. Use bit to represent sub-function.
    } DH_DEV_ENABLE_INFO;
    
    //////////////////////////////////////////////////////////////////////////
    //Card number search function structure 
    typedef struct 
    {
        char		IsCardQueryEnable;
        char		iRev[3];
    } DH_CARD_QUERY_EN;
    
    //////////////////////////////////////////////////////////////////////////
    //	Wireless capacity structure 
    typedef struct 
    {
        char		IsWirelessEnable;
        char		iRev[3];
    } DH_WIRELESS_EN;
    
    //////////////////////////////////////////////////////////////////////////
    //	Image watermark capacity structure 
    typedef struct 
    {
        char		isSupportWM;		// 1:Support; 0 Do not support
        char		supportWhat;		// 0:Characrer watermark; 1:Image watermark; 2:Support character watermark and image watermark at the same time.
        char		reserved[2];
    } DH_WATERMAKE_EN;
    
    //////////////////////////////////////////////////////////////////////////
    //	Multiple-window preview capacity structure 
    typedef struct  
    {
        int			nEnable;				// 1:Support;  0 :Do not support 
        DWORD		dwMultiPlayMask;		// Multiple-window preview mask 
        char		reserved[4];			// Reserved 
    } DH_MULTIPLAY_EN;
    
    //////////////////////////////////////////////////////////////////////////
    //	Wireless alarm capacity structure 
    typedef struct  
    {
        BOOL		bSupport;				// Support or not 
        int			nAlarmInCount;			// Input amount
        int			nAlarmOutCount;			// Output amount 
        int			nRemoteAddrCount;		// Remote control amount 
        BYTE		reserved[32];
    }DH_WIRELESS_ALARM_INFO;
    
    //////////////////////////////////////////////////////////////////////////
    // Network hard disk partition capacity structure
    typedef struct 
    {
        BOOL		bSupported;				// Support or not
        int			nSupportNum;			// Support the number of disk partition
        BYTE		bReserved[32];
    } DH_DISK_SUBAREA_EN;
    
    // DSP capabilities query ,use when DSP capabilities algorithm with ID 2.
    typedef struct  
    {
        BYTE bMainFrame[32];				//Use the resolution enumeration value (CAPTURE_SIZE) as index, the main code stream corresponds to the max resolution it support, if do not support, the value should be 0.
        BYTE bExtraFrame_1[32];				//Extra code stream1,use the same method as: bMainFrame
        BYTE bReserved[128];				//obligate for extra code stream 2 and 3.		
    }DH_DSP_CFG_ITEM;
    
    typedef struct  
    {
        int nItemNum;						//Valid number of DH_DSP_CFG_ITEM, equals to channel number
        DH_DSP_CFG_ITEM	stuDspCfgItem[32];	//Main code stream Information
        BYTE bReserved[128];				//Retain
    }DH_DSP_CFG; 
    
    //////////////////////////////////////////////////////////////////////////
    //	Fast query configuration capabilities struct 
    typedef struct 
    {
        char		IsQuickQueryEnable;    //1 is device support configuration command go back easily,please set enough configuration time to ensure reading the configuration in narrowband. Recommended for 60S
        char		iRev[3];
    } DH_QUICK_QUERY_CFG_EN;
    
    typedef struct  
    {
        int			nStreamType;			// 0,null 1,SIP 2,RTSP
        BYTE		bReserved[16];			// Reserved
    } DH_STREAM_MEDIA_EN;
    
    //Search intelligent speed dome track capability 
    typedef struct
    {
        char		IsIntelliTrackerEnable;	// Has intelligent speed dome track capability if it is more than 0
        BYTE		bReserved[3];
    }DH_INTELLI_TRACKER_EN;
    
#define NET_MAX_COMPOSITE_CHANNEL       256                 // ¡Á¨¦???????????¡§??¡Á??¨®????
    
    // ????????????????????????, ????NET_COMPOSITE_CAPS
    typedef struct tagNET_IN_COMPOSITE_CAPS 
    {
        DWORD           dwSize;
        int             nChannelCount;                          // ?¨¨?????????¡ã??????
        int             nChannels[NET_MAX_COMPOSITE_CHANNEL];   // ?¨¨?????????¡ã??????¡À¨ª
        int             nLayoutX;                               // ???????¨°?¡ã??????
        int             nLayoutY;                               // ???¡À???¨°?¡ã??????
    } NET_IN_COMPOSITE_CAPS;
    
    // ????????????????????????, ????NET_COMPOSITE_CAPS
    typedef struct tagNET_OUT_COMPOSITE_CAPS 
    {
        DWORD           dwSize;
        int             nSplitModeCount;                        // ?¡ì????????????????
        DH_SPLIT_MODE   emSplitModes[DH_MAX_SPLIT_MODE_NUM];    // ?¡ì??????????????¡À¨ª
        int             nMaxFreeWindow;                         // ¡Á??¨®???¡ã??
    } NET_OUT_COMPOSITE_CAPS;
    
#define MAX_REGISTER_ID_LEN       (256)
#define MAX_APP_ID_LEN            (256)
#define MAX_URL_LEN               (1024)
#define MAX_IOS_CERTIFICATE_LEN   (1024 * 14)
#define MAX_IOS_SECRET_KEY_LEN    (512)
#define MAX_MOBILE_CHANNEL_NUM    (256)
    
    // Mobile server type
    typedef enum tagEM_MOBILE_SERVER_TYPE
    {
        EM_MOBILE_SERVER_TYPE_UNKNOWN,             // Unknown
        EM_MOBILE_SERVER_TYPE_APPLE,               // Apple
        EM_MOBILE_SERVER_TYPE_ANDROID,             // Android
        EM_MOBILE_SERVER_TYPE_SDKCLOUD,            // Private_CLOUD
    } EM_MOBILE_SERVER_TYPE;
    
    // Push server config info
    typedef struct tagNET_PUSH_SERVER_INFO
    {
        char                            szAddress[MAX_URL_LEN];                    // ip address
        int                             nPort;                                     // port
    } NET_PUSH_SERVER_INFO;
    
    // Event sub code type
    typedef enum tagEM_EVENT_SUB_CODE
    {
        EM_EVENT_SUB_CODE_UNKNOWN = -1,            // Unknown
        EM_EVENT_SUB_CODE_LOSS,                    // Loss
        EM_EVENT_SUB_CODE_COVER,                   // Cover
        EM_EVENT_SUB_CODE_FROZEN,                  // Frozen
        EM_EVENT_SUB_CODE_LIGHT,                   // Light
        EM_EVENT_SUB_CODE_DARK,                    // Dark
        EM_EVENT_SUB_CODE_SCENECHANGE,             // SceneChange
    } EM_EVENT_SUB_CODE;
    
    // Subscrbie info
    typedef struct tagNET_SUBSCRIBE_INFO
    {
        int                             nCode;                                     // Event code
        EM_EVENT_SUB_CODE               emSubCode;                                 // ????¡Á??¨¤??, EM_EVENT_SUB_CODE_UNKNOWN?????¡ì
        // ????VideoAbnormalDetection,AlarmLocal??¡ã¨¹???¨¤???¨¤????¡À¡§?????????¡ì
        int                             nChnNum;                                   // ???????¡§??????, ?????¡§???????¨°??0
        int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];           // ?¡§????????
        char                            szNumber[DH_COMMON_STRING_16];             // ????"CallNoAnswered "?????¡À???¡ì
        // ???????????¡§?¨¨¡À??????????????????????¡À?????¨°???¨²??????????
        // CFG_CMD_MOBILE_PUSH_NOFITY_CFG?¡À???¡ì
        char                            szSound[DH_COMMON_STRING_64];              // ???¨²?????????????¡À?????¨¨???????¨´??????
    } NET_SUBSCRIBE_INFO;
    
    // Push gateway type
    typedef enum tagEM_PUSH_GATEWAY_TYPE
    {
        EM_PUSH_GATEWAY_TYPE_UNKNOWN,              // Unknown
        EM_PUSH_GATEWAY_TYPE_APPLE_PUSH,           // ApplePush
        EM_PUSH_GATEWAY_TYPE_ANDROID_SDKPUSH,      // AndroidPrivatePush
        EM_PUSH_GATEWAY_TYPE_ANDROID_JPUSH,        // AndroidJPush
        EM_PUSH_GATEWAY_TYPE_ANDROID_GCM,          // AndroidGCM
    } EM_PUSH_GATEWAY_TYPE;
    
    // Mobile push notification, use RegisterID to subscribe
    typedef struct tagNET_MOBILE_PUSH_NOTIFY
    {
        DWORD                           dwSize;
        char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ???¨²?¨°Appple/ Android?????¡Â¡Á??¨¢????????????????
        EM_MOBILE_SERVER_TYPE           emServerType;                              // ???¡§?¨¤??
        int                             nPeriodOfValidity;                         // ???¡ì?¡À????????????
        char                            szAuthServerAddr[MAX_URL_LEN];             // Android?¨¦?¡è?????¡Â????
        int                             nAuthServerPort;                           // Android?¨¦?¡è?????¡Â????
        char                            szPushServerAddr[MAX_URL_LEN];             // ?????????¡Â????(?¨®???¨²?¨ª???????????¡Â????????)
        // ???¨®???????¡Â¡ã??????????¡Â???¨®??????¡Á????????????¡§??¡Á??????????????¡Â
        int                             nPushServerPort;                           // ?????????¡Â????(?¨®???¨²?¨ª)
        NET_PUSH_SERVER_INFO            stuPushServerMain;                         // ?????????¡Â????, ???????¡Á???????¡Â???????????¡ì¡ã????????????¡§?¨°?¨°?¨²?¨ª?????¡Â
        NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // ?????????¡Â????(?¨®?????¡§?¨°???????????¡Â)
        char                            szDevName[DH_COMMON_STRING_64];            // ?¨¨¡À?¡À????????¨²???¨¨??????
        char                            szDevID[DH_COMMON_STRING_64];              // ?¨¨¡À?¡À¨º???????¨²???¨¨??????
        char                            szUser[DH_COMMON_STRING_64];                  // ???????¡ì??
        char                            szPassword[DH_COMMON_STRING_64];              // ????
        char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios?¡è?¨¦??????base64???¨®??¡Á????????¨¨??????TLS?????¡À???¡ì
        char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios??????base64???¨®¡Á?????
        int                             nSubScribeMax;                             // ¡Á??¨®?????¨¤??????, ¡À¨ª??pstuSubscribes?????¨®????
        int                             nSubScribeNum;                             // ???????????¨¤??????, ???????????¡ì
        NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ?????¨¤??
    } NET_MOBILE_PUSH_NOTIFY;
    
    // Delete mobile push notification, CLIENT_DelMobilePushNotify's input param
    typedef struct tagNET_MOBILE_PUSH_NOTIFY_DEL
    {
        DWORD                           dwSize;
        char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ???¨²?¨°Appple/ Android?????¡Â¡Á??¨¢????????????????
    } NET_MOBILE_PUSH_NOTIFY_DEL;
    
    // Mobile push notification config,  use RegisterID + AppID to subscribe
    typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG
    {
        DWORD                           dwSize;
        char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ???¨²?¨°Appple/ Android?????¡Â¡Á??¨¢????????????????
        char                            szAppID[MAX_APP_ID_LEN];                   // ???¨²???????????¡ì?????¨¢?¨²?¨²????
        EM_MOBILE_SERVER_TYPE           emServerType;                              // ???¡§?¨¤??
        EM_PUSH_GATEWAY_TYPE            emPushGatewayType;                         // ?????????¨¤??, emServerType??EM_MOBILE_SERVER_TYPE_SDKCLOUD?¡À???¡ì
        int                             nPeriodOfValidity;                         // ???¡ì?¡À????????????
        char                            szAuthServerAddr[MAX_URL_LEN];             // Android?¨¦?¡è?????¡Â????
        int                             nAuthServerPort;                           // Android?¨¦?¡è?????¡Â????
        char                            szPushServerAddr[MAX_URL_LEN];             // ?????????¡Â????(?¨®???¨²?¨ª???????????¡Â????????)
        // ???¨®???????¡Â¡ã??????????¡Â???¨®??????¡Á????????????¡§??¡Á??????????????¡Â
        int                             nPushServerPort;                           // ?????????¡Â????(?¨®???¨²?¨ª)
        char                            szDevName[DH_COMMON_STRING_64];            // ?¨¨¡À?¡À????????¨²???¨¨??????
        char                            szDevID[DH_COMMON_STRING_64];              // ?¨¨¡À?¡À¨º???????¨²???¨¨??????
        char                            szUser[DH_COMMON_STRING_64];                  // ???????¡ì??
        char                            szPassword[DH_COMMON_STRING_64];              // ????
        char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios?¡è?¨¦??????base64???¨®??¡Á????????¨¨??????TLS?????¡À???¡ì
        char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios??????base64???¨®¡Á?????
        int                             nSubScribeMax;                             // ¡Á??¨®?????¨¤??????, ¡À¨ª??pstuSubscribes?????¨®????
        int                             nSubScribeNum;                             // ???????????¨¤??????, ???????????¡ì
        NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ?????¨¤??
        NET_PUSH_SERVER_INFO            stuPushServerMain;                         // 
        NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // 
    } NET_MOBILE_PUSH_NOTIFY_CFG;
    
    // Delete mobile push notification config, CLIENT_DelMobilePushNotify's input param
    typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG_DEL
    {
        DWORD                           dwSize;
        char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ???¨²?¨°Appple/ Android?????¡Â¡Á??¨¢????????????????
        char                            szAppID[MAX_APP_ID_LEN];                   // ???¨²???????????¡ì?????¨¢?¨²?¨²????
    } NET_MOBILE_PUSH_NOTIFY_CFG_DEL;
    
    // NetSDK optimize type
    typedef enum tagEmOptimizeType
    {
        EM_OPT_TYPE_DEFAULT     = 0,    // default to do nothing
        EM_OPT_TYPE_MOBILE_V1   = 1,    // optimized for mobile
    }EM_OPTIMIZE_TYPE;
    
    //////////////////////////////////////////////////////////////////////////
    // RPC method name
    //////////////////////////////////////////////////////////////////////////
    
#define RPC_METHOD_MONITORWALL_ADD      "monitorWallManager.addMonitorWall"     // add MonitorWall
    
    /***********************************************************************
     ** Callback Function Definition 
     ***********************************************************************/
    
    // Network disconnection callback function original shape 
    typedef void (CALLBACK *fDisConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
    
    // network re-connection callback function original shape
    typedef void (CALLBACK *fHaveReConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
    
    // The prototype of dynamic sub connection offline call function 
    typedef void (CALLBACK *fSubDisConnect)(EM_INTERFACE_TYPE emInterfaceType, BOOL bOnline, LLONG lOperateHandle, LLONG lLoginID, LDWORD dwUser);
    
    // monitor disconnect callback function
    typedef void (CALLBACK *fRealPlayDisConnect)(LLONG lOperateHandle, EM_REALPLAY_DISCONNECT_EVENT_TYPE dwEventType, void* param, LDWORD dwUser);
    
    // Real-time monitor data callback function original shape
    typedef void (CALLBACK *fRealDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);
    
    // Real-time monitor data callback function original shape---extensive
    typedef void (CALLBACK *fRealDataCallBackEx)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser);
    
    // OSD callback function original shape 
    typedef void (CALLBACK *fDrawCallBack)(LLONG lLoginID, LLONG lPlayHandle, HDC hDC, LDWORD dwUser);
    
    // Playback process by time callback function original shape
    typedef void (CALLBACK *fTimeDownLoadPosCallBack) (LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, int index, NET_RECORDFILE_INFO recordfileinfo, LDWORD dwUser);
    
    // Alarm message callback function original shape
    typedef BOOL (CALLBACK *fMessCallBack)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
    // explanation of new parameter: 
    // bAlarmAckFlag : TRUE,the event is affirmable event;FALSE,the event is not affirmable event
    // nEventID is used by CLIENT_AlarmAck, when bAlarmAckFlag is TRUE, this data is efficient
    typedef BOOL (CALLBACK *fMessCallBackEx1)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, BOOL bAlarmAckFlag, LONG nEventID, LDWORD dwUser);
    
    // Listening server callback function original shape
    typedef int (CALLBACK *fServiceCallBack)(LLONG lHandle, char *pIp, WORD wPort, LONG lCommand, void *pParam, DWORD dwParamLen, LDWORD dwUserData);
    
    // Audio data of audio talk callback function original shape 
    typedef void (CALLBACK *pfAudioDataCallBack)(LLONG lTalkHandle, char *pDataBuf, DWORD dwBufSize, BYTE byAudioFlag, LDWORD dwUser);
    
    // Upgrade device callback function original shape
    typedef void (CALLBACK *fUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser);
    
    // Transparent COM callback function original shape
    typedef void (CALLBACK *fTransComCallBack) (LLONG lLoginID, LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize, LDWORD dwUser);
    
    // Search device log data callback function original shape 
    typedef void (CALLBACK *fLogDataCallBack)(LLONG lLoginID, char *pBuffer, DWORD dwBufSize, DWORD nTotalSize, BOOL bEnd, LDWORD dwUser);
    
    // Snapshot callback function original shape 
    typedef void (CALLBACK *fSnapRev)(LLONG lLoginID, BYTE *pBuf, UINT RevLen, UINT EncodeType, DWORD CmdSerial, LDWORD dwUser);
    
    // GPS message subscription callback 
    typedef void( CALLBACK *fGPSRev)(LLONG lLoginID, GPS_Info GpsInfo, LDWORD dwUserData);
    
    // GPSGPS message subscription callback - extra
    typedef void (CALLBACK *fGPSRevEx)(LLONG lLoginID, GPS_Info GpsInfo, ALARM_STATE_INFO stAlarmInfo, LDWORD dwUserData, void *reserved);
    
    // GPS GPS subscription of temperature and humidity callback
    typedef void (CALLBACK *fGPSTempHumidityRev)(LLONG lLoginID, GPS_TEMP_HUMIDITY_INFO GpsTHInfo, LDWORD dwUserData);
    
    // Asynchronous data callback
    typedef void (CALLBACK *fMessDataCallBack)(LLONG lCommand, LPNET_CALLBACK_DATA lpData, LDWORD dwUser);
    
    // File Transfer callback
    typedef void (CALLBACK *fTransFileCallBack)(LLONG lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, LDWORD dwUser);
    
    // intelligent analysis data callback;nSequence instruct the repeat picture's station,0 instruct the first time it appear, 2 instruct the last time it appear or it only appear once,1 instruct it will appear next time
    // int nState = (int) reserved instruct current callback data's state, 0 means realtime data,1 means offline data,2 means send offline data over
    typedef int  (CALLBACK *fAnalyzerDataCallBack)(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);
    
    // Asynchronism search device call
    typedef void (CALLBACK *fSearchDevicesCB)(DEVICE_NET_INFO_EX *pDevNetInfo, void* pUserData);
    
    // Asynchronism register device call
    // typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);
    
    // playback YUV callback function
    typedef void (CALLBACK *fYUVDataCallBack)(LLONG lPlaybackHandle, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser, void *reserved);

    
    
    
    // device capacity type, corresponding to CLIENT_GetDevCaps port
#define NET_DEV_CAP_SEQPOWER            0x01                // power timing capacity, pInBuf=NET_IN_CAP_SEQPOWER*, pOutBuf=NET_OUT_CAP_SEQPOWER*
#define NET_ENCODE_CFG_CAPS             0x02                // device encode config corresponding to capacity, pInBuf=NET_IN_ENCODE_CFG_CAPS*, pOutBuf= NET_OUT_ENCODE_CFG_CAPS*
#define NET_VIDEOIN_FISHEYE_CAPS        0x03                // Fish eye capacity , pInBuf=NET_IN_VIDEOIN_FISHEYE_CAPS*, pOutBuf=NET_OUT_VIDEOIN_FISHEYE_CAPS*
#define NET_COMPOSITE_CAPS              0x04                // Get composited caps by pointed window number, pInBuf=NET_IN_COMPOSITE_CAPS*, pOutBuf=NET_OUT_COMPOSITE_CAPS*
#define NET_VIDEO_DETECT_CAPS           0x05                // Get video detect device caps,pInBuf=NET_IN_VIDEO_DETECT_CAPS* , pOutBuf=NET_OUT_VIDEO_DETECT_CAPS*

    
    
    // device info type??corresponding to CLIENT_QueryDevInfo port
#define NET_QUERY_DEV_STORAGE_NAMES            0x01                // search device storage module name list , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
#define NET_QUERY_DEV_STORAGE_INFOS            0x02                // search device storage info list, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
#define NET_QUERY_RECENCY_JNNCTION_CAR_INFO    0x03                // search recent ANPR vehicle info port, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
#define NET_QUERY_LANES_STATE                  0x04                // search lane info ,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
#define NET_QUERY_DEV_FISHEYE_WININFO          0x05                // search Fish eye window info , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
#define NET_QUERY_DEV_REMOTE_DEVICE_INFO       0x06                // search remote device info , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
#define NET_QUERY_SYSTEM_INFO                  0x07                // search system info , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*

    
    
    
    
    // split window play operaton type
    typedef enum tagNET_PLAYER_OPERATE_TYPE
    {
        NET_PLAYER_OPERATE_OPEN,                // open playuer
        NET_PLAYER_OPERATE_CLOSE,               // close player
        NET_PLAYER_OPERATE_START,               //  start play
        NET_PLAYER_OPERATE_STOP,                // stop play
        NET_PLAYER_OPERATE_PAUSE,               // pause/restore play
        NET_PLAYER_OPERATE_SEEK_TIME,           // go to specific time play
        NET_PLAYER_OPERATE_STEP_FRAME,          // single frame playback, need to be used after pause
        NET_PLAYER_OPERATE_GET_STATE,           // take current playback status
        NET_PLAYER_OPERATE_GET_TIME,            // Get  current playback time
        NET_PLAYER_OPERATE_GET_SPEED,           // Get play speed
        NET_PLAYER_OPERATE_SET_SPEED,           // Set play speed
        NET_PLAYER_OPERATE_GET_VOLUME,          // Get volume
        NET_PLAYER_OPERATE_SET_VOLUME,          // Set volume
        NET_PLAYER_OPERATE_GET_PLAYLIST,        // Get file list
        NET_PLAYER_OPERATE_GET_PLAYLIST_TS,     // Get current file list all period info
    }NET_PLAYER_OPERATE_TYPE;
    
    // play criteria
    typedef struct tagNET_PLAYER_OPEN_CONDITION
    {
        DWORD               dwSize;
        char                szDevice[DH_DEV_ID_LEN];        // point remote device
        int                 nChannel;                       // channel no.
        NET_TIME            stuStartTime;                   // start time
        NET_TIME            stuEndTime;                     // end time
        NET_STREAM_TYPE     emStreamType;                   // stream type
        int                 nEventNum;                      // Event type number
        int                 nEvent[MAX_IVS_EVENT_NUM];      // Event type
    }NET_PLAYER_OPEN_CONDITION;
    
    //open player input parameter , corresponding to NET_PLAYER_OPERATE_OPEN
    typedef struct tagNET_IN_PLAYER_OPEN
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           // play example ID
        const char*     pszDevice;           // take record from local or remote end, as null represents to take record from local??
        // if from remote device??need to maintain with NET_PLAYER_OPEN_CONDITION szDevice identical
        NET_PLAYER_OPEN_CONDITION stuCondition;       // search criteria
    }NET_IN_PLAYER_OPEN;
    
    // open player  output parameter , corresponding to NET_PLAYER_OPERATE_OPEN
    typedef struct tagNET_OUT_PLAYER_OPEN
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_OPEN;
    
    // close player input parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
    typedef struct tagNET_IN_PLAYER_CLOSE
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           // play example ID
    }NET_IN_PLAYER_CLOSE;
    
    // close player output parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
    typedef struct tagNET_OUT_PLAYER_CLOSE
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_CLOSE;
    
    //  start  play input parameter , corresponding to NET_PLAYER_OPERATE_START
    typedef struct tagNET_IN_PLAYER_START
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_START;
    
    //  start  play  output parameter , corresponding to NET_PLAYER_OPERATE_START
    typedef struct tagNET_OUT_PLAYER_START
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_START;
    
    // stop play input parameter , corresponding to NET_PLAYER_OPERATE_STOP
    typedef struct tagNET_IN_PLAYER_STOP
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_STOP;
    
    // stop play  output parameter , corresponding to NET_PLAYER_OPERATE_STOP
    typedef struct tagNET_OUT_PLAYER_STOP
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_STOP;
    
    //  pause /recover  play input parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
    typedef struct tagNET_IN_PLAYER_PAUSE
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        BOOL        bPause;             // pause or not, TRUE- pause  play , FALSE-recover  play
    }NET_IN_PLAYER_PAUSE;
    
    //  pause /recover  play  output parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
    typedef struct tagNET_OUT_PLAYER_PAUSE
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_PAUSE;
    
    // go to specific time play input parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
    typedef struct tagNET_IN_PLAYER_SEEK_TIME
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        NET_TIME      stuTime;            // go to time
    }NET_IN_PLAYER_SEEK_TIME;
    
    // go to specific time play  output parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
    typedef struct tagNET_OUT_PLAYER_SEEK_TIME
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_SEEK_TIME;
    
    // single frame play input parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
    typedef struct tagNET_IN_PLAYER_STEP_FRAME
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        BOOL        bForward;            //  positive direction, TRUE-positive direction, FALSE-negative direction
    }NET_IN_PLAYER_STEP_FRAME;
    
    // single frame play  output parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
    typedef struct tagNET_OUT_PLAYER_STEP_FRAME
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_STEP_FRAME;
    
    //  play status
    typedef enum tagNET_PLAYER_STATE
    {
        NET_PLAYER_STATE_UNKNOWN,        // unknown
        NET_PLAYER_STATE_ERROR,         // error occur
        NET_PLAYER_STATE_READING,        // ready, may start palyabck
        NET_PLAYER_STATE_STANDBY,        //  current file playback stop, only can start playback from beginningart
        NET_PLAYER_STATE_RUNNING,        // running
        NET_PLAYER_STATE_PAUSED,        //  paused , may continue from pause point
        NET_PLAYER_STATE_CLOSED,        // closed, cannot play, must open and enter Reading status again
    }NET_PLAYER_STATE;
    
    // search  play status input parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
    typedef struct tagNET_IN_PLAYER_GET_STATE
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_GET_STATE;
    
    // search  play status  output parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
    typedef struct tagNET_OUT_PLAYER_GET_STATE
    {
        DWORD        dwSize;
        NET_PLAYER_STATE  emState;            // status
    }NET_OUT_PLAYER_GET_STATE;
    
    // Get  current  playback timeinput parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
    typedef struct tagNET_IN_PLAYER_GET_TIME
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_GET_TIME;
    
    // Get  current  playback time output parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
    typedef struct tagNET_OUT_PLAYER_GET_TIME
    {
        DWORD        dwSize;
        NET_TIME      stuTime;            //  current  play time
    }NET_OUT_PLAYER_GET_TIME;
    
    // Get  play speed input parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
    typedef struct tagNET_IN_PLAYER_GET_SPEED
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_GET_SPEED;
    
    // Get  play speed output parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
    typedef struct tagNET_OUT_PLAYER_GET_SPEED
    {
        DWORD        dwSize;
        float        fSpeed;             //  play speed, >0 positive direction  play , <0 direction  play
        // absolute value means speed, =1 nornal speed, >1 quick, <1 slow
    }NET_OUT_PLAYER_GET_SPEED;
    
    // set play speedinput parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
    typedef struct tagNET_IN_PLAYER_SET_SPEED
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        float        fSpeed;             //  play speed, >0 positive direction  play , <0 direction  play
        // absolute value means speed, =1 normal speed, >1 quick, <1 slow
    }NET_IN_PLAYER_SET_SPEED;
    
    // set play speed output parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
    typedef struct tagNET_OUT_PLAYER_SET_SPPED
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_SET_SPEED;
    
    // Get  play  volume input parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
    typedef struct tagNET_IN_PLAYER_GET_VOLUME
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
    }NET_IN_PLAYER_GET_VOLUME;
    
    // Get  play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
    typedef struct tagNET_OUT_PLAYER_GET_VOLUME
    {
        DWORD        dwSize;
        int         nVolume;            //  play  volume , 0~100
    }NET_OUT_PLAYER_GET_VOLUME;
    
    // set play  volume input parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
    typedef struct tagNET_IN_PLAYER_SET_VOLUME
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        int         nVolume;            //  play  volume , 0~100
    }NET_IN_PLAYER_SET_VOLUME;
    
    // set play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
    typedef struct tagNET_OUT_PLAYER_SET_VOLUME
    {
        DWORD        dwSize;
    }NET_OUT_PLAYER_SET_VOLUME;
    
    //  play listinfo
    typedef struct tagNET_PLAYER_PLAYLIST
    {
        DWORD        dwSize;
        char        szFilePath[MAX_PATH];      // file path, select either Url
        char        szUrl[MAX_PATH];        // URL, and FilePath wither one
        DH_DEVICE_PROTOCOL emUrlProtocol;         // URL protocol type
        NET_TIME      stuStartTime;          // start time
        NET_TIME      stuEndTime;           // end time
    }NET_PLAYER_PLAYLIST;
    
    // Get  current  play listinput parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
    typedef struct tagNET_IN_PLAYER_GET_PLAYLIST
    {
        DWORD        dwSize;
        LLONG        lPlayerID;           //  play example ID
        NET_TIME      stuStartTime;          // start time
        NET_TIME      stuEndTime;           // end time
        int         nLimit;             // search file quantity limit, 0 means no limit
    }NET_IN_PLAYER_GET_PLAYLIST;
    
    // Get  current  play list output parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
    typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST
    {
        DWORD        dwSize;
        NET_PLAYER_PLAYLIST* pstuPlayLists;         //  play list, user allocate memory
        int         nMaxPlayListCount;       // max play list quantity, user fill in
        int         nRetPlayListCount;       // return play list quantity
    }NET_OUT_PLAYER_GET_PLAYLIST;
    
    // Get current file list all time period info input parameter, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
    typedef struct tagNET_IN_PLAYER_GET_PLAYLIST_TS
    {
        DWORD               dwSize;
        LLONG               lPlayerID;                      // Play actual ID
    }NET_IN_PLAYER_GET_PLAYLIST_TS;
    
    typedef struct tagNET_PLAYLIST_TIMESECTION
    {
        DWORD               dwSize;
        int                 nEvent;                         // Record event type,  currently have
        // EVENT_ALARM_COMMON, EVENT_ALARM_VIDEOBLIND, EVENT_ALARM_VIDEOLOSS, 
        // EVENT_ALARM_MOTIONDETECT, EVENT_ALARM_LOCALALARM
        LPDH_TSECT          pstuTSs;                        // Time period info
        DWORD               unMaxTS;                        // Time period max number
        DWORD               unRetTS;                        // Actual returned time period number
    }NET_PLAYLIST_TIMESECTION;
    
    // Get current file list all time period info output parameters, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
    typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST_TS
    {
        DWORD                    dwSize;
        DWORD                    dwEventNum;                // Record type quantity
        NET_PLAYLIST_TIMESECTION stuTS[MAX_IVS_EVENT_NUM];  // Current playback list time period info
    }NET_OUT_PLAYER_GET_PLAYLIST_TS;

    
    
    
    // by file playback input parameter-proxy use
    typedef struct tagNET_IN_PLAYBACK_BYFILE_PROXY
    {
        DWORD                   dwSize;
        LPNET_RECORDFILE_INFO   lpRecordFile;                   // record file info
        HWND                    hWnd;                           // window handle
        fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
        LDWORD                  dwPosUser;                      // progress call user data
        fDataCallBack           fDownLoadDataCallBack;          // playback data call
        LDWORD                  dwDataUser;                     // data call user data
        char                    szDstIP[DH_COMMON_STRING_128];  // device IP
    }NET_IN_PLAYBACK_BYFILE_PROXY;
    
    // by file playback output parameter ¡§Cproxy use
    typedef struct tagNET_OUT_PLAYBACK_BYFILE_PROXY
    {
        DWORD                   dwSize;
    }NET_OUT_PLAYBACK_BYFILE_PROXY;
    
    // by time playback input parameter-proxy use
    typedef struct tagNET_IN_PLAYBACK_BYTIME_PROXY
    {
        DWORD                   dwSize;
        int                     nChannelID;                     // channel no.
        LPNET_TIME              lpStartTime;                    // start time
        LPNET_TIME              lpStopTime;                     // end time
        HWND                    hWnd;                           // window handlw
        fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
        LDWORD                  dwPosUser;                      // progress call user data
        fDataCallBack           fDownLoadDataCallBack;          // playback data call
        LDWORD                  dwDataUser;                     // data call user data
        char                    szDstIP[DH_COMMON_STRING_128];  // device IP
    }NET_IN_PLAYBACK_BYTIME_PROXY;
    
    // by time playback output parameter-proxy use
    typedef struct tagNET_OUT_PLAYBACK_BYTIME_PROXY 
    {
        DWORD                   dwSize;
    }NET_OUT_PLAYBACK_BYTIME_PROXY;
    
    
    //////////////////////////////////////////////////////////////////////////
    
    // add feedback type after task
    typedef enum tagNET_MISSION_FEEDBACK_TYPE
    {
        NET_MISSION_FEEDBACK_NO = 0,                        // no feedback needed
        NET_MISSION_FEEDBACK_YES,                           // need feedback, shall replay DH_ALARM_MISSION_CONFIRM task confirmed event
    }NET_MISSION_FEEDBACK_TYPE;
    
    // message type (mobile)
    typedef enum tagNET_MISSION_MESSAGE_TYPE
    {
        NET_MISSION_MESSAGE_TEXT = 0 ,      //text info
        NET_MISSION_MESSAGE_AD ,            //ad info
        NET_MISSION_MESSAGE_BROAD ,         //broadcast info
        NET_MISSION_MESSAGE_DRIVER ,        //driver info
        NET_MISSION_MESSAGE_DISPATCH ,      //dispatch command
        NET_MISSION_MESSAGE_TRANSPARENT ,   //transparent data
        NET_MISSION_MESSAGE_URGENT,         // emergency
        NET_MISSION_MESSAGE_MAX ,
    }NET_MISSION_MESSAGE_TYPE;
    
    // CLIENT_AddMission()port input parameter
    typedef struct tagNET_IN_ADD_MISSION
    {
        DWORD           dwSize;
        char            szTitle[DH_COMMON_STRING_256];      // task name
        char            szMissionID[DH_COMMON_STRING_256];  // task ID
        char            szComment[DH_COMMON_STRING_256];    // replay content
        NET_MISSION_FEEDBACK_TYPE   emFeedBack;             // feedback type after adding
        NET_MISSION_MESSAGE_TYPE    emMessageType;          // message type
    }NET_IN_ADD_MISSION;
    
    // CLIENT_AddMission() port output parameter
    typedef struct tagNET_OUT_ADD_MISSION
    {
        DWORD           dwSize;
    }NET_OUT_ADD_MISSION;
    
    // CLIENT_ParkingControlStartFind port input parameter
    typedef struct tagNET_IN_PARKING_CONTROL_START_FIND_PARAM
    {
        DWORD                     dwSize;          // structure size
        BOOL                      bSearchCount;    // Search if record call is valid
        DWORD                     dwSearchCount;   // Search record item, value range is 1~100
        BOOL                      bBegin;          // Search if start time is valid
        NET_TIME                  stuBegin;        // Search start time
        BOOL                      bEnd;            // Search if end time is valid
        NET_TIME                  stuEnd;          // Search end time
        BOOL                      bCardType;       // If card type is valid
        NET_ECK_IC_CARD_USER_TYPE emCardType;      // Card type
        BOOL                      bFlag;           // If car pass mark is valid
        NET_ECK_CAR_PASS_FLAG     emFlag;          // Car pass mark
    } NET_IN_PARKING_CONTROL_START_FIND_PARAM;
    
    // CLIENT_ParkingControlStartFind port output parameter
    typedef struct tagNET_OUT_PARKING_CONTROL_START_FIND_PARAM
    {
        DWORD                     dwSize;          // structure size
        DWORD                     dwTotalCount;    // Result number match the search criteria
    } NET_OUT_PARKING_CONTROL_START_FIND_PARAM;
    
    // CLIENT_ParkingControlDoFind port input parameter
    typedef struct tagNET_IN_PARKING_CONTROL_DO_FIND_PARAM
    {
        DWORD                     dwSize;          // structure size
        DWORD                     dwFileCount;     // Currently record item number to search
    } NET_IN_PARKING_CONTROL_DO_FIND_PARAM;
    
    // Car pass record info
    typedef struct tagNET_CAR_PASS_ITEM
    {
        DWORD                      dwSize;
        NET_TIME                   stuTime;          // Car pass time
        DWORD                      dwCardNo;         // Card no.
        NET_ECK_IC_CARD_USER_TYPE  emCardType;       // Card type
        NET_ECK_CAR_PASS_FLAG      emFlag;           // Car pass record type
    } NET_CAR_PASS_ITEM;
    
    // CLIENT_ParkingControlDoFind port output parameter
    typedef struct tagNET_OUT_PARKING_CONTROL_DO_FIND_PARAM
    {
        DWORD                     dwSize;          // structure size
        NET_CAR_PASS_ITEM        *pstuRecordList;  // Record list, user allocate memory
        int                       nMaxRecordNum;   // List record number
        int                       nRetRecordNum;   // Searched record items, current searched item number is lower than designated item number, search end
    } NET_OUT_PARKING_CONTROL_DO_FIND_PARAM;
    
    // Order car pass record data call function origin
    typedef void (CALLBACK *fParkingControlRecordCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CAR_PASS_ITEM *pInfo, int nBufLen, LDWORD dwUser);
    
    // CLIENT_ParkingControlAttachRecord() port input parameter
    typedef struct tagNET_IN_PARKING_CONTROL_PARAM
    {
        DWORD                           dwSize;
        fParkingControlRecordCallBack   cbCallBack;                 // Data call function
        LDWORD                          dwUser;                     // User custom parameter
    } NET_IN_PARKING_CONTROL_PARAM;
    
    // CLIENT_ParkingControlDetachRecord() port output parameter
    typedef struct tagNET_OUT_PARKING_CONTROL_PARAM
    {
        DWORD    dwSize;
    } NET_OUT_PARKING_CONTROL_PARAM;

    
    // Vehicle detector status
    typedef enum tagNET_CAR_DETECTOR_STATE
    {
        NET_CAR_DETECTOR_STATE_UNKNOWN = -1,
        NET_CAR_DETECTOR_STATE_OFFLINE = 0,                   // Offline
        NET_CAR_DETECTOR_STATE_ONLINE,                        // Online
        NET_CAR_DETECTOR_STATE_LOOPOFFLINE,                   // Senser coil offline
    } NET_CAR_DETECTOR_STATE;
    
    // Sub device general status
    typedef enum tagNET_AUXILIARY_DEV_STATE
    {
        NET_AUXILIARY_DEV_STATE_UNKNOWN = -1,
        NET_AUXILIARY_DEV_STATE_OFFLINE = 0,                   // offline
        NET_AUXILIARY_DEV_STATE_ONLINE,                        // online
    } NET_AUXILIARY_DEV_STATE;
    
    // Device IC card quantity condition
    typedef enum tagNET_IC_CARD_STATUS
    {
        NET_IC_CARD_STATUS_UNKNOWN = -1,
        NET_IC_CARD_STATUS_NORMAL = 0,                         // Normal
        NET_IC_CARD_STATUS_NOCARD,                             // No card
        NET_IC_CARD_STATUS_LOWCARD,                            // Few
        NET_IC_CARD_STATUS_FULLCARDS,                          // Full
    } NET_IC_CARD_STATUS;
    
    // auxiliary work mode type
    typedef enum tagNET_AUXILIARY_WORK_MODE
    {
        NET_AUXILIARY_WORK_MODE_UNKNOWN = 0,
        NET_AUXILIARY_WORK_MODE_OFFLINE,                       // working offline
        NET_AUXILIARY_WORK_MODE_ONLINE,                        // working online
    } NET_AUXILIARY_WORK_MODE;
    
    // Alarm event type DH_ALARM_AUXILIARY_DEV_STATE(sub device status event)corresponding data description info
    typedef struct tagALARM_AUXILIARY_DEV_STATE
    {
        DWORD                   dwSize;
        NET_CAR_DETECTOR_STATE  emDetector;                   // Vehicle detector status
        NET_AUXILIARY_DEV_STATE emLed;                        // LED status lattice screen status
        NET_AUXILIARY_DEV_STATE emICDetectBoard;              // Panel swiping card board
        NET_AUXILIARY_DEV_STATE emICSenderBoard;              // Issuing card swiping cardboard
        NET_IC_CARD_STATUS      emICCardStatus;               // Device IC card quantity condition
        NET_AUXILIARY_WORK_MODE emWorkMode;                   // working mode
    } ALARM_AUXILIARY_DEV_STATE;
    
    // Parking issuing card swiping card type
    typedef enum tagNET_PARKING_CARD_TYPE
    {
        NET_PARKING_CARD_TYPE_UNKNOWN,
        NET_PARKING_CARD_TYPE_SEND,                             // Issue card
        NET_PARKING_CARD_TYPE_DETECT,                           // Swipe card
    } NET_PARKING_CARD_TYPE;
    
    // Alarm event type DH_ALARM_PARKING_CARD(parking swipe card event)corresponding data description info
    typedef struct tagALARM_PARKING_CARD
    {
        DWORD                   dwSize;
        NET_PARKING_CARD_TYPE   emType;                       // Type
        DWORD                   dwCardNo;                     // Card no.
        char                    szPlate[DH_COMMON_STRING_16]; // Plate
    } ALARM_PARKING_CARD;
    
    // The type of alarm source device
    typedef enum tagEM_ALARM_TRANSMIT_DEV_SRC_TYPE
    {
        EM_ALARM_TRANSMIT_DEV_SRC_TYPE_UNKNOWN,             // Unknown
        EM_ALARM_TRANSMIT_DEV_SRC_TYPE_DIGIT,               // Digit
        EM_ALARM_TRANSMIT_DEV_SRC_TYPE_ANALOG,              // Analog
        EM_ALARM_TRANSMIT_DEV_SRC_TYPE_SMARTLOCK,           // SmartLock
    }EM_ALARM_TRANSMIT_DEV_SRC_TYPE;
    
    // alarm transmit alarm type
    typedef enum tagEM_ALARM_TRANSMIT_ALARM_TYPE
    {
        EM_ALARM_TRANSMIT_ALARM_TYPE_UNKNOWN,               // unknown
        EM_ALARM_TRANSMIT_ALARM_TYPE_PREVENTREMOVE,         // PreventRemove
        EM_ALARM_TRANSMIT_ALARM_TYPE_LOWERPOWER,            // LowerPower
        EM_ALARM_TRANSMIT_ALARM_TYPE_KEY,                   // Key
        EM_ALARM_TRANSMIT_ALARM_TYPE_DURESS,                // Duress
    }EM_ALARM_TRANSMIT_ALARM_TYPE;
    
    // Alarm transmission event (Corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
    typedef struct tagALARM_PROFILE_ALARM_TRANSMIT_INFO
    {
        DWORD                           dwSize;
        int					            nChannelID;								// channel number
        int					            nAction;								// 0:Start 1:Stop
        NET_TIME                        stuTime;                                // time-to-event
        NET_SENSE_METHOD                emSenseMethod;                          // Sensor Type
        char                            szUserID[DH_COMMON_STRING_128];         // Alarm users, to distinguish    
        EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // The type of alarm source device 
        EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // alarm transmit alarm type
    }ALARM_PROFILE_ALARM_TRANSMIT_INFO;
    
    
    // Parking Spaces of the intelligent parking systems
    typedef enum tagNET_ECK_PARK_STATE
    {
        NET_ECK_PARK_STATE_UNKOWN,
        NET_ECK_PARK_STATE_PARK,                     // Parking cars
        NET_ECK_PARK_STATE_NOPARK,                   // No car parking Spaces
    } NET_ECK_PARK_STATE;
    
    // Parking information
    typedef struct tagNET_PARK_INFO_ITEM
    {
        DWORD                      dwSize;
        char                       szParkNo[DH_COMMON_STRING_32];   // Parking number
        NET_ECK_PARK_STATE         emState;                         // Parking state
        DWORD                      dwScreenIndex;                   // GuideScreen index according to parking number
        DWORD                      dwFreeParkNum;                   // Free count of parking space
    } NET_PARK_INFO_ITEM;
    
    // Subscribe to the parking information callback function prototypes
    typedef void (CALLBACK *fParkInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_PARK_INFO_ITEM *pInfo, int nBufLen, LDWORD dwUser);
    
    // Parking space detector type
    typedef enum tagNET_ECK_PARK_DETECTOR_TYPE
    {
        NET_ECK_PARK_DETECTOR_TYPE_SONIC,                     // ultrasonic detector
        NET_ECK_PARK_DETECTOR_TYPE_CAMERA,                    // The camera detector
        NET_ECK_PARK_DETECTOR_TYPE_ALL,
    } NET_ECK_PARK_DETECTOR_TYPE;
    
    // Parking space detector information query condition
    
    typedef struct tagNET_PARK_INFO_FILTER
    {
        DWORD                      dwSize;
        DWORD                      dwNum;                                  // Parking space detector type number
        NET_ECK_PARK_DETECTOR_TYPE emType[NET_ECK_PARK_DETECTOR_TYPE_ALL]; // Parking space detector type
    } NET_PARK_INFO_FILTER;
    
    // CLIENT_ParkingControlAttachParkInfo()Interface input parameters
    typedef struct tagNET_IN_PARK_INFO_PARAM
    {
        DWORD                           dwSize;
        NET_PARK_INFO_FILTER            stuFilter;
        fParkInfoCallBack               cbCallBack;                 // Data callback function
        LDWORD                          dwUser;                     // User defined parameters
    } NET_IN_PARK_INFO_PARAM;
    
    // CLIENT_ParkingControlAttachParkInfo()Interface output parameters
    typedef struct tagNET_OUT_PARK_INFO_PARAM
    {
        DWORD    dwSize;
    } NET_OUT_PARK_INFO_PARAM;

    
    
    ////////////////////////////////////////////////////////////////////////////////
    // Net applications, operation type
    typedef enum tagEM_RPC_NETAPP_TYPE
    {
        EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT,      //  get statistics of net resource, pstuIn: NET_IN_NETAPP_GET_NET_RESOURCE_STAT*??pstuOut: NET_OUT_NETAPP_GET_NET_RESOURCE_STAT*
    }EM_RPC_NETAPP_TYPE;
    
    // EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, input param
    typedef struct tagNET_IN_NETAPP_GET_NET_RESOURCE_STAT
    {
        DWORD               dwSize;
    }NET_IN_NETAPP_GET_NET_RESOURCE_STAT;
    
    // EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, output param
    typedef struct tagNET_OUT_NETAPP_GET_NET_RESOURCE_STAT
    {
        DWORD               dwSize;
        int                 nIPChanneIn;             // IP channel in bandwidth, unit: kbps
        int                 nNetRemain;              // Net remain bandwidth, unit: kbps
        int                 nNetCapability;          // Net total bandwidth, unit: Mbps
        int                 nRemotePreview;          // Remote preview bandwidth, unit: kbps
        int                 nRemotePlayAndDownload;  // Remote playback and download bandwidth, unit: kbps
        int                 nRemoteSendRemain;       // Remote send remain bandwidth, unit: kbps
        int                 nRemoteSendCapability;   // Remote send total bandwidth, unit: Mbps
    }NET_OUT_NETAPP_GET_NET_RESOURCE_STAT;

    
    
#ifdef __cplusplus
}
#endif
    
#endif /* dahua_defs_h */
